---
title: "Node.js — Fundamentos e Boas Práticas"
description: "Runtime, módulos, npm, error handling idiomático, estrutura de projetos, variáveis de ambiente, debugging e as boas práticas que separam código amador de código de produção"
track: "backend"
order: 2
section: "Node.js"
priority: "high"
tags: ["nodejs", "runtime", "npm", "módulos", "error-handling", "boas-práticas", "debugging"]
prerequisites: []
keyTakeaways:
  - "Node.js é um runtime JavaScript construído sobre o V8 do Chrome com libuv para I/O assíncrono — não é um framework, é uma plataforma"
  - "CommonJS (require) vs ESModules (import): ESM é o padrão moderno, mas CJS ainda domina o ecossistema legado — saiba navegar nos dois"
  - "npm/pnpm/yarn gerenciam dependências via package.json e lockfiles — nunca commite node_modules, sempre commite o lockfile"
  - "Error handling em Node.js exige disciplina: erros operacionais vs erros de programação, try/catch em async/await, e process.on('uncaughtException')"
  - "Variáveis de ambiente (.env), graceful shutdown (SIGTERM/SIGINT) e health checks são o mínimo para rodar em produção"
---

## O que é Node.js

Node.js **não é um framework**. É um **runtime** — um ambiente de execução para JavaScript fora do browser. Criado por Ryan Dahl em 2009, nasceu da frustração com o modelo thread-per-request do Apache e da observação de que a maioria das aplicações web gasta a maior parte do tempo esperando I/O (rede, disco, banco de dados), não executando computação.

A arquitetura do Node.js é composta por duas peças fundamentais:

- **V8**: o engine JavaScript do Chrome. Compila JavaScript para código de máquina via JIT (Just-In-Time compilation) usando o compilador otimizador TurboFan. É o mesmo engine que roda no Google Chrome — rápido, bem mantido, com garbage collector geracional (Scavenger para a young generation, Mark-Sweep-Compact para a old generation).

- **libuv**: biblioteca C que implementa o Event Loop, a thread pool e a abstração de I/O assíncrono cross-platform. O libuv usa epoll no Linux, kqueue no macOS e IOCP no Windows. É o que permite que Node.js faça I/O não-bloqueante em todas as plataformas.

```
┌─────────────────────────────────────────────────────────────┐
│                    ARQUITETURA NODE.JS                       │
│                                                             │
│  ┌───────────────────────────────────────────────────────┐  │
│  │              Seu Código JavaScript/TypeScript          │  │
│  └──────────────────────────┬────────────────────────────┘  │
│                              │                              │
│  ┌───────────────────────────▼───────────────────────────┐  │
│  │                Node.js Bindings (C++)                  │  │
│  │  Ponte entre JavaScript e as bibliotecas C nativas    │  │
│  └────────┬──────────────────────────────┬───────────────┘  │
│           │                              │                  │
│  ┌────────▼────────┐           ┌─────────▼──────────────┐  │
│  │    V8 Engine     │           │        libuv            │  │
│  │                  │           │                         │  │
│  │  - JIT compile   │           │  - Event Loop           │  │
│  │  - Garbage       │           │  - Thread Pool (4)      │  │
│  │    Collection    │           │  - Async I/O            │  │
│  │  - Memory mgmt   │           │  - epoll/kqueue/IOCP   │  │
│  └──────────────────┘           └─────────────────────────┘  │
│                                                             │
│  ┌───────────────────────────────────────────────────────┐  │
│  │           APIs Nativas (C/C++)                         │  │
│  │  fs, net, http, crypto, zlib, dns, child_process...   │  │
│  └───────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

### Onde Node.js brilha

Node.js é excelente para **aplicações I/O-bound**: servidores HTTP, APIs REST/GraphQL, proxies, real-time apps (WebSocket, SSE), ferramentas CLI, scripts de automação, BFFs (Backend for Frontend). O modelo single-threaded com I/O não-bloqueante permite lidar com milhares de conexões simultâneas com pouca memória.

### Onde Node.js não brilha

Para **trabalho CPU-bound** — processamento de imagem, criptografia pesada, machine learning, cálculos científicos — Node.js é uma escolha ruim. Uma operação síncrona pesada bloqueia o Event Loop e trava todas as requisições. Existem mitigações (worker_threads, child_process), mas se o workload é predominantemente CPU-bound, linguagens como Go, Rust ou Python (com NumPy/PyTorch) são escolhas mais naturais.

```javascript
// Exemplo: por que CPU-bound é problemático em Node.js
const http = require('http');

const server = http.createServer((req, res) => {
  if (req.url === '/heavy') {
    // Bloqueia o Event Loop por vários segundos
    // TODAS as outras requisições ficam paradas esperando
    const result = fibonacci(45);
    res.end(`Resultado: ${result}`);
  } else {
    res.end('OK');
  }
});

function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

server.listen(3000);
// Se alguém chama /heavy, NINGUÉM mais recebe resposta
// até o fibonacci(45) terminar (~7 segundos).
```

---

## Sistema de Módulos

Node.js possui dois sistemas de módulos: **CommonJS (CJS)**, que é o original, e **ECMAScript Modules (ESM)**, que é o padrão do JavaScript moderno. Entender os dois é obrigatório porque o ecossistema está em transição ativa.

### CommonJS (CJS)

CommonJS foi o sistema de módulos original do Node.js. Usa `require()` para importar e `module.exports` (ou `exports`) para exportar.

```javascript
// math.js — exportando com CommonJS
function soma(a, b) {
  return a + b;
}

function multiplica(a, b) {
  return a * b;
}

module.exports = { soma, multiplica };
// ou: exports.soma = soma; exports.multiplica = multiplica;

// app.js — importando com CommonJS
const { soma, multiplica } = require('./math');
const fs = require('fs');          // módulo nativo
const express = require('express'); // módulo de terceiros (node_modules)

console.log(soma(2, 3)); // 5
```

Características importantes do CJS:

- **Síncrono**: `require()` bloqueia a execução até o módulo ser carregado e avaliado. Por isso funciona bem no servidor (arquivos locais), mas seria problemático no browser.
- **Cache**: módulos são cacheados após o primeiro `require()`. Chamadas subsequentes retornam o mesmo objeto da memória.
- **Dinâmico**: `require()` pode ser chamado em qualquer lugar do código, inclusive dentro de condicionais.
- **`__dirname` e `__filename`**: disponíveis automaticamente em cada módulo CJS.

```javascript
// require() é dinâmico — funciona dentro de condicionais
if (process.env.NODE_ENV === 'development') {
  const devTools = require('./dev-tools'); // só carrega em dev
  devTools.setup();
}

// O cache do require pode ser inspecionado e invalidado (use com cautela)
console.log(require.cache);
delete require.cache[require.resolve('./math')]; // força re-load
```

### ECMAScript Modules (ESM)

ESM é o padrão oficial do JavaScript, definido na spec ECMAScript. Usa `import` e `export`.

```javascript
// math.mjs — exportando com ESM
export function soma(a, b) {
  return a + b;
}

export function multiplica(a, b) {
  return a * b;
}

// ou export default para um único export principal
export default class Calculator {
  add(a, b) { return a + b; }
}

// app.mjs — importando com ESM
import { soma, multiplica } from './math.mjs';
import Calculator from './math.mjs';
import fs from 'node:fs';             // prefixo node: para módulos nativos
import { readFile } from 'node:fs/promises';
```

Características importantes do ESM:

- **Assíncrono**: imports são resolvidos em tempo de análise (parse time), antes da execução. Isso permite tree-shaking e análise estática.
- **Estático**: a sintaxe `import`/`export` deve estar no top-level do módulo. Não pode estar dentro de condicionais.
- **`import()` dinâmico**: existe uma versão dinâmica que retorna uma Promise — útil para code splitting e lazy loading.
- **Sem `__dirname`/`__filename`**: essas variáveis não existem em ESM. Existem alternativas.

```javascript
// import() dinâmico — carregamento condicional em ESM
const moduloAdmin = await import('./admin.js');

// __dirname e __filename em ESM — alternativas
import { fileURLToPath } from 'node:url';
import { dirname } from 'node:path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// A partir do Node.js 21.2+, existe import.meta.dirname e import.meta.filename
// const __dirname = import.meta.dirname;  // Node 21.2+
// const __filename = import.meta.filename; // Node 21.2+
```

### Como o Node.js decide entre CJS e ESM

O Node.js usa a seguinte hierarquia para determinar o sistema de módulos:

```
┌─────────────────────────────────────────────────────────┐
│  RESOLUÇÃO DO SISTEMA DE MÓDULOS                         │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. Extensão do arquivo:                                │
│     .mjs  → SEMPRE ESM                                  │
│     .cjs  → SEMPRE CJS                                  │
│     .js   → depende do package.json mais próximo        │
│                                                         │
│  2. Campo "type" no package.json:                       │
│     "type": "module"     → .js é tratado como ESM       │
│     "type": "commonjs"   → .js é tratado como CJS       │
│     (ausente)            → .js é tratado como CJS       │
│                                                         │
│  3. Flag --input-type na CLI:                           │
│     --input-type=module  → stdin/eval tratado como ESM  │
│     --input-type=commonjs → stdin/eval tratado como CJS │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

```json
// package.json — habilitando ESM para todo o projeto
{
  "name": "minha-api",
  "type": "module",
  "engines": {
    "node": ">=18"
  }
}
```

### Interoperabilidade CJS/ESM

```javascript
// ESM pode importar CJS (quase sempre funciona)
import express from 'express';      // pacote CJS importado de ESM — OK
import { readFileSync } from 'fs';  // módulo nativo — OK

// CJS NÃO pode usar require() para importar ESM
// const pkg = require('./esm-module.mjs'); // ERR_REQUIRE_ESM

// CJS pode importar ESM via import() dinâmico (retorna Promise)
async function main() {
  const esmModule = await import('./esm-module.mjs');
  console.log(esmModule.default);
}
main();
```

**Recomendação prática**: para projetos novos, use `"type": "module"` no package.json e escreva ESM. Para projetos legados, mantenha CJS a menos que tenha um bom motivo para migrar. A migração CJS → ESM em projetos grandes é trabalhosa e cheia de edge cases.

---

## npm e Gerenciamento de Pacotes

### Anatomia do package.json

O `package.json` é o manifesto do projeto. Cada campo tem uma função específica:

```json
{
  "name": "minha-api",
  "version": "1.2.0",
  "description": "API de gerenciamento de cervejarias",
  "type": "module",
  "main": "./dist/index.cjs",
  "module": "./dist/index.mjs",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "import": "./dist/index.mjs",
      "require": "./dist/index.cjs",
      "types": "./dist/index.d.ts"
    },
    "./utils": {
      "import": "./dist/utils.mjs",
      "require": "./dist/utils.cjs"
    }
  },
  "engines": {
    "node": ">=20.0.0"
  },
  "scripts": {
    "dev": "tsx watch src/server.ts",
    "build": "tsup src/index.ts --format cjs,esm --dts",
    "start": "node dist/index.mjs",
    "test": "vitest run",
    "test:watch": "vitest",
    "lint": "eslint src/",
    "format": "prettier --write 'src/**/*.ts'",
    "typecheck": "tsc --noEmit",
    "prepare": "husky"
  },
  "dependencies": {
    "fastify": "^4.28.0",
    "zod": "^3.23.0",
    "pino": "^9.0.0"
  },
  "devDependencies": {
    "typescript": "^5.5.0",
    "vitest": "^2.0.0",
    "tsx": "^4.16.0",
    "eslint": "^9.0.0",
    "prettier": "^3.3.0",
    "@types/node": "^22.0.0"
  }
}
```

### Semver (Semantic Versioning)

Cada pacote segue (ou deveria seguir) semver: `MAJOR.MINOR.PATCH`.

```
┌─────────────────────────────────────────────────────────┐
│  SEMVER: MAJOR.MINOR.PATCH                               │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  MAJOR (1.x.x → 2.0.0)                                 │
│    Breaking changes. API pública mudou de forma          │
│    incompatível. Seu código pode quebrar ao atualizar.   │
│                                                         │
│  MINOR (1.1.x → 1.2.0)                                 │
│    Nova funcionalidade, backwards-compatible.            │
│    Atualizar deve ser seguro.                            │
│                                                         │
│  PATCH (1.1.1 → 1.1.2)                                 │
│    Bug fix, backwards-compatible.                        │
│    Atualizar deve ser seguro.                            │
│                                                         │
├─────────────────────────────────────────────────────────┤
│  RANGE SYNTAX NO package.json                            │
│                                                         │
│  ^4.28.0  → >=4.28.0 e <5.0.0  (mais comum)            │
│  ~4.28.0  → >=4.28.0 e <4.29.0                          │
│  4.28.0   → exatamente 4.28.0                            │
│  >=4.28.0 → qualquer versão >= 4.28.0                    │
│  *        → qualquer versão (nunca use em produção)      │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Lockfiles: por que são obrigatórios

O `package-lock.json` (npm), `pnpm-lock.yaml` (pnpm) ou `yarn.lock` (yarn) trava as versões exatas de **todas** as dependências (incluindo transitivas). Sem lockfile, dois `npm install` em momentos diferentes podem gerar `node_modules` com versões diferentes — mesmo com o mesmo `package.json`.

```bash
# REGRA DE OURO:
# - SEMPRE commite o lockfile no git
# - NUNCA commite a pasta node_modules
# - Em CI, use npm ci (não npm install) — respeita o lockfile ao pé da letra

# .gitignore essencial
echo "node_modules/" >> .gitignore

# Em CI/CD:
npm ci          # Instala exatamente o que está no lockfile
                # Apaga node_modules existente antes de instalar
                # Falha se package-lock.json estiver desatualizado

# Para desenvolvimento:
npm install     # Pode atualizar o lockfile se as ranges permitirem
```

### Scripts npm

Scripts são o ponto de entrada padronizado para qualquer operação do projeto:

```bash
# Scripts com lifecycle hooks
npm test       # roda "pretest" → "test" → "posttest"
npm start      # roda "prestart" → "start" → "poststart"
npm run build  # roda "prebuild" → "build" → "postbuild"

# npx: executa binários de pacotes sem instalar globalmente
npx create-next-app@latest      # baixa e executa
npx tsx src/script.ts            # executa TypeScript diretamente
npx eslint --fix src/            # usa o eslint do projeto ou baixa

# npm workspaces (monorepo nativo)
# package.json raiz:
# { "workspaces": ["packages/*"] }
npm install -w packages/api      # instala deps de um workspace específico
npm run build -w packages/shared # roda script de um workspace
npm run test --workspaces        # roda em todos os workspaces
```

### pnpm como alternativa

O pnpm é um gerenciador de pacotes alternativo que resolve problemas reais do npm:

```bash
# npm: node_modules flat com hoisting (pode acessar deps não declaradas)
# pnpm: node_modules com symlinks — strict isolation

npm install -g pnpm

# O node_modules do pnpm usa um content-addressable store global
# Se 10 projetos usam lodash@4.17.21, o arquivo existe UMA vez no disco
# Economia significativa de espaço e tempo de install

pnpm install           # equivalente ao npm install
pnpm add fastify       # equivalente ao npm install fastify
pnpm add -D vitest     # equivalente ao npm install --save-dev vitest
pnpm run dev           # equivalente ao npm run dev

# Strictness: pnpm não permite acessar dependências não declaradas
// import lodash from 'lodash';
// Se lodash não está no SEU package.json (mesmo que seja dep transitiva),
// pnpm vai bloquear o import. npm permitiria silenciosamente.
// Isso previne bugs onde seu código depende de uma dep fantasma.
```

---

## Estrutura de Projetos

Não existe um padrão oficial, mas a comunidade convergiu em convenções sólidas. A estrutura abaixo funciona para APIs de tamanho médio a grande:

```
minha-api/
├── src/
│   ├── config/
│   │   ├── env.ts              # Validação de variáveis de ambiente
│   │   ├── database.ts         # Configuração do banco
│   │   └── logger.ts           # Configuração do logger
│   ├── modules/
│   │   ├── users/
│   │   │   ├── users.controller.ts
│   │   │   ├── users.service.ts
│   │   │   ├── users.repository.ts
│   │   │   ├── users.schema.ts    # Validação com Zod/Joi
│   │   │   ├── users.routes.ts
│   │   │   └── users.test.ts
│   │   └── beers/
│   │       ├── beers.controller.ts
│   │       ├── beers.service.ts
│   │       └── ...
│   ├── shared/
│   │   ├── errors/
│   │   │   ├── app-error.ts       # Classe base de erros
│   │   │   └── error-handler.ts   # Middleware global de erros
│   │   ├── middleware/
│   │   │   ├── auth.ts
│   │   │   └── rate-limit.ts
│   │   └── utils/
│   │       └── pagination.ts
│   ├── server.ts               # Configuração do servidor HTTP
│   └── app.ts                  # Entry point da aplicação
├── tests/
│   ├── integration/
│   └── e2e/
├── .env.example                # Template das variáveis (sem valores reais)
├── .env                        # Valores reais (NÃO commitar)
├── .gitignore
├── package.json
├── tsconfig.json
└── vitest.config.ts
```

### Gerenciamento de variáveis de ambiente

Variáveis de ambiente são a forma padrão de configurar aplicações em produção (12-factor app). Em desenvolvimento, usamos arquivos `.env` com o pacote `dotenv` ou o suporte nativo do Node.js 20+.

```typescript
// src/config/env.ts — validação rigorosa com Zod
import { z } from 'zod';

const envSchema = z.object({
  NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),
  PORT: z.coerce.number().int().positive().default(3000),
  DATABASE_URL: z.string().url(),
  JWT_SECRET: z.string().min(32, 'JWT_SECRET deve ter pelo menos 32 caracteres'),
  REDIS_URL: z.string().url().optional(),
  LOG_LEVEL: z.enum(['fatal', 'error', 'warn', 'info', 'debug', 'trace']).default('info'),
  CORS_ORIGIN: z.string().default('*'),
});

// Faz parse e valida — se faltar variável obrigatória, a aplicação
// falha IMEDIATAMENTE no startup, não 3 horas depois quando alguém
// tenta logar e descobre que JWT_SECRET é undefined.
function validateEnv() {
  const result = envSchema.safeParse(process.env);

  if (!result.success) {
    console.error('Variáveis de ambiente inválidas:');
    console.error(result.error.format());
    process.exit(1);
  }

  return result.data;
}

export const env = validateEnv();

// Uso em qualquer lugar do projeto:
// import { env } from '@/config/env';
// const port = env.PORT; // number, tipado, validado
```

```bash
# .env.example (comitado no git — template sem valores reais)
NODE_ENV=development
PORT=3000
DATABASE_URL=postgresql://user:pass@localhost:5432/mydb
JWT_SECRET=troque-isso-por-um-valor-real-de-pelo-menos-32-chars
REDIS_URL=redis://localhost:6379
LOG_LEVEL=debug

# .env (NÃO comitado — valores reais)
# Crie copiando o .env.example e preenchendo os valores

# Node.js 20+ suporta .env nativo (sem dotenv):
node --env-file=.env src/app.js

# Para versões anteriores, use dotenv:
# npm install dotenv
# No topo do entry point: import 'dotenv/config';
```

---

## Error Handling Idiomático

Error handling é onde a maturidade de um desenvolvedor Node.js fica evidente. A diferença entre código amador e código de produção é a disciplina no tratamento de erros.

### Erros operacionais vs erros de programação

Esta é a distinção mais importante em Node.js:

```
┌─────────────────────────────────────────────────────────┐
│  ERROS OPERACIONAIS                                      │
│  (esperados, tratáveis, parte da lógica de negócio)      │
├─────────────────────────────────────────────────────────┤
│  - Conexão com banco de dados recusada                   │
│  - Timeout em requisição HTTP para serviço externo       │
│  - Arquivo não encontrado                                │
│  - Input do usuário inválido                             │
│  - Rate limit excedido                                   │
│  - Disco cheio                                           │
│                                                         │
│  TRATAMENTO: recuperar, retornar erro adequado ao        │
│  cliente, retry com backoff, fallback para cache         │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ERROS DE PROGRAMAÇÃO                                    │
│  (bugs, nunca deveriam acontecer)                        │
├─────────────────────────────────────────────────────────┤
│  - TypeError: Cannot read property of undefined          │
│  - RangeError: array index fora dos limites              │
│  - Chamar uma função com argumentos errados              │
│  - Assertion failure                                     │
│  - Leak de memória                                       │
│                                                         │
│  TRATAMENTO: logar, crashar o processo, corrigir o       │
│  código. NÃO tente recuperar — o estado é corrompido.    │
└─────────────────────────────────────────────────────────┘
```

### Custom Error Classes

```typescript
// src/shared/errors/app-error.ts
export class AppError extends Error {
  public readonly statusCode: number;
  public readonly code: string;
  public readonly isOperational: boolean;

  constructor(
    message: string,
    statusCode: number,
    code: string,
    isOperational = true
  ) {
    super(message);
    this.statusCode = statusCode;
    this.code = code;
    this.isOperational = isOperational;

    // Necessário para instanceof funcionar com classes que estendem Error
    Object.setPrototypeOf(this, new.target.prototype);

    // Captura o stack trace excluindo o constructor
    Error.captureStackTrace(this, this.constructor);
  }
}

export class NotFoundError extends AppError {
  constructor(resource: string, id: string) {
    super(
      `${resource} com id '${id}' não encontrado`,
      404,
      'RESOURCE_NOT_FOUND'
    );
  }
}

export class ValidationError extends AppError {
  public readonly errors: Array<{ field: string; message: string }>;

  constructor(errors: Array<{ field: string; message: string }>) {
    super('Dados de entrada inválidos', 422, 'VALIDATION_ERROR');
    this.errors = errors;
  }
}

export class ConflictError extends AppError {
  constructor(message: string) {
    super(message, 409, 'CONFLICT');
  }
}

export class UnauthorizedError extends AppError {
  constructor(message = 'Autenticação necessária') {
    super(message, 401, 'UNAUTHORIZED');
  }
}
```

### try/catch com async/await

```typescript
// O padrão correto para async/await
async function getUser(id: string) {
  try {
    const user = await db.users.findUnique({ where: { id } });

    if (!user) {
      throw new NotFoundError('User', id);
    }

    return user;
  } catch (error) {
    // Re-throw erros operacionais (AppError) — serão tratados pelo error handler
    if (error instanceof AppError) {
      throw error;
    }

    // Erros inesperados: logar e lançar erro genérico
    logger.error({ err: error, userId: id }, 'Erro ao buscar usuário');
    throw new AppError('Erro interno do servidor', 500, 'INTERNAL_ERROR', false);
  }
}

// ANTI-PATTERN: engolir erros silenciosamente
async function getUserBad(id: string) {
  try {
    return await db.users.findUnique({ where: { id } });
  } catch (error) {
    console.log('deu erro'); // Log inútil, sem contexto
    return null;              // Engoliu o erro — o chamador nunca sabe o que houve
  }
}
```

### Error handler global (middleware)

```typescript
// src/shared/errors/error-handler.ts
import type { FastifyError, FastifyReply, FastifyRequest } from 'fastify';
import { AppError } from './app-error.js';

export function errorHandler(
  error: FastifyError,
  request: FastifyRequest,
  reply: FastifyReply
) {
  // Erros operacionais (AppError) — retornar ao cliente
  if (error instanceof AppError) {
    return reply.status(error.statusCode).send({
      type: `https://api.example.com/errors/${error.code.toLowerCase()}`,
      title: error.message,
      status: error.statusCode,
      code: error.code,
      ...(error instanceof ValidationError && { errors: error.errors }),
      trace_id: request.id,
    });
  }

  // Erros de validação do Fastify/Zod
  if (error.validation) {
    return reply.status(422).send({
      type: 'https://api.example.com/errors/validation_error',
      title: 'Dados de entrada inválidos',
      status: 422,
      errors: error.validation,
      trace_id: request.id,
    });
  }

  // Erros inesperados — NUNCA expor detalhes internos ao cliente
  logger.error(
    {
      err: error,
      request_id: request.id,
      method: request.method,
      url: request.url,
    },
    'Erro não tratado'
  );

  return reply.status(500).send({
    type: 'https://api.example.com/errors/internal_error',
    title: 'Erro interno do servidor',
    status: 500,
    trace_id: request.id,
    // NÃO incluir error.message ou error.stack em produção
  });
}
```

### Tratamento de erros não capturados

```typescript
// No entry point da aplicação (app.ts ou server.ts)

// Promessas rejeitadas sem catch
process.on('unhandledRejection', (reason: unknown) => {
  logger.fatal({ err: reason }, 'Unhandled Promise Rejection');
  // Em produção, considere crashar o processo — o estado pode estar corrompido
  // O process manager (PM2, Docker, Kubernetes) reinicia automaticamente
  process.exit(1);
});

// Exceções não capturadas
process.on('uncaughtException', (error: Error) => {
  logger.fatal({ err: error }, 'Uncaught Exception');
  // SEMPRE crashar após uncaughtException — o estado é irrecuperável
  process.exit(1);
});

// NOTA IMPORTANTE:
// A partir do Node.js 15+, unhandledRejection causa crash por padrão.
// Antes do Node 15, apenas emitia um warning. Se você roda Node 14 ou
// anterior, a flag --unhandled-rejections=throw força o crash.
```

### Error-first callbacks (legado)

O padrão original do Node.js para lidar com erros assíncronos. Ainda aparece em APIs nativas e bibliotecas antigas:

```javascript
// Padrão error-first: o primeiro argumento do callback é sempre o erro
const fs = require('fs');

fs.readFile('/etc/passwd', 'utf8', (err, data) => {
  if (err) {
    // SEMPRE verificar o erro antes de usar data
    console.error('Falha ao ler arquivo:', err.message);
    return;
  }
  console.log(data);
});

// Versão moderna com Promises (preferível)
import { readFile } from 'node:fs/promises';

try {
  const data = await readFile('/etc/passwd', 'utf8');
  console.log(data);
} catch (err) {
  console.error('Falha ao ler arquivo:', err.message);
}

// Converter callback para Promise (quando necessário)
import { promisify } from 'node:util';
const readFileAsync = promisify(fs.readFile);
// Mas prefira usar node:fs/promises diretamente.
```

---

## Debugging e Profiling

### O flag --inspect e Chrome DevTools

Node.js possui um debugger integrado que se conecta ao Chrome DevTools. É a ferramenta mais poderosa que poucos desenvolvedores usam.

```bash
# Iniciar com debugger ativo (para em breakpoints)
node --inspect src/server.js

# Iniciar pausado na primeira linha (útil para debugging de startup)
node --inspect-brk src/server.js

# Com TypeScript (usando tsx)
node --inspect -r tsx/register src/server.ts

# Abrir Chrome DevTools:
# 1. Abra chrome://inspect no Chrome
# 2. Clique em "Open dedicated DevTools for Node"
# 3. Ou use a extensão "Node.js DevTools Manager"
```

No Chrome DevTools conectado ao Node.js, você tem acesso a:

- **Breakpoints**: pause a execução em qualquer linha
- **Watch expressions**: monitore variáveis em tempo real
- **Call stack**: veja a pilha de chamadas completa
- **Scope**: inspecione variáveis locais e de closure
- **Memory profiler**: tire heap snapshots para encontrar memory leaks
- **CPU profiler**: identifique funções que consomem mais CPU
- **Console**: execute código no contexto da aplicação pausada

### Console methods além do .log

```javascript
// console.table — formata arrays/objetos como tabela
const users = [
  { name: 'Alice', role: 'admin', active: true },
  { name: 'Bob', role: 'user', active: false },
];
console.table(users);
// ┌─────────┬─────────┬─────────┬────────┐
// │ (index) │  name   │  role   │ active │
// ├─────────┼─────────┼─────────┼────────┤
// │    0    │ 'Alice' │ 'admin' │  true  │
// │    1    │  'Bob'  │ 'user'  │ false  │
// └─────────┴─────────┴─────────┴────────┘

// console.time / console.timeEnd — medir duração
console.time('query-usuarios');
const result = await db.query('SELECT * FROM users');
console.timeEnd('query-usuarios');
// query-usuarios: 23.456ms

// console.count — contar execuções
function processItem(item) {
  console.count('processItem chamada');
  // ...
}
// processItem chamada: 1
// processItem chamada: 2

// console.dir — inspecionar objetos com profundidade
console.dir(complexObject, { depth: null, colors: true });

// console.trace — print stack trace sem throw
function funcaoSuspeita() {
  console.trace('Quem chamou esta função?');
}

// console.assert — falha silenciosa se condição é true
console.assert(user.age >= 18, 'Usuário menor de idade:', user);
```

### Heap Snapshots para Memory Leaks

```javascript
// Tirar heap snapshot programaticamente
import v8 from 'node:v8';
import fs from 'node:fs';

function takeHeapSnapshot() {
  const snapshotStream = v8.writeHeapSnapshot();
  console.log(`Heap snapshot escrito em: ${snapshotStream}`);
  // Abra o arquivo .heapsnapshot no Chrome DevTools > Memory
}

// Exemplo de memory leak comum: event listeners não removidos
import { EventEmitter } from 'node:events';

const emitter = new EventEmitter();

function handleRequest(req, res) {
  // BUG: a cada request, um novo listener é adicionado e NUNCA removido
  emitter.on('data', (data) => {
    res.write(data);
  });
  // Após 10 listeners, Node emite warning:
  // "MaxListenersExceededWarning: Possible EventEmitter memory leak detected"
}

// CORREÇÃO: usar once() ou remover o listener quando não for mais necessário
function handleRequestFixed(req, res) {
  const handler = (data) => res.write(data);
  emitter.on('data', handler);

  res.on('close', () => {
    emitter.removeListener('data', handler);
  });
}
```

### Profiling de CPU

```bash
# Gerar profile V8 nativo
node --prof src/server.js
# Após rodar a carga, processar o log:
node --prof-process isolate-0x*.log > profile.txt
# O arquivo mostra as funções que mais consumiram CPU (ticks)

# Clinic.js — ferramenta visual completa
npx clinic doctor -- node src/server.js
# Gera relatório HTML com Event Loop delay, CPU, GC, handles

# Flame graph para identificar hot paths
npx clinic flame -- node src/server.js
# Mostra quais funções consomem mais tempo na call stack

# 0x — flame graph leve e rápido
npx 0x src/server.js
# Gera flame graph interativo em HTML
```

---

## Boas Práticas de Produção

### Graceful Shutdown

Quando o processo recebe SIGTERM (Docker stop, Kubernetes pod termination, deploy), ele deve encerrar de forma limpa: parar de aceitar novas conexões, esperar as requisições em andamento terminarem, fechar conexões com banco e serviços externos, e só então sair.

```typescript
// src/server.ts
import Fastify from 'fastify';
import { env } from './config/env.js';

const app = Fastify({ logger: true });

// ... registrar rotas, plugins, etc.

async function start() {
  try {
    await app.listen({ port: env.PORT, host: '0.0.0.0' });
    app.log.info(`Servidor rodando na porta ${env.PORT}`);
  } catch (err) {
    app.log.fatal(err);
    process.exit(1);
  }
}

async function gracefulShutdown(signal: string) {
  app.log.info(`Recebido ${signal}. Iniciando shutdown graceful...`);

  // Timeout de segurança — se o shutdown demorar demais, força saída
  const forceExitTimeout = setTimeout(() => {
    app.log.error('Shutdown graceful excedeu timeout. Forçando saída.');
    process.exit(1);
  }, 30_000); // 30 segundos

  try {
    // 1. Parar de aceitar novas conexões
    await app.close();
    app.log.info('Servidor HTTP fechado.');

    // 2. Fechar conexões com banco, Redis, filas, etc.
    await db.$disconnect();
    app.log.info('Conexão com banco fechada.');

    await redis.quit();
    app.log.info('Conexão com Redis fechada.');

    clearTimeout(forceExitTimeout);
    app.log.info('Shutdown graceful concluído.');
    process.exit(0);
  } catch (err) {
    app.log.error({ err }, 'Erro durante shutdown graceful');
    process.exit(1);
  }
}

// Capturar sinais de terminação
process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));

start();
```

### Health Checks

Todo serviço em produção precisa de endpoints de health check. São usados por load balancers, Kubernetes (liveness/readiness probes), e ferramentas de monitoramento.

```typescript
// src/modules/health/health.routes.ts

// Liveness — "o processo está vivo?"
// Kubernetes reinicia o pod se este endpoint falhar.
// NÃO checar dependências externas aqui.
app.get('/health/live', async (request, reply) => {
  return reply.status(200).send({ status: 'alive' });
});

// Readiness — "o serviço está pronto para receber tráfego?"
// Kubernetes remove o pod do load balancer se este endpoint falhar.
// Checar dependências críticas aqui.
app.get('/health/ready', async (request, reply) => {
  const checks = {
    database: false,
    redis: false,
  };

  try {
    // Checar banco de dados
    await db.$queryRaw`SELECT 1`;
    checks.database = true;
  } catch (err) {
    logger.warn({ err }, 'Health check: banco de dados indisponível');
  }

  try {
    // Checar Redis
    await redis.ping();
    checks.redis = true;
  } catch (err) {
    logger.warn({ err }, 'Health check: Redis indisponível');
  }

  const isReady = Object.values(checks).every(Boolean);

  return reply.status(isReady ? 200 : 503).send({
    status: isReady ? 'ready' : 'not_ready',
    checks,
    uptime: process.uptime(),
    timestamp: new Date().toISOString(),
  });
});
```

### 12-Factor App aplicado ao Node.js

Os 12 fatores são princípios para construir aplicações cloud-native. Os mais relevantes para Node.js:

```
┌─────────────────────────────────────────────────────────┐
│  12-FACTOR APP — RESUMO APLICADO A NODE.JS               │
├──────────────────┬──────────────────────────────────────┤
│  I. Codebase     │ Um repositório, múltiplos deploys    │
│                  │ (dev, staging, production).           │
├──────────────────┼──────────────────────────────────────┤
│  II. Dependencies│ Declaradas em package.json.           │
│                  │ Lockfile comitado. Sem deps globais.  │
├──────────────────┼──────────────────────────────────────┤
│  III. Config     │ Em variáveis de ambiente.             │
│                  │ NUNCA hardcode secrets no código.     │
├──────────────────┼──────────────────────────────────────┤
│  IV. Backing     │ Banco, Redis, S3 são attached         │
│      services    │ resources. Troque o DATABASE_URL      │
│                  │ e o app funciona com outro banco.     │
├──────────────────┼──────────────────────────────────────┤
│  V. Build/Release│ Build: npm run build                  │
│     /Run         │ Release: build + config               │
│                  │ Run: node dist/server.js              │
├──────────────────┼──────────────────────────────────────┤
│  VI. Processes   │ Stateless. Sem estado em memória      │
│                  │ entre requests. Use Redis/banco       │
│                  │ para estado compartilhado.            │
├──────────────────┼──────────────────────────────────────┤
│  VII. Port       │ Exporta serviço via binding de porta. │
│       binding    │ app.listen(PORT).                     │
├──────────────────┼──────────────────────────────────────┤
│  VIII. Concur-   │ Escalar via processos, não threads.   │
│        rency     │ Cluster mode ou múltiplas instâncias. │
├──────────────────┼──────────────────────────────────────┤
│  IX. Disposabi-  │ Startup rápido, shutdown graceful.    │
│      lity        │ SIGTERM handler implementado.         │
├──────────────────┼──────────────────────────────────────┤
│  X. Dev/prod     │ Ambientes de dev e prod o mais        │
│     parity       │ similares possível. Docker ajuda.     │
├──────────────────┼──────────────────────────────────────┤
│  XI. Logs        │ Escrever para stdout/stderr.          │
│                  │ NÃO escrever em arquivos.             │
│                  │ A plataforma coleta (Docker, K8s).    │
├──────────────────┼──────────────────────────────────────┤
│  XII. Admin      │ Tasks administrativas como scripts    │
│       processes  │ one-off: npm run migrate, seed, etc.  │
└──────────────────┴──────────────────────────────────────┘
```

### Segurança básica

```typescript
// Segurança mínima para uma API Node.js em produção

// 1. Helmet — configura headers de segurança HTTP
import helmet from '@fastify/helmet';
await app.register(helmet, {
  contentSecurityPolicy: false, // ajustar conforme necessário
});

// 2. Rate limiting — proteger contra brute force e DDoS
import rateLimit from '@fastify/rate-limit';
await app.register(rateLimit, {
  max: 100,          // máximo de requests
  timeWindow: '1 minute',
  keyGenerator: (request) => request.ip, // ou request.headers['x-forwarded-for']
});

// 3. CORS — controlar quais origins podem acessar a API
import cors from '@fastify/cors';
await app.register(cors, {
  origin: env.CORS_ORIGIN,  // em produção: 'https://meusite.com'
  credentials: true,
});

// 4. Validação de input — NUNCA confiar no cliente
import { z } from 'zod';

const createUserSchema = z.object({
  email: z.string().email().max(255),
  name: z.string().min(2).max(100).trim(),
  password: z.string().min(8).max(128),
});

app.post('/users', async (request, reply) => {
  // Se a validação falhar, Zod lança um ZodError com detalhes
  const body = createUserSchema.parse(request.body);
  // body é tipado e sanitizado
});

// 5. NUNCA expor stack traces em produção
// O error handler global deve omitir error.stack quando NODE_ENV=production

// 6. Manter dependências atualizadas
// npm audit          — verifica vulnerabilidades conhecidas
// npm audit fix      — atualiza automaticamente (quando possível)
// npx npm-check-updates — mostra dependências desatualizadas
```

### Logging em produção

```typescript
// Use um logger estruturado (JSON), não console.log
// Pino é o logger mais rápido para Node.js

import pino from 'pino';

const logger = pino({
  level: env.LOG_LEVEL,
  // Em produção: JSON para stdout (coletado por Datadog, ELK, etc.)
  // Em desenvolvimento: formato legível
  transport: env.NODE_ENV === 'development'
    ? { target: 'pino-pretty', options: { colorize: true } }
    : undefined,
  // Redação de campos sensíveis
  redact: ['req.headers.authorization', 'req.headers.cookie', 'body.password'],
});

// Uso com contexto estruturado
logger.info({ userId: user.id, action: 'login' }, 'Usuário autenticado');
logger.error({ err, requestId: req.id }, 'Falha ao processar pagamento');

// ANTI-PATTERNS:
// console.log('usuário logou');          // sem estrutura, sem contexto
// console.log('erro:', error);            // perde stack trace
// logger.info(`user ${userId} logged`);   // string interpolation perde estrutura
```

---

## Ferramentas do Ecossistema

### TypeScript

TypeScript é praticamente obrigatório para projetos Node.js sérios. A tipagem estática elimina classes inteiras de bugs em tempo de compilação.

```json
// tsconfig.json — configuração recomendada para Node.js
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

```bash
# Executar TypeScript em desenvolvimento (sem compilar)
npx tsx src/server.ts             # tsx: rápido, suporta ESM
npx tsx watch src/server.ts       # com watch mode

# Compilar para produção
npx tsc                           # compila para dist/
# ou
npx tsup src/index.ts --format esm,cjs --dts  # bundler rápido

# Checar tipos sem compilar
npx tsc --noEmit
```

### ESLint e Prettier

```javascript
// eslint.config.js — flat config (ESLint 9+)
import js from '@eslint/js';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  js.configs.recommended,
  ...tseslint.configs.recommended,
  {
    rules: {
      '@typescript-eslint/no-unused-vars': ['error', {
        argsIgnorePattern: '^_',
      }],
      '@typescript-eslint/explicit-function-return-type': 'off',
      'no-console': ['warn', { allow: ['warn', 'error'] }],
    },
  },
  {
    ignores: ['dist/', 'node_modules/'],
  }
);
```

```json
// .prettierrc
{
  "semi": true,
  "singleQuote": true,
  "trailingComma": "all",
  "printWidth": 100,
  "tabWidth": 2
}
```

### Frameworks de Teste (Vitest)

```typescript
// src/modules/users/users.service.test.ts
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { UsersService } from './users.service.js';

describe('UsersService', () => {
  let service: UsersService;
  let mockRepository: any;

  beforeEach(() => {
    mockRepository = {
      findById: vi.fn(),
      create: vi.fn(),
    };
    service = new UsersService(mockRepository);
  });

  describe('getById', () => {
    it('deve retornar o usuário quando encontrado', async () => {
      const user = { id: '1', name: 'Alice', email: 'alice@example.com' };
      mockRepository.findById.mockResolvedValue(user);

      const result = await service.getById('1');

      expect(result).toEqual(user);
      expect(mockRepository.findById).toHaveBeenCalledWith('1');
    });

    it('deve lançar NotFoundError quando usuário não existe', async () => {
      mockRepository.findById.mockResolvedValue(null);

      await expect(service.getById('999')).rejects.toThrow(NotFoundError);
    });
  });
});
```

```bash
# Executar testes
npx vitest run              # roda uma vez e sai
npx vitest                  # watch mode (re-roda ao salvar)
npx vitest run --coverage   # com relatório de cobertura
npx vitest run --reporter=verbose  # output detalhado
```

### Process Managers (PM2)

PM2 é usado quando você roda Node.js diretamente em VMs (sem Docker/Kubernetes). Gerencia processos, cluster mode, logs e restarts automáticos.

```javascript
// ecosystem.config.cjs
module.exports = {
  apps: [{
    name: 'minha-api',
    script: './dist/server.js',
    instances: 'max',         // um processo por CPU core
    exec_mode: 'cluster',     // cluster mode para load balancing
    env: {
      NODE_ENV: 'production',
      PORT: 3000,
    },
    max_memory_restart: '500M',  // restart se ultrapassar 500MB
    exp_backoff_restart_delay: 100, // delay crescente entre restarts
    log_type: 'json',
    merge_logs: true,
  }],
};
```

```bash
# Comandos PM2 essenciais
pm2 start ecosystem.config.cjs    # iniciar
pm2 list                           # listar processos
pm2 logs                           # ver logs em tempo real
pm2 monit                          # dashboard no terminal
pm2 reload minha-api               # zero-downtime reload
pm2 stop minha-api                 # parar
pm2 delete minha-api               # remover

# Em ambientes com Docker/Kubernetes, PM2 geralmente NÃO é necessário.
# O orquestrador cuida de restarts, scaling e load balancing.
# Use "node dist/server.js" diretamente no Dockerfile.
```

---

## Resumo Operacional

Node.js é uma plataforma poderosa, mas que exige disciplina. O caminho de código amador para código de produção passa por:

1. **Entender a plataforma**: V8 + libuv, single-threaded, I/O não-bloqueante. Saber onde Node.js brilha e onde não brilha evita decisões arquiteturais ruins.

2. **Usar ESModules**: `"type": "module"` no package.json, `import`/`export`, prefixo `node:` para módulos nativos. CJS só quando necessário para compatibilidade.

3. **Gerenciar dependências com rigor**: lockfile comitado, `npm ci` em CI, `npm audit` regular, pnpm para strictness.

4. **Validar tudo no startup**: variáveis de ambiente com schema (Zod), fail-fast se algo estiver errado. Melhor falhar em 2 segundos no deploy do que em 3 horas na madrugada.

5. **Tratar erros com intenção**: erros operacionais vs erros de programação, custom error classes, error handler global, unhandledRejection/uncaughtException.

6. **Preparar para produção**: graceful shutdown (SIGTERM), health checks (liveness/readiness), logging estruturado (Pino), rate limiting, helmet, CORS.

7. **Ferramentas certas**: TypeScript para tipagem, ESLint para consistência, Vitest para testes, Prettier para formatação. Debugging com --inspect e Chrome DevTools, não com console.log.

A diferença entre um projeto Node.js que "funciona" e um que sobrevive em produção é a atenção a esses detalhes. Nenhum deles é difícil individualmente — a disciplina está em aplicar todos consistentemente.
