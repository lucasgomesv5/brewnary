---
title: "O Problema N+1"
description: "Identificar, diagnosticar e resolver o problema N+1 queries — a causa mais comum de degradação de performance em aplicações que usam ORMs"
track: "backend"
order: 11
section: "Banco de Dados"
priority: "high"
tags: ["sql", "banco-de-dados", "n-plus-1", "performance", "orm", "dataloader", "graphql"]
prerequisites: ["sql-modelagem"]
keyTakeaways:
  - "O problema N+1 ocorre quando o código faz 1 query inicial + N queries extras (uma por resultado) — transformando O(1) em O(n) round-trips ao banco"
  - "Resolva com eager loading (JOIN), batch loading (WHERE IN) ou o padrão DataLoader (batching + caching por request)"
  - "Em GraphQL o N+1 é amplificado pela resolução campo-a-campo — DataLoader é obrigatório em produção"
---

## O Problema: Anatomia do N+1

O N+1 é o problema de performance mais comum em aplicações que usam ORMs.
Acontece quando o código executa **1 query para buscar uma lista** e depois
**N queries adicionais** (uma para cada item) para buscar dados relacionados.

```javascript
// ❌ N+1: 1 query + 100 queries = 101 round-trips ao banco de dados
const users = await db.query('SELECT * FROM users LIMIT 100');  // 1 query

for (const user of users) {
  // Para CADA um dos 100 usuários, executa UMA query adicional
  const orders = await db.query(
    'SELECT * FROM orders WHERE user_id = $1',
    [user.id]
  );
  user.orders = orders;
}

// Impacto real com 100 usuários:
//   101 queries × ~2ms cada (rede + parsing + execução) = ~200ms
//   Com connection pool saturado, pode subir para 500ms+
//
// Com JOIN ou batch: 1-2 queries × ~5ms = ~10ms
// Diferença: 20x mais lento. Em produção com carga, é catastrófico.
```

### Por que é tão comum?

O N+1 é um efeito colateral do **lazy loading** — a estratégia padrão da
maioria dos ORMs. Cada acesso a uma relação dispara uma query sob demanda.
O código parece limpo mas esconde dezenas de queries:

```typescript
// Prisma: este código parece inocente mas causa N+1
const users = await prisma.user.findMany({ take: 100 });

// Em um template ou serializer:
for (const user of users) {
  // Se user.orders não foi carregado via include,
  // Prisma NÃO faz lazy loading — mas outros ORMs (Sequelize, TypeORM) fazem.
  // Em Sequelize/TypeORM, acessar user.orders aqui dispara uma query por user.
  console.log(user.orders); // ← N queries implícitas em ORMs com lazy loading
}
```

O problema é insidioso porque:
1. **Funciona corretamente** — o resultado está correto, só é lento
2. **Não aparece em testes** — com 3 registros no test DB, 4 queries são imperceptíveis
3. **Aparece em produção** — com 1000 registros, são 1001 queries
4. **Escala linearmente** — cada novo registro adiciona mais uma query

---

## Detecção: Como Encontrar N+1

### Query Logging

A primeira linha de defesa é **logar todas as queries** em desenvolvimento:

```typescript
// Prisma: habilitar query logging
const prisma = new PrismaClient({
  log: [
    { emit: 'stdout', level: 'query' },  // Loga toda query executada
    { emit: 'stdout', level: 'warn' },
  ],
});

// Sequelize: logging
const sequelize = new Sequelize(DATABASE_URL, {
  logging: (sql, timing) => {
    console.log(`[${timing}ms] ${sql}`);
  },
  benchmark: true,
});

// TypeORM: logging
// Em ormconfig.json: "logging": ["query", "error"]
// Ou via DataSource: logging: "all"
```

### Slow Query Analysis

```sql
-- PostgreSQL: habilitar slow query log
-- Em postgresql.conf:
-- log_min_duration_statement = 100  (loga queries > 100ms)

-- Identificar queries repetitivas (sinal de N+1):
SELECT query, calls, mean_exec_time, total_exec_time
FROM pg_stat_statements
ORDER BY calls DESC
LIMIT 20;

-- Se você vê a mesma query sendo chamada centenas de vezes
-- com apenas o parâmetro mudando, é N+1:
-- SELECT * FROM orders WHERE user_id = $1  → calls: 847
```

### APM Tools

Ferramentas de Application Performance Monitoring detectam N+1 automaticamente:

```
Ferramentas que detectam N+1:
─────────────────────────────
• Datadog APM    → Mostra query count por request, destaca queries repetitivas
• New Relic      → N+1 detection automático, sugestões de fix
• Sentry         → Performance monitoring, query spans
• Scout APM      → Focado em N+1, mostra exatamente onde no código
• OpenTelemetry  → Instrumentação open-source, spans por query

Métricas-chave para monitorar:
  • Query count per request → Se > 10, provavelmente tem N+1
  • Database time % → Se > 50% do request time, investigue
  • p99 latency por endpoint → Spikes indicam N+1 sob carga
```

---

## Soluções

### Solução 1: Eager Loading com JOIN

Uma única query que traz todos os dados de uma vez:

```javascript
// SQL puro: JOIN retorna tudo em 1 round-trip
const results = await db.query(`
  SELECT
    u.id AS user_id,
    u.name,
    u.email,
    o.id AS order_id,
    o.total,
    o.status,
    o.created_at
  FROM users u
  LEFT JOIN orders o ON o.user_id = u.id
  WHERE u.active = true
  ORDER BY u.id, o.created_at DESC
`);

// Problema do JOIN: duplicação de dados
// Se um user tem 5 orders, os campos do user são repetidos 5 vezes
// Para 100 users com média de 5 orders = 500 linhas (vs 100 + 500)
// Solução: hidratar em memória
const usersMap = new Map();
for (const row of results) {
  if (!usersMap.has(row.user_id)) {
    usersMap.set(row.user_id, {
      id: row.user_id,
      name: row.name,
      email: row.email,
      orders: [],
    });
  }
  if (row.order_id) {
    usersMap.get(row.user_id).orders.push({
      id: row.order_id,
      total: row.total,
      status: row.status,
      createdAt: row.created_at,
    });
  }
}
const users = Array.from(usersMap.values());
```

### Solução 2: Batch Loading com WHERE IN

Duas queries, sem duplicação de dados:

```javascript
// Query 1: buscar todos os usuários
const users = await db.query(
  'SELECT * FROM users WHERE active = true LIMIT 100'
);

// Query 2: buscar TODOS os orders de uma vez com WHERE IN
const userIds = users.map(u => u.id);
const orders = await db.query(
  'SELECT * FROM orders WHERE user_id = ANY($1) ORDER BY created_at DESC',
  [userIds]
);

// Agrupar em memória: O(n) com Map
const ordersByUserId = new Map();
for (const order of orders) {
  if (!ordersByUserId.has(order.user_id)) {
    ordersByUserId.set(order.user_id, []);
  }
  ordersByUserId.get(order.user_id).push(order);
}

// Associar
for (const user of users) {
  user.orders = ordersByUserId.get(user.id) || [];
}

// Resultado: 2 queries em vez de 101. Sem duplicação de dados.
// Trade-off: WHERE IN com milhares de IDs pode ser lento.
// Solução para muitos IDs: batches de 500-1000 IDs por vez.
```

### Solução 3: DataLoader Pattern

O **DataLoader** (criado pelo Facebook para GraphQL) resolve N+1 com
**batching automático + caching por request**:

```typescript
import DataLoader from 'dataloader';

// O DataLoader recebe uma função que busca MUITOS IDs de uma vez
const orderLoader = new DataLoader<string, Order[]>(async (userIds) => {
  // Esta função é chamada UMA vez com TODOS os IDs acumulados no tick
  const orders = await db.query(
    'SELECT * FROM orders WHERE user_id = ANY($1)',
    [userIds]
  );

  // IMPORTANTE: deve retornar um array na MESMA ORDEM dos IDs de entrada
  const ordersByUserId = new Map<string, Order[]>();
  for (const order of orders) {
    if (!ordersByUserId.has(order.user_id)) {
      ordersByUserId.set(order.user_id, []);
    }
    ordersByUserId.get(order.user_id)!.push(order);
  }

  return userIds.map(id => ordersByUserId.get(id) || []);
});

// Uso: cada .load() NÃO dispara uma query imediatamente.
// O DataLoader acumula todos os .load() do mesmo tick do event loop
// e dispara UMA query batch.
const user1Orders = await orderLoader.load('user_1');  // Acumula
const user2Orders = await orderLoader.load('user_2');  // Acumula
// → No próximo tick: UMA query com WHERE user_id IN ('user_1', 'user_2')

// Caching: se user_1 for pedido novamente no mesmo request,
// retorna do cache sem query adicional.
```

#### Como o DataLoader funciona internamente:

```
Tick 1 do Event Loop:
  resolver('user_1') → orderLoader.load('user_1') → enfileira 'user_1'
  resolver('user_2') → orderLoader.load('user_2') → enfileira 'user_2'
  resolver('user_3') → orderLoader.load('user_3') → enfileira 'user_3'

Tick 2 (process.nextTick / microtask):
  DataLoader executa batchFn(['user_1', 'user_2', 'user_3'])
  → UMA query: SELECT * FROM orders WHERE user_id IN ($1, $2, $3)
  → Resultado é distribuído para cada Promise pendente

Cache (por request):
  Se resolver('user_1') é chamado de novo → retorna do cache
  IMPORTANTE: criar novo DataLoader por request para evitar stale data
```

---

## Soluções por ORM

### Prisma

```typescript
// ❌ N+1: Prisma NÃO faz lazy loading, mas loops manuais causam o problema
const users = await prisma.user.findMany();
for (const user of users) {
  const orders = await prisma.order.findMany({
    where: { userId: user.id },
  });
  // N+1: 1 + N queries
}

// ✅ Solução: include (eager loading via query separada, não JOIN)
const users = await prisma.user.findMany({
  include: {
    orders: {
      where: { status: 'completed' },
      orderBy: { createdAt: 'desc' },
      take: 10,     // Limitar orders por user
    },
  },
});
// Prisma gera 2 queries:
//   1. SELECT * FROM users
//   2. SELECT * FROM orders WHERE user_id IN (...) AND status = 'completed'

// ✅ Otimização extra: select para reduzir payload
const users = await prisma.user.findMany({
  select: {
    id: true,
    name: true,
    email: true,
    orders: {
      select: {
        id: true,
        total: true,
        status: true,
      },
    },
  },
});
```

### Sequelize

```typescript
// ❌ N+1: lazy loading é o default no Sequelize
const users = await User.findAll();
for (const user of users) {
  const orders = await user.getOrders(); // Lazy load → 1 query por user
}

// ✅ Solução: eager loading com include
const users = await User.findAll({
  include: [{
    model: Order,
    as: 'orders',
    where: { status: 'completed' },   // Filtro opcional
    required: false,                    // LEFT JOIN (inclui users sem orders)
    attributes: ['id', 'total', 'status'],
  }],
});

// ✅ Solução alternativa: separate queries (batch loading)
const users = await User.findAll({
  include: [{
    model: Order,
    as: 'orders',
    separate: true,  // Gera query separada com WHERE IN em vez de JOIN
  }],
});
```

### TypeORM

```typescript
// ❌ N+1: relations com lazy: true disparam queries sob demanda
@Entity()
class User {
  @OneToMany(() => Order, order => order.user, { lazy: true })
  orders: Promise<Order[]>;  // Cada await dispara uma query
}

// ✅ Solução 1: eager loading com find options
const users = await userRepository.find({
  relations: { orders: true },
  where: { active: true },
});

// ✅ Solução 2: QueryBuilder para controle fino
const users = await userRepository
  .createQueryBuilder('user')
  .leftJoinAndSelect('user.orders', 'order', 'order.status = :status', {
    status: 'completed',
  })
  .where('user.active = :active', { active: true })
  .orderBy('order.createdAt', 'DESC')
  .getMany();
// Gera UM JOIN SQL — mais eficiente que queries separadas quando
// a relação é pequena (poucos orders por user).
```

---

## GraphQL N+1: O Problema Amplificado

Em REST, o N+1 é ruim. Em GraphQL, é **catastrófico**, porque cada campo
de cada tipo é resolvido independentemente:

```typescript
// Schema GraphQL
type Query {
  users: [User!]!
}
type User {
  id: ID!
  name: String!
  orders: [Order!]!    // ← Cada user resolve orders separadamente
}
type Order {
  id: ID!
  total: Float!
  items: [OrderItem!]!  // ← Cada order resolve items separadamente
}

// Query do cliente:
// { users { name orders { total items { productName } } } }
//
// Sem DataLoader:
//   1 query: SELECT * FROM users                         → 100 users
//   100 queries: SELECT * FROM orders WHERE user_id = ?  → ~500 orders
//   500 queries: SELECT * FROM items WHERE order_id = ?  → ~2000 items
//   Total: 601 queries para 1 request HTTP!

// ✅ Resolvers com DataLoader:
const resolvers = {
  Query: {
    users: () => db.query('SELECT * FROM users'),
  },
  User: {
    orders: (user, _, { loaders }) => loaders.order.load(user.id),
  },
  Order: {
    items: (order, _, { loaders }) => loaders.orderItem.load(order.id),
  },
};

// Context factory: novo DataLoader por request
const context = ({ req }) => ({
  loaders: {
    order: new DataLoader(async (userIds) => {
      const orders = await db.query(
        'SELECT * FROM orders WHERE user_id = ANY($1)', [userIds]
      );
      return userIds.map(id => orders.filter(o => o.user_id === id));
    }),
    orderItem: new DataLoader(async (orderIds) => {
      const items = await db.query(
        'SELECT * FROM order_items WHERE order_id = ANY($1)', [orderIds]
      );
      return orderIds.map(id => items.filter(i => i.order_id === id));
    }),
  },
});
// Total com DataLoader: 3 queries (users + orders batch + items batch)
```

---

## Database-Level: Otimizações Complementares

Quando o N+1 já foi resolvido no application layer, otimizações no banco
podem melhorar ainda mais:

```sql
-- Materialized View: pré-computa JOINs pesados
CREATE MATERIALIZED VIEW user_order_summary AS
SELECT
  u.id AS user_id,
  u.name,
  COUNT(o.id) AS total_orders,
  COALESCE(SUM(o.total), 0) AS total_spent,
  MAX(o.created_at) AS last_order_date
FROM users u
LEFT JOIN orders o ON o.user_id = u.id
GROUP BY u.id, u.name;

-- Refresh periódico (não é em tempo real)
REFRESH MATERIALIZED VIEW CONCURRENTLY user_order_summary;

-- Índices para as queries mais comuns do N+1
CREATE INDEX idx_orders_user_id ON orders(user_id);
CREATE INDEX idx_orders_user_status ON orders(user_id, status)
  INCLUDE (total, created_at);  -- Covering index: evita heap access

-- Denormalização controlada: coluna computada
ALTER TABLE users ADD COLUMN order_count INT DEFAULT 0;
-- Atualizar via trigger ou application code
```

---

## Lazy Loading vs Eager Loading: Trade-offs

```
                    Lazy Loading              Eager Loading
                    ────────────              ─────────────
Queries             N+1 (1 + N)              1-2 (JOIN ou batch)
Latência            Alta (muitos round-trips) Baixa (poucos round-trips)
Memória             Baixa (carrega sob demanda) Alta (carrega tudo de uma vez)
Payload             Mínimo por query          Potencialmente grande
Complexidade        Simples (código direto)   Requer planejamento

Quando usar Lazy Loading:
  → Relação raramente acessada (ex: user.auditLog)
  → Dados muito grandes que nem sempre são necessários
  → Admin panels com poucos registros

Quando usar Eager Loading:
  → Relação SEMPRE acessada junto com o pai
  → Listas com muitos registros (users + orders)
  → APIs públicas com SLA de latência
  → Qualquer endpoint chamado frequentemente

Regra prática:
  → Default para eager loading em endpoints de produção
  → Use lazy loading apenas quando tem certeza que a relação
    é raramente necessária E os dados são grandes
```

---

## Monitoring: Métricas Essenciais

```
Métrica                        Alvo Saudável       Sinal de N+1
──────────────────────────     ────────────────     ──────────────────
Query count per request        < 10                 > 50 queries/req
p99 database latency           < 50ms               > 500ms
DB time % of request           < 30%                > 70%
Connection pool utilization    < 60%                > 90% (saturação)
Queries per second (QPS)       Estável              Spikes proporcionais ao tráfego

-- Monitorar no PostgreSQL:
SELECT
  datname,
  numbackends AS active_connections,
  xact_commit AS transactions,
  blk_read_time AS disk_read_ms,
  blk_write_time AS disk_write_ms
FROM pg_stat_database
WHERE datname = 'myapp';

-- Connection pool monitoring (pgbouncer stats):
-- SHOW POOLS; → sv_active, sv_idle, sv_waiting
-- Se sv_waiting > 0 consistentemente → pool saturado → provável N+1
```

O N+1 é um problema de **multiplicação de round-trips**, não de queries
complexas. A solução é sempre a mesma: substituir N queries individuais
por 1-2 queries batch. O mecanismo varia (JOIN, WHERE IN, DataLoader),
mas o princípio é constante — **minimize round-trips ao banco de dados**.
