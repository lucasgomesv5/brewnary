---
title: "Índices"
description: "Como índices funcionam internamente, tipos de índice (B-Tree, Hash, GIN, GiST, BRIN), estratégias de scan e a importância da ordem em índices compostos"
track: "backend"
order: 10
section: "Banco de Dados"
priority: "high"
tags: ["sql", "banco-de-dados", "índices", "performance", "b-tree", "postgresql"]
prerequisites: ["sql-modelagem"]
keyTakeaways:
  - "Índices são estruturas auxiliares que trocam espaço em disco e custo de escrita por velocidade de leitura — B-Trees permitem busca O(log n) em vez de Full Table Scan O(n)"
  - "Use EXPLAIN ANALYZE para verificar se sua query está usando índices corretamente e entender o custo real de execução"
  - "Em índices compostos a ordem das colunas importa — a leftmost prefix rule determina quais queries podem usar o índice"
  - "Cada tipo de índice (B-Tree, Hash, GIN, GiST, BRIN) resolve um domínio diferente de problemas — escolher o tipo errado é tão ruim quanto não ter índice"
---

## Índices — Estruturas Auxiliares de Busca

Um índice de banco de dados é uma **estrutura de dados separada** que mantém uma cópia ordenada (ou organizada) de um subconjunto de colunas de uma tabela, com ponteiros de volta para as rows completas. A ideia fundamental é simples: **trocar espaço em disco e custo de escrita por velocidade de leitura**.

Sem índice, qualquer query que filtre dados precisa fazer um **Sequential Scan** (ou Full Table Scan) — ler cada página de dados da tabela do início ao fim. Para uma tabela com 10 milhões de rows ocupando 1.2 GB em disco, isso significa ler 1.2 GB mesmo que você queira uma única row. Com um índice B-Tree na coluna filtrada, o banco desce 3-4 níveis de uma árvore balanceada e lê apenas as páginas necessárias — tipicamente 3-5 leituras de I/O em vez de milhares.

```sql
-- Sem índice: Sequential Scan — lê TODAS as páginas da tabela
EXPLAIN ANALYZE SELECT * FROM users WHERE email = 'lucas@empresa.com';
--  Seq Scan on users  (cost=0.00..185432.00 rows=1 width=124)
--                      (actual time=823.412..823.412 rows=1 loops=1)
--  Filter: (email = 'lucas@empresa.com'::text)
--  Rows Removed by Filter: 9999999
--  Planning Time: 0.082 ms
--  Execution Time: 823.456 ms

CREATE INDEX idx_users_email ON users (email);

-- Com índice: Index Scan — desce a B-Tree e lê ponteiro direto
EXPLAIN ANALYZE SELECT * FROM users WHERE email = 'lucas@empresa.com';
--  Index Scan using idx_users_email on users  (cost=0.43..8.45 rows=1 width=124)
--                                              (actual time=0.028..0.029 rows=1 loops=1)
--  Index Cond: (email = 'lucas@empresa.com'::text)
--  Planning Time: 0.095 ms
--  Execution Time: 0.048 ms
```

A diferença é brutal: **823 ms vs 0.048 ms** — quase 20.000x mais rápido. Mas essa melhoria não vem de graça. Cada índice ocupa espaço em disco, consome memória no buffer pool, e **cada INSERT, UPDATE ou DELETE na tabela precisa atualizar todos os índices afetados**. Entender esse trade-off é o que separa um engenheiro que "coloca índice em tudo" de um que projeta esquemas de banco com precisão cirúrgica.

---

## B-Tree — A Estrutura Padrão

O B-Tree (Balanced Tree) é o tipo de índice padrão em praticamente todos os bancos de dados relacionais (PostgreSQL, MySQL/InnoDB, Oracle, SQL Server). Quando você executa `CREATE INDEX` sem especificar tipo, você cria um B-Tree.

### Por que B-Tree e não Binary Search Tree?

A resposta está no **modelo de I/O de disco**. Uma BST (Binary Search Tree) tem fanout 2 — cada nó tem no máximo 2 filhos. Para 10 milhões de rows, a altura seria ~23 níveis (log2 de 10M). Cada nível é uma leitura de I/O (tipicamente uma página de 8 KB no PostgreSQL ou 16 KB no MySQL/InnoDB). 23 leituras de I/O random para encontrar uma row é **inaceitável**.

O B-Tree resolve isso com **fanout alto**. Cada nó interno cabe em uma página de disco (8 KB) e armazena centenas de chaves. Com fanout ~500, a altura para 10 milhões de rows é apenas **3 níveis** (log500 de 10M ≈ 2.6). Na prática, os níveis superiores da árvore ficam em cache no buffer pool, então a maioria das buscas requer **1-2 leituras de I/O do disco**.

### Anatomia de uma B-Tree

```
Nível 0 (raiz):     [  50  |  150  |  300  |  500  |  ... ]
                     /       |        |        |        \
Nível 1 (interno):  [10|25|40] [60|80|120] [160|200|280] ...
                    / | | \    / | | \      / | | \
Nível 2 (folhas): [1,2,..,9] [11,12,..,24] [26,27,..,39] ...
                    ↕           ↕              ↕
              (ponteiros para heap pages / ctid no PostgreSQL)
```

**Nós internos** armazenam apenas chaves de roteamento e ponteiros para nós filhos. Eles dizem "para encontrar valores < 50, vá para a esquerda; para 50-149, vá para o segundo filho", e assim por diante.

**Nós folha** armazenam as chaves indexadas e um **ponteiro para a row na tabela** (no PostgreSQL, esse ponteiro é o `ctid` — um par `(page_number, offset)` que identifica a localização física da row na heap table). Os nós folha são ligados entre si em uma **doubly linked list**, o que permite range scans eficientes sem precisar voltar à raiz.

### Altura Típica e Buffer Pool

| Rows na tabela | Altura B-Tree (fanout ~500) | Páginas de índice |
|---|---|---|
| 1.000 | 1 | ~2 |
| 100.000 | 2 | ~200 |
| 10.000.000 | 3 | ~40.000 |
| 1.000.000.000 | 4 | ~8.000.000 |

O nível raiz e os primeiros níveis internos são acessados com tanta frequência que ficam **permanentemente em cache** no buffer pool (shared_buffers no PostgreSQL, buffer pool no InnoDB). Na prática, mesmo para tabelas com bilhões de rows, uma busca por chave exata faz **1-2 leituras de disco** — o resto vem do cache.

Você pode verificar o tamanho de um índice e quantas páginas ele ocupa:

```sql
SELECT pg_size_pretty(pg_relation_size('idx_users_email')) AS index_size,
       relpages, reltuples
FROM pg_class
WHERE relname = 'idx_users_email';
--  index_size | relpages | reltuples
-- -----------+----------+-----------
--  256 MB     |   32768  |  10000000
```

---

## Clustered vs Non-Clustered Index

### Heap Table (Non-Clustered — padrão no PostgreSQL)

No PostgreSQL, a tabela em si é uma **heap** — rows são armazenadas em qualquer ordem, tipicamente na ordem de inserção, mas com espaços criados por DELETEs e preenchidos por INSERTs futuros. O índice é uma estrutura **separada** que aponta para a localização física das rows na heap via `ctid`.

Isso significa que um **Index Scan** envolve dois passos: (1) descer a B-Tree para encontrar o `ctid`, e (2) ir até a heap page correspondente para ler a row completa. Se o scan retorna muitas rows espalhadas por muitas heap pages, isso gera **random I/O** que pode ser mais lento que um Sequential Scan.

### Index-Organized Table (Clustered — padrão no MySQL/InnoDB)

No MySQL/InnoDB, a **primary key é um clustered index** — os dados da tabela são fisicamente armazenados **dentro** da estrutura B-Tree, ordenados pela primary key. Não existe heap separada. Os nós folha do clustered index contêm as rows completas.

Os índices secundários no InnoDB armazenam a **primary key** (não um ponteiro físico) nas suas folhas. Isso significa que uma busca por um índice secundário requer um **double lookup**: primeiro desce a B-Tree do índice secundário para encontrar a PK, depois desce a B-Tree do clustered index para encontrar a row. Isso torna a escolha da PK no InnoDB **crítica** — PKs grandes (UUIDs de 16 bytes) são copiadas para cada índice secundário, inflando todos eles.

```sql
-- PostgreSQL: CLUSTER reordena a heap segundo um índice (one-time, não se mantém)
CLUSTER users USING idx_users_created_at;

-- Após CLUSTER, range scans em created_at são muito mais rápidos
-- porque rows consecutivas na B-Tree estão em páginas consecutivas na heap
EXPLAIN ANALYZE
SELECT * FROM users WHERE created_at BETWEEN '2025-01-01' AND '2025-01-31';
--  Index Scan using idx_users_created_at on users
--    (actual time=0.034..12.451 rows=31205 loops=1)
--    Buffers: shared hit=423    ← poucas páginas, dados contíguos
```

---

## Índices Compostos e a Leftmost Prefix Rule

Um índice composto é uma B-Tree onde a chave de ordenação é a **concatenação** das colunas especificadas. A ordem das colunas define a hierarquia de ordenação.

```sql
CREATE INDEX idx_orders_status_date ON orders (status, created_at);
```

Esse índice ordena primeiro por `status` e, **dentro de cada status**, por `created_at`. Pense como uma lista telefônica: primeiro por sobrenome, depois por nome.

### Leftmost Prefix Rule

O índice composto `(A, B, C)` pode ser usado para queries que filtram:
- `A` sozinho
- `A` e `B`
- `A`, `B` e `C`

**Não pode** ser usado para queries que filtram apenas:
- `B` sozinho
- `C` sozinho
- `B` e `C` (sem `A`)

```sql
-- Dado o índice (status, created_at, customer_id):

-- Usa o índice (prefixo completo):
SELECT * FROM orders WHERE status = 'shipped'
  AND created_at > '2025-01-01' AND customer_id = 42;

-- Usa o índice (prefixo parcial — status + range em created_at):
SELECT * FROM orders WHERE status = 'pending'
  AND created_at BETWEEN '2025-06-01' AND '2025-06-30';

-- Usa o índice (apenas a primeira coluna):
SELECT * FROM orders WHERE status = 'cancelled';

-- NÃO usa o índice (pula a primeira coluna):
EXPLAIN ANALYZE SELECT * FROM orders WHERE created_at > '2025-01-01';
--  Seq Scan on orders  (cost=0.00..284320.00 rows=823104 width=96)
--  Filter: (created_at > '2025-01-01')
```

### Covering Index (Index-Only Scan)

Se **todas** as colunas necessárias pela query estão no índice, o banco não precisa acessar a heap — é um **Index-Only Scan**. Isso elimina completamente o passo de random I/O na heap.

```sql
-- Se a query só precisa de status e created_at:
CREATE INDEX idx_orders_covering ON orders (status, created_at);

EXPLAIN ANALYZE
SELECT status, created_at FROM orders WHERE status = 'pending';
--  Index Only Scan using idx_orders_covering on orders
--    (actual time=0.021..15.834 rows=45023 loops=1)
--    Heap Fetches: 0    ← zero acessos à heap!

-- Incluindo colunas extras com INCLUDE (PostgreSQL 11+):
CREATE INDEX idx_orders_cover_v2 ON orders (status, created_at) INCLUDE (total, customer_id);

-- Agora queries que precisam dessas colunas também evitam a heap:
EXPLAIN ANALYZE
SELECT status, created_at, total, customer_id
FROM orders WHERE status = 'pending' AND created_at > '2025-01-01';
--  Index Only Scan using idx_orders_cover_v2 on orders
--    (actual time=0.019..8.234 rows=12034 loops=1)
--    Heap Fetches: 0
```

A diferença entre colunas no índice vs colunas no `INCLUDE`: colunas no índice fazem parte da B-Tree e podem ser usadas para filtragem e ordenação. Colunas no `INCLUDE` são apenas "carregadas junto" nos nós folha — não são parte da chave e não podem ser usadas em condições de busca, mas não aumentam o tamanho dos nós internos.

---

## Hash Index

Um Hash Index usa uma **tabela hash** em vez de uma árvore. O valor da coluna é passado por uma função hash, e o resultado aponta diretamente para o bucket que contém o ponteiro da row.

**Complexidade:** O(1) para equality lookups — mais rápido que B-Tree para busca exata.

**Limitação fundamental:** não suporta range queries (`>`, `<`, `BETWEEN`), `ORDER BY`, ou `LIKE 'prefix%'`. A função hash destrói a ordenação.

```sql
-- PostgreSQL: Hash indexes são WAL-logged desde a versão 10 (antes eram inseguros)
CREATE INDEX idx_sessions_token ON sessions USING hash (token);

-- Funciona (equality):
SELECT * FROM sessions WHERE token = 'abc123def456';

-- NÃO funciona (range — cai em Seq Scan):
SELECT * FROM sessions WHERE token > 'abc';
```

No **MySQL**, Hash indexes estão disponíveis apenas na engine MEMORY (HEAP). O InnoDB usa internamente o **Adaptive Hash Index** — um cache automático em memória que o próprio engine cria e destrói conforme padrões de acesso, sem intervenção do DBA.

Na prática, B-Tree cobre 95% dos casos. Hash index é um nicho para colunas onde você faz **exclusivamente** buscas por igualdade e precisa de cada microssegundo.

---

## GIN — Generalized Inverted Index

O GIN (Índice Invertido Generalizado) é projetado para valores que contêm **múltiplos elementos** — arrays, JSONB, full-text search vectors. A estrutura é um mapa invertido: para cada elemento (palavra, chave JSON, elemento de array), armazena a lista de rows que o contêm.

### Full-Text Search

```sql
-- Coluna tsvector para busca textual
ALTER TABLE articles ADD COLUMN search_vector tsvector;
UPDATE articles SET search_vector = to_tsvector('portuguese', title || ' ' || body);
CREATE INDEX idx_articles_search ON articles USING gin (search_vector);

EXPLAIN ANALYZE
SELECT title FROM articles WHERE search_vector @@ to_tsquery('portuguese', 'índice & banco');
--  Bitmap Heap Scan on articles  (cost=24.08..1234.56 rows=312 width=64)
--    Recheck Cond: (search_vector @@ '''índic'' & ''banc'''::tsquery)
--    ->  Bitmap Index Scan on idx_articles_search  (cost=0.00..24.00 rows=312 width=0)
--        Index Cond: (search_vector @@ '''índic'' & ''banc'''::tsquery)
--  Planning Time: 0.312 ms
--  Execution Time: 1.847 ms
```

### JSONB Queries

```sql
CREATE INDEX idx_events_data ON events USING gin (data jsonb_path_ops);

-- Containment query — "encontre eventos onde data contém esse sub-objeto"
EXPLAIN ANALYZE
SELECT * FROM events WHERE data @> '{"type": "purchase", "source": "mobile"}';
--  Bitmap Heap Scan on events  (cost=28.12..3456.78 rows=1245 width=256)
--    ->  Bitmap Index Scan on idx_events_data  (cost=0.00..27.81 rows=1245 width=0)
--        Index Cond: (data @> '{"type": "purchase", "source": "mobile"}'::jsonb)
--  Execution Time: 3.421 ms

-- jsonb_path_ops é mais compacto e rápido que a classe padrão,
-- mas só suporta o operador @> (containment)
-- Para operadores ?, ?|, ?&, use a classe padrão: USING gin (data)
```

### Array Containment

```sql
CREATE INDEX idx_products_tags ON products USING gin (tags);

-- Encontre produtos que tenham TODOS esses tags
SELECT * FROM products WHERE tags @> ARRAY['orgânico', 'vegano'];

-- Encontre produtos que tenham QUALQUER um desses tags
SELECT * FROM products WHERE tags && ARRAY['orgânico', 'vegano'];
```

O custo do GIN: **inserções são significativamente mais lentas** que B-Tree porque cada valor pode gerar dezenas de entradas no índice invertido. O PostgreSQL mitiga isso com a técnica de **pending list** — inserções vão para uma lista não ordenada que é consolidada periodicamente (ou no próximo VACUUM).

---

## GiST — Generalized Search Tree

O GiST é uma framework de índice que suporta **predicados arbitrários** — não apenas igualdade e ordenação. É a base para indexação de dados geoespaciais (PostGIS), range types, e nearest-neighbor search.

```sql
-- Dados geoespaciais com PostGIS
CREATE INDEX idx_stores_location ON stores USING gist (location);

-- Encontre lojas dentro de 5 km de um ponto
EXPLAIN ANALYZE
SELECT name, ST_Distance(location, ST_MakePoint(-46.6339, -23.5507)::geography) AS dist
FROM stores
WHERE ST_DWithin(location, ST_MakePoint(-46.6339, -23.5507)::geography, 5000)
ORDER BY dist;
--  Index Scan using idx_stores_location on stores
--    (actual time=0.089..0.234 rows=23 loops=1)
--    Index Cond: (location && ST_Expand(...)::geometry)
--    Filter: ST_DWithin(...)
--  Execution Time: 0.312 ms

-- Range types — encontre reservas que se sobrepõem a um período
CREATE TABLE reservations (
    id serial PRIMARY KEY,
    room_id int,
    period tstzrange NOT NULL
);
CREATE INDEX idx_reservations_period ON reservations USING gist (period);

SELECT * FROM reservations
WHERE period && tstzrange('2025-07-01', '2025-07-15', '[)');
-- O operador && testa overlap — o GiST resolve isso eficientemente
```

O GiST também suporta **KNN (K-Nearest Neighbor)** com o operador `<->`:

```sql
-- As 10 lojas mais próximas, ordenadas por distância
SELECT name, location <-> ST_MakePoint(-46.6339, -23.5507)::geometry AS dist
FROM stores
ORDER BY location <-> ST_MakePoint(-46.6339, -23.5507)::geometry
LIMIT 10;
-- Usa o índice GiST para busca eficiente de vizinhos mais próximos
-- sem precisar calcular distância para TODAS as rows
```

---

## BRIN — Block Range Index

O BRIN (Block Range Index) é um índice **extremamente compacto** que armazena, para cada range de páginas de dados (por padrão, 128 páginas = 1 MB), o valor mínimo e máximo da coluna indexada naquele range.

O BRIN funciona extraordinariamente bem quando os dados estão **naturalmente correlacionados com a ordem física** na tabela — o caso clássico é uma coluna `created_at` em uma tabela append-only onde inserções são sempre cronológicas.

```sql
-- Tabela de logs com 500 milhões de rows, ~60 GB
CREATE INDEX idx_logs_created_at ON logs USING brin (created_at)
  WITH (pages_per_range = 128);

-- Tamanho do índice:
SELECT pg_size_pretty(pg_relation_size('idx_logs_created_at'));
--  pg_size_pretty
-- ----------------
--  264 kB          ← 264 KB para indexar 60 GB de dados!

-- Compare com B-Tree equivalente:
CREATE INDEX idx_logs_created_at_btree ON logs USING btree (created_at);
SELECT pg_size_pretty(pg_relation_size('idx_logs_created_at_btree'));
--  pg_size_pretty
-- ----------------
--  10 GB           ← 10 GB vs 264 KB

-- Query com BRIN:
EXPLAIN ANALYZE
SELECT * FROM logs WHERE created_at BETWEEN '2025-07-01' AND '2025-07-02';
--  Bitmap Heap Scan on logs  (cost=52.08..285634.12 rows=1843201 width=128)
--    Recheck Cond: (created_at >= ... AND created_at <= ...)
--    ->  Bitmap Index Scan on idx_logs_created_at  (cost=0.00..51.62 rows=1843201 width=0)
--  Execution Time: 342.567 ms
```

O trade-off é claro: BRIN é **ordens de magnitude menor** que B-Tree, mas menos preciso — ele descarta ranges inteiros que certamente não contêm o valor buscado, mas as páginas dentro de um range retornado ainda precisam ser verificadas (Recheck Cond). Se os dados não estão correlacionados com a ordem física (por exemplo, uma coluna `status` com valores aleatórios), o BRIN é inútil.

---

## Partial Indexes

Um partial index indexa apenas um **subconjunto** das rows, definido por uma cláusula `WHERE`. Isso reduz o tamanho do índice e o custo de manutenção.

```sql
-- Apenas 2% dos pedidos estão em status 'pending', mas 90% das queries
-- são sobre esses pedidos:
CREATE INDEX idx_orders_pending ON orders (created_at)
  WHERE status = 'pending';

-- O índice é ~50x menor que um índice em toda a tabela
-- e só precisa ser atualizado quando rows entram/saem do status 'pending'

EXPLAIN ANALYZE
SELECT * FROM orders WHERE status = 'pending' AND created_at > '2025-07-01';
--  Index Scan using idx_orders_pending on orders
--    (cost=0.29..124.56 rows=342 width=96)
--    (actual time=0.018..0.892 rows=338 loops=1)
--    Index Cond: (created_at > '2025-07-01')
--  Execution Time: 0.934 ms

-- Caso clássico: soft-delete
CREATE INDEX idx_users_active ON users (email) WHERE deleted_at IS NULL;

-- Outro caso: indexar apenas dados "quentes"
CREATE INDEX idx_recent_logs ON logs (level, message)
  WHERE created_at > '2025-01-01';
-- Cuidado: esse índice precisa ser recriado periodicamente
-- ou substituído por particionamento de tabela
```

---

## Expression Indexes

Expression indexes indexam o **resultado de uma expressão**, não o valor raw da coluna. Essenciais quando queries aplicam funções a colunas antes de comparar.

```sql
-- Busca case-insensitive por email:
-- SEM expression index, o B-Tree em (email) não ajuda:
EXPLAIN ANALYZE SELECT * FROM users WHERE LOWER(email) = 'lucas@empresa.com';
--  Seq Scan on users  (cost=0.00..205432.00 rows=50000 width=124)
--  Filter: (lower(email) = 'lucas@empresa.com')
--  Execution Time: 945.312 ms

-- COM expression index:
CREATE INDEX idx_users_email_lower ON users (LOWER(email));

EXPLAIN ANALYZE SELECT * FROM users WHERE LOWER(email) = 'lucas@empresa.com';
--  Index Scan using idx_users_email_lower on users
--    (cost=0.43..8.45 rows=1 width=124)
--    (actual time=0.024..0.025 rows=1 loops=1)
--  Execution Time: 0.042 ms

-- Indexar campo extraído de JSONB:
CREATE INDEX idx_events_type ON events ((data->>'type'));

EXPLAIN ANALYZE
SELECT * FROM events WHERE data->>'type' = 'purchase';
--  Index Scan using idx_events_type on events
--    (cost=0.42..234.56 rows=4521 width=256)
--  Execution Time: 5.678 ms

-- Indexar parte de data:
CREATE INDEX idx_orders_year_month ON orders ((date_trunc('month', created_at)));
```

A regra é: **a expressão na query deve corresponder exatamente à expressão no índice**. `WHERE LOWER(email) = ...` usa o índice em `(LOWER(email))`, mas `WHERE email = ...` não usa (e vice-versa).

---

## Estratégias de Scan: Index Scan vs Index-Only Scan vs Bitmap Scan

O planner do PostgreSQL escolhe a estratégia de scan baseado em **estimativas de seletividade** (que porcentagem das rows será retornada) e **estatísticas** coletadas pelo ANALYZE.

### Index Scan

Desce a B-Tree, encontra o ponteiro (`ctid`), busca a row na heap. Eficiente para queries que retornam **poucas rows** (alta seletividade).

```sql
-- Alta seletividade — retorna 1 row de 10M:
EXPLAIN (ANALYZE, BUFFERS) SELECT * FROM users WHERE id = 42;
--  Index Scan using users_pkey on users  (cost=0.43..8.45 rows=1 width=124)
--    (actual time=0.019..0.020 rows=1 loops=1)
--    Buffers: shared hit=4
```

### Index-Only Scan

Igual ao Index Scan, mas **não precisa acessar a heap** porque todas as colunas necessárias estão no índice. Requer que as páginas de heap relevantes estejam marcadas como "all-visible" no visibility map (atualizado pelo VACUUM).

```sql
EXPLAIN (ANALYZE, BUFFERS) SELECT email FROM users WHERE email = 'lucas@empresa.com';
--  Index Only Scan using idx_users_email on users  (cost=0.43..4.45 rows=1 width=64)
--    (actual time=0.015..0.016 rows=1 loops=1)
--    Heap Fetches: 0     ← zero acessos à heap
--    Buffers: shared hit=3
```

### Bitmap Scan

Quando a query retorna **muitas rows** (mas não tantas que justifiquem um Seq Scan), o planner usa um Bitmap Scan em dois passos:

1. **Bitmap Index Scan**: percorre o índice e constrói um bitmap de pages que contêm rows relevantes
2. **Bitmap Heap Scan**: lê essas pages em **ordem física** (sequential I/O), o que é muito mais eficiente que random I/O

```sql
-- Retorna ~5% da tabela (seletividade média):
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM orders WHERE status = 'shipped'
  AND created_at BETWEEN '2025-01-01' AND '2025-06-30';
--  Bitmap Heap Scan on orders  (cost=1245.67..52340.12 rows=48230 width=96)
--    (actual time=12.345..89.012 rows=47856 loops=1)
--    Recheck Cond: (status = 'shipped' AND created_at >= ... AND created_at <= ...)
--    Heap Blocks: exact=8234
--    Buffers: shared hit=8456
--    ->  Bitmap Index Scan on idx_orders_status_date  (cost=0.00..1233.61 rows=48230 width=0)
--          Index Cond: (status = 'shipped' AND created_at >= ... AND created_at <= ...)
--          Buffers: shared hit=222

-- O planner pode combinar MÚLTIPLOS índices com BitmapAnd/BitmapOr:
--  BitmapAnd
--    ->  Bitmap Index Scan on idx_orders_status ...
--    ->  Bitmap Index Scan on idx_orders_date ...
-- Isso é possível APENAS com Bitmap Scan — Index Scan não combina índices
```

### Quando o Planner Escolhe Cada Um

| Seletividade | Estratégia | Motivo |
|---|---|---|
| < ~1-5% das rows | Index Scan | Poucas rows, random I/O aceitável |
| ~5-20% das rows | Bitmap Scan | Muitas rows, converte random I/O em sequential |
| > ~20% das rows | Sequential Scan | Mais barato ler tudo em sequência |

Esses thresholds são aproximados e dependem de muitos fatores: tamanho da row, correlação física, dados em cache, e os parâmetros `random_page_cost` e `seq_page_cost` do planner.

---

## EXPLAIN ANALYZE — Leitura Detalhada do Query Plan

`EXPLAIN ANALYZE` é a ferramenta mais importante para otimização de queries. Ele **executa a query de fato** e mostra o plano real com métricas.

```sql
EXPLAIN (ANALYZE, BUFFERS, FORMAT TEXT)
SELECT o.id, o.total, c.name
FROM orders o
JOIN customers c ON c.id = o.customer_id
WHERE o.status = 'pending'
  AND o.created_at > '2025-01-01'
ORDER BY o.created_at DESC
LIMIT 20;
```

```
Limit  (cost=0.87..234.56 rows=20 width=84)
       (actual time=0.052..0.198 rows=20 loops=1)
  Buffers: shared hit=28
  ->  Nested Loop  (cost=0.87..45678.90 rows=3421 width=84)
                   (actual time=0.051..0.195 rows=20 loops=1)
        Buffers: shared hit=28
        ->  Index Scan Backward using idx_orders_pending on orders o
              (cost=0.29..12345.67 rows=3421 width=52)
              (actual time=0.032..0.089 rows=20 loops=1)
              Index Cond: (created_at > '2025-01-01')
              Buffers: shared hit=8
        ->  Index Scan using customers_pkey on customers c
              (cost=0.43..8.45 rows=1 width=36)
              (actual time=0.004..0.004 rows=1 loops=20)
              Index Cond: (id = o.customer_id)
              Buffers: shared hit=20
Planning Time: 0.234 ms
Execution Time: 0.221 ms
```

**Como ler:**

- **cost=0.87..234.56**: custo estimado (startup..total) em unidades arbitrárias de página
- **actual time=0.052..0.198**: tempo real em milissegundos (startup..total)
- **rows=20**: número real de rows retornadas por esse nó
- **loops=20**: quantas vezes esse nó foi executado (o join interno executa uma vez por row do externo)
- **Buffers: shared hit=28**: 28 páginas lidas do buffer pool (cache); `shared read` indicaria leituras de disco
- **Index Scan Backward**: percorre o índice de trás para frente (para `ORDER BY DESC`)

**Red flags** no EXPLAIN ANALYZE:
- `Seq Scan` em tabela grande com filtro altamente seletivo
- `rows=1` estimado mas `actual rows=100000` — estatísticas desatualizadas, rode `ANALYZE tabela`
- `Buffers: shared read=50000` — muitos dados lidos do disco, considere mais memória ou índice melhor
- `Sort Method: external merge Disk` — sort estourou `work_mem`, dados foram para disco
- `Nested Loop` com `loops=1000000` no nó interno — possível N+1 no nível do banco

---

## Problemas de Índices

### Write Amplification

Cada índice na tabela precisa ser atualizado em **cada operação de escrita** que afeta as colunas indexadas. Uma tabela com 8 índices transforma cada INSERT em ~9 escritas (1 heap + 8 índices). Em workloads write-heavy, isso pode ser o gargalo principal.

```sql
-- Verificar quantos índices uma tabela tem:
SELECT indexname, indexdef
FROM pg_indexes WHERE tablename = 'orders';

-- Se você tem 10+ índices e write throughput é um problema,
-- questione cada índice: ele é realmente usado?
SELECT schemaname, relname, indexrelname, idx_scan, idx_tup_read
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY idx_scan ASC;
-- Índices com idx_scan = 0 há semanas/meses são candidatos para remoção
```

### Index Bloat

Assim como tabelas, índices sofrem de **bloat** — páginas parcialmente vazias causadas por DELETEs e UPDATEs. O VACUUM libera espaço na tabela mas não compacta índices de forma eficiente. Com o tempo, um índice pode estar usando 3x mais espaço do que o necessário.

```sql
-- Estimar bloat com a extensão pgstattuple:
CREATE EXTENSION IF NOT EXISTS pgstattuple;
SELECT * FROM pgstatindex('idx_orders_status_date');
--  tree_level | 2
--  index_size | 268435456    (256 MB)
--  leaf_pages | 30000
--  empty_pages | 8500        ← 28% das páginas estão vazias = bloat

-- Solução: REINDEX (bloqueia a tabela) ou REINDEX CONCURRENTLY (PostgreSQL 12+)
REINDEX INDEX CONCURRENTLY idx_orders_status_date;
```

### HOT Updates no PostgreSQL

HOT (Heap-Only Tuple) é uma otimização onde um UPDATE que **não modifica nenhuma coluna indexada** pode atualizar a row in-place na mesma heap page sem tocar em nenhum índice. Isso é extremamente importante para performance de UPDATEs.

```sql
-- Se a tabela 'users' tem índices em (email) e (created_at):
-- UPDATE que modifica 'name' (não indexada) → pode ser HOT ✓
UPDATE users SET name = 'Novo Nome' WHERE id = 42;

-- UPDATE que modifica 'email' (indexada) → NÃO pode ser HOT ✗
UPDATE users SET email = 'novo@email.com' WHERE id = 42;

-- Verificar taxa de HOT updates:
SELECT relname,
       n_tup_upd AS total_updates,
       n_tup_hot_upd AS hot_updates,
       CASE WHEN n_tup_upd > 0
            THEN round(100.0 * n_tup_hot_upd / n_tup_upd, 1)
            ELSE 0 END AS hot_pct
FROM pg_stat_user_tables
WHERE relname = 'users';
--  relname | total_updates | hot_updates | hot_pct
-- ---------+---------------+-------------+---------
--  users   |       5000000 |     4250000 |    85.0

-- Se hot_pct é baixo, investigue se você tem índices desnecessários
-- em colunas frequentemente atualizadas. Cada índice removido aumenta a
-- chance de HOT updates.
```

Para que HOT funcione, a nova versão da row precisa caber na **mesma heap page**. Manter um `fillfactor` menor que 100 reserva espaço para isso:

```sql
ALTER TABLE users SET (fillfactor = 90);
-- Reserva 10% de cada página para acomodar HOT updates
-- Após alterar, rode VACUUM FULL ou CLUSTER para reestruturar
```

---

## Quando NÃO Indexar

Índice não é bala de prata. Criar índices desnecessários causa dano real.

**Tabelas pequenas (< ~10.000 rows):** um Sequential Scan em uma tabela de 80 KB é mais rápido que descer uma B-Tree, porque a tabela inteira cabe em poucas páginas que provavelmente já estão em cache. O overhead do índice (espaço, write amplification) não compensa.

**Colunas com baixa cardinalidade:** um índice B-Tree em uma coluna `status` com 3 valores distintos (`active`, `inactive`, `suspended`) tem seletividade de ~33%. O planner quase sempre vai preferir Seq Scan. **Exceção:** partial index (`WHERE status = 'suspended'`) funciona bem quando um dos valores é raro.

**Workloads write-heavy:** tabelas de logs, eventos, métricas de tempo real — onde a taxa de INSERT é de milhares por segundo e as leituras são raras ou tolerantes a latência. Aqui, considere BRIN (overhead mínimo) ou nenhum índice, e use particionamento por data para manter performance de leitura.

**Colunas frequentemente atualizadas:** se uma coluna muda a cada segundo e tem índice, cada update atualiza o índice e impede HOT updates. Avalie se o índice é realmente necessário ou se a query pode ser reestruturada.

```sql
-- Anti-pattern: indexar tudo "por precaução"
CREATE INDEX idx_users_name ON users (name);          -- baixa seletividade, raramente filtrado
CREATE INDEX idx_users_bio ON users (bio);            -- texto longo, quase nunca filtrado
CREATE INDEX idx_users_updated_at ON users (updated_at); -- atualizado em cada request

-- Resultado: 3 índices inúteis que:
-- 1. Consomem ~500 MB de disco combinados
-- 2. Reduzem throughput de INSERT/UPDATE em ~30%
-- 3. Eliminam possibilidade de HOT updates em qualquer UPDATE
-- 4. Precisam ser mantidos pelo VACUUM, aumentando I/O de background

-- Antes de criar um índice, SEMPRE verifique:
-- 1. A query que ele vai beneficiar realmente existe e é frequente?
-- 2. EXPLAIN ANALYZE mostra Seq Scan E a performance é insatisfatória?
-- 3. A coluna tem cardinalidade suficiente?
-- 4. O impacto em write performance é aceitável?
```

---

## Resumo de Tipos de Índice

| Tipo | Melhor para | Operadores | Tamanho | Custo de escrita |
|---|---|---|---|---|
| **B-Tree** | Igualdade, range, ORDER BY, LIKE 'prefix%' | `=  <  >  <=  >=  BETWEEN  IN  IS NULL` | Médio | Médio |
| **Hash** | Apenas igualdade exata | `=` | Médio | Baixo |
| **GIN** | Full-text, JSONB, arrays, múltiplos elementos por row | `@@  @>  ?  ?&  ?\|  &&` | Grande | Alto |
| **GiST** | Geoespacial, ranges, nearest-neighbor | `&&  @>  <@  <->  ~=` | Médio | Médio |
| **BRIN** | Dados naturalmente ordenados, tabelas enormes | `<  <=  =  >=  >` | Mínimo | Mínimo |

A escolha do índice correto é tão importante quanto a decisão de indexar. Um GIN onde caberia um B-Tree desperdiça espaço e write throughput. Um B-Tree onde caberia um BRIN desperdiça 1000x mais espaço. Um índice que ninguém usa é puro custo sem benefício. **Meça, não adivinhe** — `EXPLAIN ANALYZE` e `pg_stat_user_indexes` são suas ferramentas de decisão.
