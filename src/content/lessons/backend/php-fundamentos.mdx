---
title: "PHP Moderno — Fundamentos e Boas Práticas"
description: "PHP 8.x, tipos, OOP, Composer, PSR standards, Laravel essencial, testing com PHPUnit e as práticas que transformaram PHP numa linguagem moderna e robusta"
track: "backend"
order: 8
section: "PHP"
priority: "high"
tags: ["php", "laravel", "composer", "psr", "oop", "phpunit", "boas-práticas"]
prerequisites: []
keyTakeaways:
  - "PHP moderno (8.x) é drasticamente diferente do PHP 4/5: tipos estritos, enums, fibers, named arguments, match expressions e JIT compilation"
  - "Composer é o gerenciador de pacotes e autoloader padrão — PSR-4 autoloading elimina requires manuais"
  - "Laravel domina o ecossistema: Eloquent ORM, Blade templates, Artisan CLI, queues, events e um ecossistema rico (Forge, Vapor, Horizon)"
  - "PSR standards (PSR-1, PSR-4, PSR-7, PSR-12) garantem interoperabilidade entre frameworks e bibliotecas"
  - "PHP roda como share-nothing architecture: cada request é isolado, sem estado compartilhado — isso simplifica concorrência mas exige cache externo (Redis)"
---

## PHP Moderno — Por Que Ainda Importa

PHP alimenta aproximadamente 77% dos websites com server-side conhecida. WordPress sozinho representa mais de 40% da web. Laravel é o framework backend mais estrelado no GitHub. Ignorar PHP por preconceito com código legado de 2005 é ignorar a realidade do mercado.

A linguagem mudou drasticamente. O PHP 8.x de hoje tem mais em comum com TypeScript e Kotlin do que com o PHP 4 que gerou a má reputação. A evolução:

```
PHP 4 (2000)    Sem OOP real, sem tipos, sem namespaces
                register_globals, magic_quotes — desastres de seguranca
                |
PHP 5.0 (2004)  OOP real (classes, interfaces, excepcoes)
                PDO para acesso a banco de dados
                |
PHP 5.3 (2009)  Namespaces, closures, late static binding
                Marco: Composer e PSR comecam a surgir
                |
PHP 5.6 (2014)  Variadic functions, constant expressions
                Ultimo da era 5.x
                |
PHP 7.0 (2015)  REVOLUÇÃO: 2x mais rapido que PHP 5.6
                Scalar type hints, return types, null coalesce (??)
                Spaceship operator (<=>), anonymous classes
                |
PHP 7.4 (2019)  Arrow functions, typed properties, preloading
                Spread operator em arrays
                |
PHP 8.0 (2020)  JIT compiler, union types, named arguments
                match expression, nullsafe operator (?->)
                Attributes (annotations nativas)
                Constructor promotion
                |
PHP 8.1 (2021)  Enums, fibers, readonly properties
                Intersection types, never return type
                |
PHP 8.2 (2022)  Readonly classes, DNF types
                Depreca dynamic properties
                |
PHP 8.3 (2023)  Typed class constants, json_validate()
                Deep cloning de readonly properties
                #[\Override] attribute
```

### Performance: PHP 8 vs PHP 5

O salto de performance entre PHP 5.6 e PHP 8.x com JIT e OPcache e brutal:

```
Benchmark WordPress (requests/segundo):
  PHP 5.6:    ~95 req/s
  PHP 7.0:    ~185 req/s   (2x)
  PHP 7.4:    ~210 req/s   (2.2x)
  PHP 8.0:    ~235 req/s   (2.5x)
  PHP 8.1+:   ~250 req/s   (2.6x, com JIT em workloads CPU-bound)

Para workloads I/O-bound (maioria das apps web), a diferenca entre 8.0 e 8.3
e marginal. O JIT brilha em computacao pura (processamento de imagem, ML).
```

### Share-Nothing Architecture

Diferente de Node.js ou Go, cada request PHP inicia um processo limpo. Nao ha estado compartilhado entre requests — nenhuma variavel global persiste, nenhum memory leak acumula:

```
Request 1                  Request 2                  Request 3
    |                          |                          |
    v                          v                          v
[Bootstrap]               [Bootstrap]               [Bootstrap]
[Autoload]                [Autoload]                [Autoload]
[Execute]                 [Execute]                 [Execute]
[Response]                [Response]                [Response]
[Destroy]                 [Destroy]                 [Destroy]
    |                          |                          |
    x (tudo limpo)             x (tudo limpo)             x (tudo limpo)

Vantagens:
  - Sem memory leaks entre requests
  - Sem race conditions de estado compartilhado
  - Deploy simples (substitui arquivos, reinicia PHP-FPM)
  - Cada request e isolado — bug num request nao afeta outros

Desvantagens:
  - Bootstrap overhead em cada request (mitigado por OPcache e preloading)
  - Estado compartilhado exige infra externa (Redis, Memcached)
  - Conexoes de banco sao recriadas (mitigado por connection pooling)
```

---

## Tipos e Sintaxe Moderna

### Strict Types

Por padrao, PHP faz coercao de tipos. `declare(strict_types=1)` desativa isso **no arquivo onde e declarado**:

```php
<?php
// SEM strict_types (padrao) — coercao silenciosa
function soma(int $a, int $b): int {
    return $a + $b;
}
soma("3", "4"); // Retorna 7 — PHP converte strings para int silenciosamente

// COM strict_types — TypeError se tipos nao batem
declare(strict_types=1);

function soma(int $a, int $b): int {
    return $a + $b;
}
soma("3", "4"); // TypeError: Argument #1 must be of type int, string given

// REGRA: sempre use declare(strict_types=1) no topo de CADA arquivo.
// Nao ha opcao global — e por arquivo, por design.
```

### Union Types e Intersection Types

```php
declare(strict_types=1);

// Union type: aceita string OU int
function formatId(string|int $id): string {
    return "ID-{$id}";
}

formatId(42);       // "ID-42"
formatId("abc");    // "ID-abc"

// Nullable e sugar para union com null
function findUser(int $id): ?User {
    // equivalente a: User|null
    return User::find($id);
}

// Intersection type (PHP 8.1): o valor deve implementar AMBAS as interfaces
function process(Countable&Iterator $collection): void {
    echo count($collection);     // Countable
    foreach ($collection as $item) { /* ... */ }  // Iterator
}

// DNF Types (PHP 8.2): combinacao de union e intersection
function handle((Countable&Iterator)|null $data): void {
    if ($data === null) return;
    // $data implementa Countable E Iterator
}
```

### Enums (PHP 8.1)

Antes de enums, usavamos constantes de classe ou strings magicas. Enums sao type-safe e integrados com a linguagem:

```php
declare(strict_types=1);

// Enum basico (Unit Enum)
enum Status {
    case Active;
    case Inactive;
    case Suspended;
}

// Enum com valor (Backed Enum)
enum OrderStatus: string {
    case Pending = 'pending';
    case Processing = 'processing';
    case Shipped = 'shipped';
    case Delivered = 'delivered';
    case Cancelled = 'cancelled';

    // Enums podem ter metodos
    public function label(): string {
        return match($this) {
            self::Pending => 'Aguardando',
            self::Processing => 'Em processamento',
            self::Shipped => 'Enviado',
            self::Delivered => 'Entregue',
            self::Cancelled => 'Cancelado',
        };
    }

    public function isFinal(): bool {
        return in_array($this, [self::Delivered, self::Cancelled]);
    }
}

// Uso
$status = OrderStatus::Pending;
echo $status->value;   // "pending"
echo $status->label();  // "Aguardando"

// Criar a partir de valor (do banco, API, etc.)
$fromDb = OrderStatus::from('shipped');        // OrderStatus::Shipped
$maybe = OrderStatus::tryFrom('invalid');      // null (sem excecao)

// Type safety em funcoes
function updateOrder(int $orderId, OrderStatus $status): void {
    // $status so pode ser um dos valores validos — compilador garante
}

// Enums implementam interfaces
enum Color: string implements HasLabel {
    case Red = 'red';
    case Blue = 'blue';

    public function label(): string {
        return match($this) {
            self::Red => 'Vermelho',
            self::Blue => 'Azul',
        };
    }
}
```

### Readonly Properties e Classes

```php
declare(strict_types=1);

// Readonly property (PHP 8.1): so pode ser atribuida uma vez
class Money {
    public function __construct(
        public readonly float $amount,
        public readonly string $currency,
    ) {}
}

$price = new Money(29.90, 'BRL');
echo $price->amount;     // 29.90
// $price->amount = 50;  // Error: Cannot modify readonly property

// Readonly class (PHP 8.2): todas as propriedades sao readonly
readonly class Coordinate {
    public function __construct(
        public float $latitude,
        public float $longitude,
    ) {}
}
```

### Named Arguments

```php
declare(strict_types=1);

// Sem named arguments — qual e qual?
str_contains('Hello World', 'World');  // Qual e haystack? Qual e needle?

// Com named arguments (PHP 8.0) — intencao explicita
str_contains(haystack: 'Hello World', needle: 'World');

// Particularmente util em funcoes com muitos parametros opcionais
function createUser(
    string $name,
    string $email,
    string $role = 'user',
    bool $active = true,
    ?string $avatar = null,
    array $permissions = [],
): User {
    // ...
}

// Sem named args: precisa passar todos os defaults para chegar ao que quer
createUser('Lucas', 'lucas@example.com', 'user', true, null, ['admin.read']);

// Com named args: pula direto para o parametro desejado
createUser(
    name: 'Lucas',
    email: 'lucas@example.com',
    permissions: ['admin.read'],
);
```

### Match Expression

`match` e a versao moderna do `switch` — retorna valor, usa comparacao estrita, e exaustivo:

```php
declare(strict_types=1);

// switch classico (problemas: fall-through, coercao de tipos)
switch ($statusCode) {
    case 200:
        $text = 'OK';
        break;       // Esqueceu o break? Fall-through silencioso.
    case 404:
        $text = 'Not Found';
        break;
    default:
        $text = 'Unknown';
}

// match (PHP 8.0): sem fall-through, comparacao estrita, retorna valor
$text = match($statusCode) {
    200 => 'OK',
    301 => 'Moved Permanently',
    404 => 'Not Found',
    500 => 'Internal Server Error',
    default => 'Unknown',
};

// match com multiplos valores
$category = match(true) {
    $statusCode >= 200 && $statusCode < 300 => 'success',
    $statusCode >= 300 && $statusCode < 400 => 'redirect',
    $statusCode >= 400 && $statusCode < 500 => 'client_error',
    $statusCode >= 500 => 'server_error',
    default => 'unknown',
};

// match lanca UnhandledMatchError se nenhum caso bate e nao ha default
// Isso e INTENCIONAL — forca voce a tratar todos os casos
```

### Nullsafe Operator

```php
declare(strict_types=1);

// Antes: encadeamento defensivo contra null
$city = null;
if ($user !== null) {
    $address = $user->getAddress();
    if ($address !== null) {
        $city = $address->getCity();
    }
}

// Depois (PHP 8.0): nullsafe operator
$city = $user?->getAddress()?->getCity();
// Se qualquer parte for null, toda a expressao retorna null
// Sem NullPointerException, sem verificacoes manuais

// Combina com null coalesce para valor padrao
$city = $user?->getAddress()?->getCity() ?? 'Nao informado';
```

### Fibers (PHP 8.1)

Fibers sao a base para concorrencia cooperativa. Na pratica, voce raramente usa Fibers diretamente — frameworks como ReactPHP e Revolt abstraem isso:

```php
declare(strict_types=1);

// Fiber: funcao que pode ser suspensa e retomada
$fiber = new Fiber(function (): void {
    $value = Fiber::suspend('primeiro');
    echo "Recebi: {$value}\n";

    $value = Fiber::suspend('segundo');
    echo "Recebi: {$value}\n";
});

$result1 = $fiber->start();         // "primeiro"
$result2 = $fiber->resume('hello'); // Imprime "Recebi: hello", retorna "segundo"
$fiber->resume('world');             // Imprime "Recebi: world"

// Na pratica, Fibers habilitam async/await em PHP via libraries:
// - Revolt (event loop padrao para PHP async)
// - ReactPHP (networking async)
// - AMPHP (framework async completo)
```

---

## OOP em PHP

### Classes, Interfaces e Traits

```php
declare(strict_types=1);

// Interface: contrato que classes devem implementar
interface PaymentGateway {
    public function charge(Money $amount, PaymentMethod $method): PaymentResult;
    public function refund(string $transactionId, Money $amount): RefundResult;
}

// Abstract class: implementacao parcial — nao pode ser instanciada
abstract class BaseRepository {
    public function __construct(
        protected readonly PDO $connection,
    ) {}

    abstract protected function tableName(): string;

    public function findById(int $id): ?array {
        $stmt = $this->connection->prepare(
            "SELECT * FROM {$this->tableName()} WHERE id = :id"
        );
        $stmt->execute(['id' => $id]);
        return $stmt->fetch(PDO::FETCH_ASSOC) ?: null;
    }

    public function delete(int $id): bool {
        $stmt = $this->connection->prepare(
            "DELETE FROM {$this->tableName()} WHERE id = :id"
        );
        return $stmt->execute(['id' => $id]);
    }
}

// Classe concreta
class UserRepository extends BaseRepository {
    protected function tableName(): string {
        return 'users';
    }

    public function findByEmail(string $email): ?array {
        $stmt = $this->connection->prepare(
            "SELECT * FROM users WHERE email = :email"
        );
        $stmt->execute(['email' => $email]);
        return $stmt->fetch(PDO::FETCH_ASSOC) ?: null;
    }
}
```

### Traits

PHP nao tem heranca multipla. Traits resolvem isso — sao blocos de codigo reutilizaveis que podem ser "injetados" em classes:

```php
declare(strict_types=1);

trait HasTimestamps {
    public readonly DateTimeImmutable $createdAt;
    public ?DateTimeImmutable $updatedAt = null;

    public function initTimestamps(): void {
        $this->createdAt = new DateTimeImmutable();
    }

    public function touch(): void {
        $this->updatedAt = new DateTimeImmutable();
    }
}

trait SoftDeletes {
    public ?DateTimeImmutable $deletedAt = null;

    public function softDelete(): void {
        $this->deletedAt = new DateTimeImmutable();
    }

    public function restore(): void {
        $this->deletedAt = null;
    }

    public function isTrashed(): bool {
        return $this->deletedAt !== null;
    }
}

class Post {
    use HasTimestamps, SoftDeletes;

    public function __construct(
        public readonly int $id,
        public string $title,
        public string $body,
    ) {
        $this->initTimestamps();
    }
}

$post = new Post(1, 'PHP Moderno', 'Conteudo aqui...');
$post->softDelete();
echo $post->isTrashed(); // true
```

### Constructor Promotion (PHP 8.0)

Elimina o boilerplate de declarar propriedades e atribuir no construtor:

```php
declare(strict_types=1);

// ANTES: verboso e repetitivo
class Product {
    private string $name;
    private float $price;
    private string $sku;
    private int $stock;

    public function __construct(
        string $name,
        float $price,
        string $sku,
        int $stock = 0
    ) {
        $this->name = $name;
        $this->price = $price;
        $this->sku = $sku;
        $this->stock = $stock;
    }
}

// DEPOIS: constructor promotion
class Product {
    public function __construct(
        private readonly string $name,
        private readonly float $price,
        private readonly string $sku,
        private int $stock = 0,
    ) {}

    public function getName(): string {
        return $this->name;
    }

    public function deductStock(int $quantity): void {
        if ($quantity > $this->stock) {
            throw new InsufficientStockException($this->sku, $this->stock, $quantity);
        }
        $this->stock -= $quantity;
    }
}
```

### Namespaces

Namespaces organizam codigo e evitam conflitos de nomes. Seguem a estrutura de diretorios por convencao PSR-4:

```php
<?php
// Arquivo: src/Domain/Order/Order.php
namespace App\Domain\Order;

use App\Domain\Money\Money;
use App\Domain\User\User;
use DateTimeImmutable;

class Order {
    /** @var OrderItem[] */
    private array $items = [];

    public function __construct(
        private readonly string $id,
        private readonly User $customer,
        private OrderStatus $status = OrderStatus::Pending,
        private readonly DateTimeImmutable $createdAt = new DateTimeImmutable(),
    ) {}

    public function addItem(Product $product, int $quantity, Money $unitPrice): void {
        $this->items[] = new OrderItem($product, $quantity, $unitPrice);
    }

    public function total(): Money {
        return array_reduce(
            $this->items,
            fn(Money $carry, OrderItem $item) => $carry->add($item->subtotal()),
            Money::zero('BRL'),
        );
    }
}
```

```
Estrutura de diretorios alinhada com namespaces (PSR-4):

src/
├── Domain/
│   ├── Order/
│   │   ├── Order.php           → App\Domain\Order\Order
│   │   ├── OrderItem.php       → App\Domain\Order\OrderItem
│   │   ├── OrderStatus.php     → App\Domain\Order\OrderStatus
│   │   └── OrderRepository.php → App\Domain\Order\OrderRepository (interface)
│   ├── User/
│   │   ├── User.php            → App\Domain\User\User
│   │   └── UserRepository.php  → App\Domain\User\UserRepository (interface)
│   └── Money/
│       └── Money.php           → App\Domain\Money\Money
├── Infrastructure/
│   ├── Persistence/
│   │   ├── EloquentOrderRepository.php
│   │   └── EloquentUserRepository.php
│   └── Http/
│       └── Controllers/
└── Application/
    └── Services/
        └── CreateOrderService.php
```

---

## Composer e Autoloading

Composer e o gerenciador de dependencias do PHP. Sem ele, o ecossistema PHP moderno nao existe.

### composer.json

```json
{
    "name": "brewnary/api",
    "description": "API da plataforma Brewnary",
    "type": "project",
    "license": "MIT",
    "require": {
        "php": "^8.2",
        "laravel/framework": "^11.0",
        "laravel/sanctum": "^4.0",
        "predis/predis": "^2.0",
        "spatie/laravel-permission": "^6.0",
        "spatie/laravel-query-builder": "^6.0"
    },
    "require-dev": {
        "phpunit/phpunit": "^11.0",
        "pestphp/pest": "^3.0",
        "phpstan/phpstan": "^1.10",
        "laravel/pint": "^1.0",
        "fakerphp/faker": "^1.23",
        "mockery/mockery": "^1.6"
    },
    "autoload": {
        "psr-4": {
            "App\\": "src/"
        }
    },
    "autoload-dev": {
        "psr-4": {
            "Tests\\": "tests/"
        }
    },
    "scripts": {
        "test": "pest --parallel",
        "lint": "pint --test",
        "lint:fix": "pint",
        "analyse": "phpstan analyse --memory-limit=512M",
        "check": [
            "@lint",
            "@analyse",
            "@test"
        ]
    },
    "config": {
        "optimize-autoloader": true,
        "sort-packages": true
    }
}
```

### Semver e Constraints

```
Constraint        Significado                    Exemplo
────────────     ────────────────────────────   ──────────────
^8.2             >=8.2.0 <9.0.0                Compativel com 8.x
~8.2             >=8.2.0 <8.3.0                Compativel com 8.2.x
>=8.2            Qualquer versao >= 8.2.0       Sem limite superior
8.2.*            Qualquer patch de 8.2          8.2.0, 8.2.1, ...
^8.2 || ^9.0     8.x a partir de 8.2 OU 9.x    Transicao entre majors

O operador ^ (caret) e o mais usado. Ele permite updates que nao quebram
a API publica seguindo semver:
  ^1.2.3 → >=1.2.3 <2.0.0
  ^0.3.0 → >=0.3.0 <0.4.0  (para 0.x, minor e tratado como major)
```

### PSR-4 Autoloading

O autoload PSR-4 mapeia namespaces para diretorios. Quando voce faz `use App\Domain\Order\Order`, o Composer sabe que deve carregar `src/Domain/Order/Order.php`:

```php
// Sem autoloader (PHP antigo): requires manuais, frageis, insustentaveis
require_once 'src/Domain/Order/Order.php';
require_once 'src/Domain/Order/OrderItem.php';
require_once 'src/Domain/Money/Money.php';
// ... 50 requires para cada arquivo ...

// Com Composer PSR-4: um unico require no entry point
require_once __DIR__ . '/vendor/autoload.php';

// Pronto. Qualquer classe do namespace App\ e carregada automaticamente.
// O Composer gera o mapa namespace → diretorio a partir do composer.json.
```

### Comandos Essenciais

```bash
# Instalar dependencias (cria vendor/ e composer.lock)
composer install

# Adicionar dependencia
composer require laravel/framework

# Adicionar dependencia de desenvolvimento
composer require --dev phpunit/phpunit

# Atualizar dependencias (respeita constraints do composer.json)
composer update

# Otimizar autoloader para producao (classmap em vez de PSR-4 dinamico)
composer dump-autoload --optimize --classmap-authoritative

# Verificar vulnerabilidades conhecidas
composer audit

# Mostrar por que um pacote foi instalado
composer why predis/predis

# Mostrar pacotes desatualizados
composer outdated
```

---

## PSR Standards

PSR (PHP Standard Recommendation) sao padroes definidos pelo PHP-FIG (Framework Interop Group) para garantir interoperabilidade entre frameworks e bibliotecas. Sem PSRs, cada framework teria seu proprio autoloader, seu proprio formato de HTTP message, seu proprio coding style.

### PSR-1: Basic Coding Standard

```php
// PSR-1 define regras fundamentais:
// - Arquivos DEVEM usar <?php ou <?= (nunca <?)
// - Arquivos DEVEM usar UTF-8 sem BOM
// - Namespaces e classes DEVEM seguir PSR-4
// - Nomes de classes: StudlyCaps (PascalCase)
// - Constantes de classe: UPPER_SNAKE_CASE
// - Metodos: camelCase

class OrderProcessor                    // StudlyCaps
{
    const MAX_RETRY_ATTEMPTS = 3;       // UPPER_SNAKE_CASE

    public function processOrder(): void // camelCase
    {
        // ...
    }
}
```

### PSR-4: Autoloading Standard

Define como namespaces mapeiam para caminhos no filesystem. E o padrao que o Composer implementa:

```
Namespace completo: App\Infrastructure\Persistence\EloquentUserRepository
Prefixo (composer.json): App\ → src/
Caminho resultante: src/Infrastructure/Persistence/EloquentUserRepository.php

Regras:
  - O prefixo do namespace DEVE corresponder a um diretorio base
  - Cada separador \ no namespace corresponde a um separador de diretorio
  - O nome da classe corresponde ao nome do arquivo + .php
  - Case-sensitive em todo o mapeamento
```

### PSR-7: HTTP Message Interface

Define interfaces para HTTP requests e responses. Permite que bibliotecas de HTTP sejam intercambiaveis:

```php
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Message\ResponseInterface;

// Qualquer framework que implemente PSR-7 pode usar este middleware
function corsMiddleware(
    ServerRequestInterface $request,
    ResponseInterface $response,
): ResponseInterface {
    return $response
        ->withHeader('Access-Control-Allow-Origin', '*')
        ->withHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE')
        ->withHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
}

// PSR-7 messages sao IMUTAVEIS:
// $response->withHeader() retorna um NOVO objeto, nao modifica o original
$response = $response
    ->withStatus(200)
    ->withHeader('Content-Type', 'application/json');
```

### PSR-12: Extended Coding Style

Estende PSR-1 com regras detalhadas de formatacao. Na pratica, ferramentas como PHP-CS-Fixer e Laravel Pint aplicam PSR-12 automaticamente:

```php
declare(strict_types=1);

namespace App\Domain\Order;

use App\Domain\Money\Money;
use App\Domain\User\User;
use DateTimeImmutable;
use InvalidArgumentException;

// PSR-12: chave de abertura da classe na MESMA linha da declaracao
// (diferente de PSR-2 que era na linha seguinte para classes)
class OrderService
{
    // PSR-12: visibilidade DEVE ser declarada em todas as propriedades e metodos
    public function __construct(
        private readonly OrderRepository $orders,
        private readonly PaymentGateway $payments,
    ) {}

    // PSR-12: tipo de retorno com espaco antes dos dois pontos
    public function create(User $customer, array $items): Order
    {
        if (empty($items)) {
            throw new InvalidArgumentException('Pedido deve ter ao menos um item');
        }

        // PSR-12: operadores com espacos, sem espacos apos ( e antes de )
        $order = new Order(
            id: $this->generateId(),
            customer: $customer,
        );

        foreach ($items as $item) {
            $order->addItem(
                product: $item['product'],
                quantity: $item['quantity'],
                unitPrice: $item['price'],
            );
        }

        return $order;
    }
}
```

### PSR-15: HTTP Server Request Handlers (Middleware)

Define a interface padrao para middleware HTTP. Toda a stack de middleware do Laravel, Slim e Mezzio segue essa convencao:

```php
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;

class RateLimitMiddleware implements MiddlewareInterface
{
    public function __construct(
        private readonly RateLimiter $limiter,
        private readonly int $maxRequests = 100,
    ) {}

    public function process(
        ServerRequestInterface $request,
        RequestHandlerInterface $handler,
    ): ResponseInterface {
        $clientIp = $request->getServerParams()['REMOTE_ADDR'] ?? 'unknown';

        if ($this->limiter->isExceeded($clientIp, $this->maxRequests)) {
            return new JsonResponse(
                ['error' => 'Rate limit exceeded'],
                429,
                ['Retry-After' => '60'],
            );
        }

        // Passa para o proximo middleware na stack
        return $handler->handle($request);
    }
}

// A stack de middleware forma um pipeline:
//
// Request → [Auth] → [RateLimit] → [CORS] → [Controller] → Response
//                                                 ↓
// Response ← [Auth] ← [RateLimit] ← [CORS] ← [Response]
```

### Por Que PSRs Importam

```
Sem PSRs:
  Framework A usa autoloader proprio
  Framework B usa autoloader proprio
  Biblioteca X so funciona com Framework A
  Biblioteca Y so funciona com Framework B
  → Ecossistema fragmentado, lock-in total

Com PSRs:
  Framework A implementa PSR-4, PSR-7, PSR-15
  Framework B implementa PSR-4, PSR-7, PSR-15
  Biblioteca X usa PSR-7 → funciona com A e B
  Biblioteca Y usa PSR-15 → funciona com A e B
  → Ecossistema interoperavel, bibliotecas reutilizaveis
```

---

## Laravel Essencial

Laravel e o framework PHP mais popular, criado por Taylor Otwell em 2011. Domina o ecossistema com um conjunto coeso de ferramentas para praticamente qualquer necessidade backend.

### Routing

```php
// routes/api.php
use App\Http\Controllers\OrderController;
use Illuminate\Support\Facades\Route;

// Rotas simples
Route::get('/orders', [OrderController::class, 'index']);
Route::post('/orders', [OrderController::class, 'store']);
Route::get('/orders/{order}', [OrderController::class, 'show']);
Route::put('/orders/{order}', [OrderController::class, 'update']);
Route::delete('/orders/{order}', [OrderController::class, 'destroy']);

// Resource controller (gera todas as rotas CRUD acima)
Route::apiResource('orders', OrderController::class);

// Rotas com middleware
Route::middleware(['auth:sanctum', 'throttle:60,1'])->group(function () {
    Route::apiResource('orders', OrderController::class);
    Route::post('/orders/{order}/cancel', [OrderController::class, 'cancel']);
});

// Route model binding: Laravel resolve {order} automaticamente
// Se o ID nao existir, retorna 404 sem codigo manual
```

### Controllers

```php
declare(strict_types=1);

namespace App\Http\Controllers;

use App\Http\Requests\StoreOrderRequest;
use App\Http\Resources\OrderResource;
use App\Models\Order;
use App\Services\OrderService;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Resources\Json\AnonymousResourceCollection;

class OrderController extends Controller
{
    public function __construct(
        private readonly OrderService $orderService,
    ) {}

    public function index(): AnonymousResourceCollection
    {
        $orders = Order::query()
            ->where('user_id', auth()->id())
            ->with(['items.product', 'payment'])  // Eager loading (evita N+1)
            ->latest()
            ->paginate(20);

        return OrderResource::collection($orders);
    }

    public function store(StoreOrderRequest $request): JsonResponse
    {
        // StoreOrderRequest ja validou os dados — se invalido, retorna 422
        $order = $this->orderService->create(
            user: $request->user(),
            items: $request->validated('items'),
        );

        return OrderResource::make($order)
            ->response()
            ->setStatusCode(201);
    }

    public function show(Order $order): OrderResource
    {
        // Route model binding: $order ja foi resolvido pelo ID na URL
        $this->authorize('view', $order);  // Policy check
        return OrderResource::make($order->load('items.product'));
    }
}
```

### Eloquent ORM

Eloquent e um Active Record ORM — cada model representa uma tabela e cada instancia uma linha:

```php
declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\SoftDeletes;

class Order extends Model
{
    use HasFactory, SoftDeletes;

    protected $fillable = [
        'user_id',
        'status',
        'total',
        'notes',
    ];

    // Cast automatico de tipos
    protected function casts(): array
    {
        return [
            'status' => OrderStatus::class,   // Enum cast
            'total' => 'decimal:2',
            'shipped_at' => 'immutable_datetime',
        ];
    }

    // Relacionamentos
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function items(): HasMany
    {
        return $this->hasMany(OrderItem::class);
    }

    // Scopes: queries reutilizaveis
    public function scopePending($query)
    {
        return $query->where('status', OrderStatus::Pending);
    }

    public function scopeRecent($query, int $days = 30)
    {
        return $query->where('created_at', '>=', now()->subDays($days));
    }
}

// Uso do Eloquent — queries fluentes
$recentPendingOrders = Order::query()
    ->pending()
    ->recent(7)
    ->with('items')
    ->orderByDesc('created_at')
    ->get();

// Criar
$order = Order::create([
    'user_id' => $user->id,
    'status' => OrderStatus::Pending,
    'total' => 299.90,
]);

// Atualizar
$order->update(['status' => OrderStatus::Shipped, 'shipped_at' => now()]);

// Query complexa com joins e aggregates
$topCustomers = User::query()
    ->select('users.name', 'users.email')
    ->selectRaw('COUNT(orders.id) as total_orders')
    ->selectRaw('SUM(orders.total) as total_spent')
    ->join('orders', 'users.id', '=', 'orders.user_id')
    ->where('orders.status', OrderStatus::Delivered)
    ->groupBy('users.id', 'users.name', 'users.email')
    ->orderByDesc('total_spent')
    ->limit(10)
    ->get();
```

### Migrations

```php
// database/migrations/2024_01_15_000001_create_orders_table.php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration {
    public function up(): void
    {
        Schema::create('orders', function (Blueprint $table) {
            $table->id();
            $table->foreignId('user_id')->constrained()->cascadeOnDelete();
            $table->string('status', 20)->default('pending')->index();
            $table->decimal('total', 10, 2);
            $table->text('notes')->nullable();
            $table->timestamp('shipped_at')->nullable();
            $table->timestamps();   // created_at, updated_at
            $table->softDeletes();  // deleted_at

            // Indices compostos para queries frequentes
            $table->index(['user_id', 'status']);
            $table->index(['status', 'created_at']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('orders');
    }
};
```

```bash
# Rodar migrations
php artisan migrate

# Rollback da ultima migration
php artisan migrate:rollback

# Reset completo (drop all + migrate)
php artisan migrate:fresh

# Seed de dados
php artisan migrate:fresh --seed
```

### Blade Templates

```php
{{-- resources/views/orders/show.blade.php --}}
<x-app-layout>
    <x-slot name="header">
        <h2>Pedido #{{ $order->id }}</h2>
    </x-slot>

    <div class="max-w-4xl mx-auto py-8">
        {{-- Condicional --}}
        @if($order->status === OrderStatus::Cancelled)
            <x-alert type="error">Este pedido foi cancelado.</x-alert>
        @elseif($order->status === OrderStatus::Delivered)
            <x-alert type="success">Pedido entregue em {{ $order->shipped_at->format('d/m/Y') }}</x-alert>
        @endif

        {{-- Loop com itens --}}
        <table>
            <thead>
                <tr>
                    <th>Produto</th>
                    <th>Qtd</th>
                    <th>Preco</th>
                </tr>
            </thead>
            <tbody>
                @forelse($order->items as $item)
                    <tr>
                        <td>{{ $item->product->name }}</td>
                        <td>{{ $item->quantity }}</td>
                        <td>R$ {{ number_format($item->subtotal, 2, ',', '.') }}</td>
                    </tr>
                @empty
                    <tr>
                        <td colspan="3">Nenhum item neste pedido.</td>
                    </tr>
                @endforelse
            </tbody>
        </table>

        {{-- Escapamento automatico contra XSS --}}
        {{-- {{ $value }} escapa HTML automaticamente --}}
        {{-- {!! $value !!} renderiza HTML raw (PERIGO — so use se sanitizado) --}}

        <p>Total: <strong>R$ {{ number_format($order->total, 2, ',', '.') }}</strong></p>
    </div>
</x-app-layout>
```

### Service Container e Dependency Injection

O service container do Laravel e o nucleo do framework. Ele resolve dependencias automaticamente via autowiring:

```php
declare(strict_types=1);

namespace App\Providers;

use App\Domain\Order\OrderRepository;
use App\Infrastructure\Persistence\EloquentOrderRepository;
use Illuminate\Support\ServiceProvider;

class AppServiceProvider extends ServiceProvider
{
    public function register(): void
    {
        // Bind interface a implementacao concreta
        $this->app->bind(OrderRepository::class, EloquentOrderRepository::class);

        // Singleton: mesma instancia durante todo o request
        $this->app->singleton(PaymentGateway::class, function ($app) {
            return new StripeGateway(
                apiKey: config('services.stripe.secret'),
                logger: $app->make(LoggerInterface::class),
            );
        });
    }
}

// No controller, Laravel injeta automaticamente:
class OrderController extends Controller
{
    public function __construct(
        private readonly OrderRepository $orders,  // Resolve EloquentOrderRepository
        private readonly PaymentGateway $payments,  // Resolve StripeGateway (singleton)
    ) {}
}
```

### Queues e Jobs

Para processamento assincrono — envio de email, geracao de PDF, integracao com APIs externas:

```php
declare(strict_types=1);

namespace App\Jobs;

use App\Models\Order;
use App\Services\InvoiceGenerator;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;

class GenerateInvoice implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public int $tries = 3;            // Maximo de tentativas
    public int $backoff = 60;          // Segundos entre retries
    public int $timeout = 120;         // Timeout de execucao

    public function __construct(
        public readonly Order $order,
    ) {}

    public function handle(InvoiceGenerator $generator): void
    {
        $pdf = $generator->generate($this->order);

        $this->order->update([
            'invoice_path' => $pdf->store('invoices'),
            'invoice_generated_at' => now(),
        ]);
    }

    // Chamado quando todas as tentativas falham
    public function failed(\Throwable $exception): void
    {
        logger()->error('Falha ao gerar invoice', [
            'order_id' => $this->order->id,
            'error' => $exception->getMessage(),
        ]);
    }
}

// Dispatch do job
GenerateInvoice::dispatch($order);                          // Async (fila)
GenerateInvoice::dispatch($order)->onQueue('invoices');     // Fila especifica
GenerateInvoice::dispatchSync($order);                      // Sincrono (sem fila)
```

```bash
# Processar filas
php artisan queue:work redis --queue=invoices,default --tries=3

# Monitorar filas (Laravel Horizon — dashboard para Redis queues)
php artisan horizon
```

---

## Testing em PHP

### PHPUnit Basico

PHPUnit e o framework de testes padrao do PHP. Toda a infraestrutura de testing do Laravel e construida sobre ele:

```php
declare(strict_types=1);

namespace Tests\Unit;

use App\Domain\Money\Money;
use PHPUnit\Framework\TestCase;

class MoneyTest extends TestCase
{
    public function test_creates_money_with_amount_and_currency(): void
    {
        $money = new Money(100.50, 'BRL');

        $this->assertSame(100.50, $money->amount);
        $this->assertSame('BRL', $money->currency);
    }

    public function test_adds_money_of_same_currency(): void
    {
        $a = new Money(100.00, 'BRL');
        $b = new Money(50.25, 'BRL');

        $result = $a->add($b);

        $this->assertSame(150.25, $result->amount);
        $this->assertSame('BRL', $result->currency);
    }

    public function test_throws_when_adding_different_currencies(): void
    {
        $brl = new Money(100.00, 'BRL');
        $usd = new Money(50.00, 'USD');

        $this->expectException(\InvalidArgumentException::class);
        $this->expectExceptionMessage('Cannot add different currencies');

        $brl->add($usd);
    }

    /**
     * @dataProvider discountProvider
     */
    public function test_applies_discount(float $amount, float $percent, float $expected): void
    {
        $money = new Money($amount, 'BRL');
        $discounted = $money->discount($percent);

        $this->assertSame($expected, $discounted->amount);
    }

    public static function discountProvider(): array
    {
        return [
            'sem desconto' => [100.00, 0, 100.00],
            '10% de desconto' => [100.00, 10, 90.00],
            '100% de desconto' => [100.00, 100, 0.00],
            'desconto com centavos' => [33.33, 15, 28.33],
        ];
    }
}
```

### Feature Tests com Laravel

```php
declare(strict_types=1);

namespace Tests\Feature;

use App\Models\Order;
use App\Models\User;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Tests\TestCase;

class OrderApiTest extends TestCase
{
    use RefreshDatabase;  // Roda migrations e limpa DB entre testes

    public function test_authenticated_user_can_list_own_orders(): void
    {
        // Arrange
        $user = User::factory()->create();
        Order::factory()->count(3)->for($user)->create();
        Order::factory()->count(2)->create(); // Pedidos de outro usuario

        // Act
        $response = $this->actingAs($user)
            ->getJson('/api/orders');

        // Assert
        $response
            ->assertOk()
            ->assertJsonCount(3, 'data')
            ->assertJsonStructure([
                'data' => [
                    '*' => ['id', 'status', 'total', 'created_at'],
                ],
                'meta' => ['current_page', 'total'],
            ]);
    }

    public function test_user_cannot_view_other_users_order(): void
    {
        $user = User::factory()->create();
        $otherOrder = Order::factory()->create();  // Pertence a outro user

        $response = $this->actingAs($user)
            ->getJson("/api/orders/{$otherOrder->id}");

        $response->assertForbidden();
    }

    public function test_store_validates_required_fields(): void
    {
        $user = User::factory()->create();

        $response = $this->actingAs($user)
            ->postJson('/api/orders', []);

        $response
            ->assertUnprocessable()
            ->assertJsonValidationErrors(['items']);
    }

    public function test_store_creates_order_with_items(): void
    {
        $user = User::factory()->create();
        $product = Product::factory()->create(['price' => 49.90]);

        $response = $this->actingAs($user)
            ->postJson('/api/orders', [
                'items' => [
                    ['product_id' => $product->id, 'quantity' => 2],
                ],
            ]);

        $response
            ->assertCreated()
            ->assertJson([
                'data' => [
                    'status' => 'pending',
                    'total' => '99.80',
                ],
            ]);

        $this->assertDatabaseHas('orders', [
            'user_id' => $user->id,
            'total' => 99.80,
        ]);
        $this->assertDatabaseCount('order_items', 1);
    }

    public function test_unauthenticated_request_returns_401(): void
    {
        $this->getJson('/api/orders')
            ->assertUnauthorized();
    }
}
```

### Mocking com Mockery

```php
declare(strict_types=1);

namespace Tests\Unit;

use App\Services\OrderService;
use App\Domain\Order\OrderRepository;
use App\Services\PaymentGateway;
use App\Services\NotificationService;
use Mockery;
use PHPUnit\Framework\TestCase;

class OrderServiceTest extends TestCase
{
    protected function tearDown(): void
    {
        Mockery::close();  // Limpa mocks apos cada teste
    }

    public function test_creates_order_and_processes_payment(): void
    {
        // Arrange: criar mocks
        $orderRepo = Mockery::mock(OrderRepository::class);
        $paymentGateway = Mockery::mock(PaymentGateway::class);
        $notifications = Mockery::mock(NotificationService::class);

        // Configurar expectativas
        $orderRepo->shouldReceive('save')
            ->once()
            ->andReturn(new Order(id: 1, total: 99.90));

        $paymentGateway->shouldReceive('charge')
            ->once()
            ->with(Mockery::on(fn($amount) => $amount === 99.90))
            ->andReturn(new PaymentResult(success: true, transactionId: 'tx_123'));

        $notifications->shouldReceive('send')
            ->once();

        // Act
        $service = new OrderService($orderRepo, $paymentGateway, $notifications);
        $result = $service->create($user, $items);

        // Assert
        $this->assertTrue($result->isPaid());
    }
}
```

### Pest — Alternativa Moderna

Pest e uma camada sobre PHPUnit com sintaxe inspirada em Jest. Mais concisa, mais legivel:

```php
// tests/Feature/OrderTest.php
use App\Models\Order;
use App\Models\User;

beforeEach(function () {
    $this->user = User::factory()->create();
});

it('lists orders for authenticated user', function () {
    Order::factory()->count(3)->for($this->user)->create();

    $this->actingAs($this->user)
        ->getJson('/api/orders')
        ->assertOk()
        ->assertJsonCount(3, 'data');
});

it('returns 401 for unauthenticated request', function () {
    $this->getJson('/api/orders')
        ->assertUnauthorized();
});

it('validates required fields on creation', function () {
    $this->actingAs($this->user)
        ->postJson('/api/orders', [])
        ->assertUnprocessable()
        ->assertJsonValidationErrors(['items']);
});

// Datasets (equivalente a @dataProvider do PHPUnit)
it('rejects invalid order status', function (string $invalidStatus) {
    $order = Order::factory()->for($this->user)->create();

    $this->actingAs($this->user)
        ->patchJson("/api/orders/{$order->id}", ['status' => $invalidStatus])
        ->assertUnprocessable();
})->with(['invalid', '', 'nonexistent', '123']);

// Expectations com API fluente
it('calculates order total correctly', function () {
    $order = createOrderWithItems([
        ['price' => 100, 'quantity' => 2],
        ['price' => 50, 'quantity' => 1],
    ]);

    expect($order->total)
        ->toBe(250.00)
        ->toBeFloat()
        ->toBeGreaterThan(0);

    expect($order->items)
        ->toHaveCount(2)
        ->each->toBeInstanceOf(OrderItem::class);
});
```

```bash
# Rodar Pest
./vendor/bin/pest

# Com cobertura
./vendor/bin/pest --coverage --min=80

# Paralelo (mais rapido)
./vendor/bin/pest --parallel

# Apenas testes que falharam na ultima execucao
./vendor/bin/pest --retry
```

---

## Boas Praticas

### PHP-FPM Tuning

PHP-FPM (FastCGI Process Manager) gerencia os worker processes que servem requests PHP:

```ini
; /etc/php/8.3/fpm/pool.d/www.conf

; Modo de gerenciamento de processos
pm = dynamic
;   static:  numero fixo de workers (previsivel, sem overhead de spawn)
;   dynamic: workers entre min e max (equilibrado)
;   ondemand: cria workers sob demanda (economiza RAM, overhead de spawn)

; Para aplicacoes de producao com trafego previsivel:
pm = static
pm.max_children = 50          ; Regra: RAM_disponivel / RAM_por_worker
                               ; Se cada worker usa ~50MB e voce tem 4GB: 4096/50 ≈ 80
                               ; Deixe margem para OS + DB + Redis

; Para trafego variavel:
pm = dynamic
pm.max_children = 50
pm.start_servers = 10          ; Workers iniciais
pm.min_spare_servers = 5       ; Minimo de workers ociosos
pm.max_spare_servers = 20      ; Maximo de workers ociosos

; Timeout e limites
pm.max_requests = 500          ; Recicla worker apos N requests (previne memory leaks)
request_terminate_timeout = 30 ; Mata requests que demoram mais de 30s
```

### OPcache

OPcache armazena bytecode compilado em memoria compartilhada. Sem OPcache, PHP recompila cada arquivo em cada request:

```ini
; /etc/php/8.3/mods-available/opcache.ini

opcache.enable=1
opcache.memory_consumption=256          ; MB de memoria para bytecode
opcache.interned_strings_buffer=32      ; MB para strings internadas
opcache.max_accelerated_files=20000     ; Numero maximo de arquivos cached
opcache.validate_timestamps=0           ; PRODUCAO: nao checar modificacoes
                                         ; (requer restart do FPM apos deploy)
opcache.revalidate_freq=0
opcache.jit_buffer_size=128M            ; PHP 8.0+: buffer para JIT
opcache.jit=1255                        ; Modo do JIT (tracing JIT)

; DESENVOLVIMENTO: habilitar validacao de timestamps
; opcache.validate_timestamps=1
; opcache.revalidate_freq=2
```

```
Impacto do OPcache em producao:

Sem OPcache:    Request → Parse PHP → Compile → Execute → Response
                ~15ms overhead por request so de compilacao

Com OPcache:    Request → Execute (bytecode em memoria) → Response
                ~0.5ms overhead — 30x mais rapido no bootstrap

Com Preloading (PHP 7.4+):
  Classes e funcoes mais usadas sao carregadas uma vez no start do FPM
  Ficam permanentemente em memoria — zero overhead de autoload para essas classes
```

### Error Handling

```php
declare(strict_types=1);

// Hierarquia de excecoes customizadas
namespace App\Exceptions;

// Base para excecoes de dominio
abstract class DomainException extends \RuntimeException
{
    public function __construct(
        string $message,
        public readonly string $errorCode,
        public readonly array $context = [],
        int $httpStatus = 400,
        ?\Throwable $previous = null,
    ) {
        parent::__construct($message, $httpStatus, $previous);
    }
}

class OrderNotFoundException extends DomainException
{
    public function __construct(string|int $orderId)
    {
        parent::__construct(
            message: "Pedido {$orderId} nao encontrado",
            errorCode: 'ORDER_NOT_FOUND',
            context: ['order_id' => $orderId],
            httpStatus: 404,
        );
    }
}

class InsufficientStockException extends DomainException
{
    public function __construct(string $sku, int $available, int $requested)
    {
        parent::__construct(
            message: "Estoque insuficiente para {$sku}: disponivel {$available}, solicitado {$requested}",
            errorCode: 'INSUFFICIENT_STOCK',
            context: compact('sku', 'available', 'requested'),
            httpStatus: 422,
        );
    }
}

// Handler global no Laravel (app/Exceptions/Handler.php)
// Laravel 11+ usa bootstrap/app.php:
// ->withExceptions(function (Exceptions $exceptions) {
//     $exceptions->render(function (DomainException $e, Request $request) {
//         if ($request->expectsJson()) {
//             return response()->json([
//                 'error' => $e->errorCode,
//                 'message' => $e->getMessage(),
//                 'context' => $e->context,
//             ], $e->getCode());
//         }
//     });
// })
```

### Logging com Monolog

Laravel usa Monolog como backend de logging. Configuracao em `config/logging.php`:

```php
// Logging estruturado — sempre com contexto
use Illuminate\Support\Facades\Log;

// Niveis de log (PSR-3 LoggerInterface)
Log::emergency('Sistema indisponivel', ['service' => 'payment']);
Log::alert('Acao imediata necessaria', ['disk_usage' => '98%']);
Log::critical('Componente critico falhou', ['component' => 'database']);
Log::error('Erro na operacao', ['order_id' => $id, 'exception' => $e->getMessage()]);
Log::warning('Situacao inesperada mas nao critica', ['retry' => 3]);
Log::notice('Evento normal mas significativo', ['user_id' => $userId]);
Log::info('Informacao geral', ['action' => 'order.created', 'total' => 299.90]);
Log::debug('Informacao de debug', ['query' => $sql, 'bindings' => $params]);

// REGRA: sempre inclua contexto estruturado — nunca concatene strings:
// ❌ Log::error("Erro no pedido $orderId: " . $e->getMessage());
// ✅ Log::error('Erro ao processar pedido', ['order_id' => $orderId, 'error' => $e->getMessage()]);

// Channels: enviar logs para destinos diferentes
Log::channel('slack')->critical('Deploy falhou', ['env' => 'production']);
Log::stack(['daily', 'slack'])->error('Pagamento falhou', ['tx_id' => $txId]);
```

### Seguranca

```php
declare(strict_types=1);

// SQL Injection — NUNCA concatene input do usuario em queries
// ❌ VULNERAVEL:
$user = DB::select("SELECT * FROM users WHERE email = '{$request->email}'");

// ✅ SEGURO: prepared statements (Eloquent e Query Builder fazem isso automaticamente)
$user = DB::select('SELECT * FROM users WHERE email = ?', [$request->email]);
$user = User::where('email', $request->email)->first();  // Eloquent: seguro por padrao

// XSS Prevention — Blade escapa output automaticamente
// {{ $userInput }}    — ESCAPADO (seguro)
// {!! $userInput !!}  — RAW (perigoso, evite)

// CSRF — Laravel inclui automaticamente em forms Blade
// <form method="POST">
//     @csrf    <!-- gera <input type="hidden" name="_token" value="..."> -->
//     ...
// </form>
// Para APIs stateless (SPA + token): use Laravel Sanctum, CSRF nao se aplica.

// Mass Assignment Protection
class User extends Model
{
    // Apenas esses campos podem ser atribuidos via create() / update()
    protected $fillable = ['name', 'email', 'password'];

    // OU: todos exceto estes (menos seguro, prefira $fillable)
    // protected $guarded = ['is_admin', 'role'];
}

// Validacao de input — SEMPRE valide no backend, nunca confie no frontend
$validated = $request->validate([
    'name' => ['required', 'string', 'max:255'],
    'email' => ['required', 'email:rfc,dns', 'unique:users'],
    'password' => ['required', 'string', 'min:8', 'confirmed'],
    'age' => ['required', 'integer', 'min:18', 'max:120'],
    'avatar' => ['nullable', 'image', 'max:2048'],  // Max 2MB, deve ser imagem
]);

// Hash de senhas — NUNCA armazene senhas em texto puro
$user->password = Hash::make($request->password);  // bcrypt por padrao

// Rate limiting (app/Providers/RouteServiceProvider.php ou bootstrap/app.php)
RateLimiter::for('api', function (Request $request) {
    return Limit::perMinute(60)->by($request->user()?->id ?: $request->ip());
});

RateLimiter::for('login', function (Request $request) {
    return Limit::perMinute(5)->by($request->ip());
});
```

### Deploy

```bash
# Script de deploy tipico para Laravel
#!/bin/bash
set -e

# 1. Pull do codigo
git pull origin main

# 2. Instalar dependencias (sem dev, otimizado)
composer install --no-dev --optimize-autoloader --no-interaction

# 3. Rodar migrations
php artisan migrate --force

# 4. Limpar e reconstruir caches
php artisan config:cache      # Cache de configuracao (~5x mais rapido)
php artisan route:cache        # Cache de rotas
php artisan view:cache         # Cache de views compiladas
php artisan event:cache        # Cache de event/listener discovery

# 5. Restart PHP-FPM (graceful — termina requests em andamento)
sudo systemctl reload php8.3-fpm

# 6. Restart queue workers (para pegar novo codigo)
php artisan queue:restart
```

```
Checklist de producao:

[x] APP_DEBUG=false (NUNCA true em producao — expoe stack traces)
[x] APP_ENV=production
[x] OPcache habilitado com validate_timestamps=0
[x] Queue workers gerenciados por Supervisor (auto-restart)
[x] Redis para cache e sessions (nao use file em producao)
[x] HTTPS forcado (APP_URL com https://)
[x] Logs enviados para servico centralizado (Datadog, Papertrail, etc.)
[x] Backups de banco automatizados
[x] Rate limiting configurado em rotas publicas
[x] Headers de seguranca (X-Frame-Options, X-Content-Type-Options, CSP)
```

---

## Resumo Operacional

PHP moderno e uma linguagem madura, tipada, performatica e com um ecossistema robusto. Os pilares para trabalhar com PHP profissionalmente:

1. **Sempre `declare(strict_types=1)`** — em cada arquivo, sem excecao
2. **Composer + PSR-4** — autoloading padronizado, sem requires manuais
3. **PSR Standards** — siga PSR-1, PSR-4, PSR-12 no minimo; use ferramentas como Pint ou PHP-CS-Fixer para enforcement automatico
4. **Eloquent com cuidado** — eager loading para evitar N+1, scopes para queries reutilizaveis, casts para type safety
5. **Testes desde o inicio** — PHPUnit ou Pest, feature tests para APIs, unit tests para logica de dominio
6. **OPcache em producao** — sem ele voce esta desperdicando 30x de performance no bootstrap
7. **PHP-FPM tuning** — ajuste workers baseado na memoria disponivel e no perfil de carga
8. **Seguranca por padrao** — prepared statements, escapamento de output, validacao de input, CSRF protection, rate limiting
