---
title: "Error Handling e Observabilidade"
description: "Estratégias de tratamento de erros, logging estruturado, tracing distribuído, métricas e alertas — como construir sistemas que você consegue debugar em produção"
track: "backend"
order: 17
section: "Testes e Qualidade"
priority: "medium"
tags: ["error-handling", "logging", "observabilidade", "tracing", "métricas", "sentry", "pino", "opentelemetry"]
prerequisites: ["rest-apis", "testes"]
keyTakeaways:
  - "Erros operacionais (timeout, 404, validação) devem ser tratados; erros de programação (TypeError, null reference) devem crashar e ser corrigidos"
  - "Logging estruturado (JSON) com níveis (debug/info/warn/error/fatal) e correlation IDs permite busca e filtragem eficiente em produção"
  - "Os três pilares da observabilidade são logs, métricas e traces — juntos fornecem visibilidade completa do sistema"
  - "OpenTelemetry é o padrão aberto para instrumentação: traces, métricas e logs com propagação de contexto entre serviços"
  - "Alertas devem ser baseados em sintomas (latência, error rate, saturação) e não em causas — USE e RED são os frameworks de referência"
---

# Error Handling e Observabilidade

Código que funciona em desenvolvimento e falha em produção sem que você saiba **por quê** é código incompleto. Error handling e observabilidade não são nice-to-have — são requisitos fundamentais de qualquer sistema que roda em produção. Esta lição cobre desde o tratamento correto de erros em código até a instrumentação completa de sistemas distribuídos.

---

## 1. Taxonomia de Erros

### 1.1 Erros Operacionais vs Erros de Programação

A distinção mais importante em error handling (Joyent, Node.js Error Handling):

| Tipo | Exemplos | Como Tratar |
|------|----------|-------------|
| **Operacional** | Timeout de rede, arquivo não encontrado, input inválido, disco cheio | Tratar no código: retry, fallback, mensagem ao usuário |
| **Programação** | TypeError, null dereference, index out of bounds, assertion failure | Crashar, logar, corrigir o bug no código |

```javascript
// Erro operacional — tratar
async function fetchUser(id) {
  try {
    const res = await fetch(`/api/users/${id}`);
    if (!res.ok) {
      // Erro operacional: API retornou erro
      throw new AppError('USER_NOT_FOUND', `Usuário ${id} não encontrado`, 404);
    }
    return await res.json();
  } catch (err) {
    if (err instanceof AppError) throw err;
    // Erro operacional: rede falhou
    throw new AppError('NETWORK_ERROR', 'Falha na comunicação com a API', 503);
  }
}

// Erro de programação — deixar crashar
function processItems(items) {
  // Se items é null aqui, é BUG — não trate com if (!items) return []
  // Deixe o TypeError estourar, seja alertado, corrija a causa raiz
  return items.map(item => transform(item));
}
```

### 1.2 Custom Error Classes

```javascript
class AppError extends Error {
  constructor(code, message, statusCode = 500, metadata = {}) {
    super(message);
    this.name = 'AppError';
    this.code = code;          // Código legível por máquina
    this.statusCode = statusCode;
    this.metadata = metadata;  // Contexto extra para debugging
    this.isOperational = true; // Flag para distinguir de erros de programação
  }
}

class ValidationError extends AppError {
  constructor(fields) {
    super('VALIDATION_ERROR', 'Dados inválidos', 400, { fields });
  }
}

class NotFoundError extends AppError {
  constructor(resource, id) {
    super('NOT_FOUND', `${resource} ${id} não encontrado`, 404, { resource, id });
  }
}
```

### 1.3 Error Handling Centralizado (Express/Fastify)

```javascript
// Middleware centralizado — ÚNICO lugar que formata erros para o cliente
function errorHandler(err, req, res, next) {
  // Log com contexto completo
  const logPayload = {
    error: err.message,
    code: err.code,
    stack: err.stack,
    requestId: req.id,
    method: req.method,
    url: req.url,
    userId: req.user?.id,
  };

  if (err.isOperational) {
    // Erro esperado — log como warning
    logger.warn(logPayload);
    return res.status(err.statusCode).json({
      type: `https://api.example.com/errors/${err.code}`,
      title: err.message,
      status: err.statusCode,
      detail: err.metadata,
    });
  }

  // Erro de programação — log como error, resposta genérica
  logger.error(logPayload);
  res.status(500).json({
    type: 'https://api.example.com/errors/INTERNAL',
    title: 'Erro interno do servidor',
    status: 500,
  });
}
```

---

## 2. Logging Estruturado

### 2.1 Por Que JSON, Não Texto

Logs em texto livre (`console.log("User 123 created")`) são impossíveis de filtrar e agregar em escala. Logs estruturados (JSON) permitem queries:

```javascript
// ❌ Texto livre — impossível de filtrar
console.log(`[INFO] User 123 created order 456 in 230ms`);

// ✅ Estruturado — filtrável, agregável, alertável
logger.info({
  event: 'order_created',
  userId: 123,
  orderId: 456,
  durationMs: 230,
  msg: 'Order created successfully',
});
```

### 2.2 Níveis de Log

| Nível | Quando usar | Exemplo |
|-------|-------------|---------|
| **fatal** | Processo vai morrer | Falha de inicialização, OOM |
| **error** | Erro que precisa de ação | Falha em pagamento, banco inacessível |
| **warn** | Situação anormal mas tratada | Rate limit atingido, retry em API externa |
| **info** | Eventos de negócio significativos | Usuário criado, pedido finalizado |
| **debug** | Detalhes para troubleshooting | Query executada, cache hit/miss |
| **trace** | Detalhes verbosos | Request/response completos, estado interno |

### 2.3 Correlation IDs

Em sistemas distribuídos, um request passa por múltiplos serviços. Sem um ID correlacionado, é impossível rastrear o fluxo:

```javascript
// Middleware que cria ou propaga correlation ID
function correlationId(req, res, next) {
  req.id = req.headers['x-request-id'] || crypto.randomUUID();
  res.setHeader('x-request-id', req.id);

  // Todas as chamadas a outros serviços propagam o ID
  req.logger = logger.child({ requestId: req.id });
  next();
}

// Agora todo log dentro deste request tem o mesmo ID
req.logger.info({ event: 'payment_started', amount: 100 });
// → {"requestId":"abc-123","event":"payment_started","amount":100}
```

### 2.4 Pino: Logger de Alta Performance

```javascript
import pino from 'pino';

const logger = pino({
  level: process.env.LOG_LEVEL || 'info',
  // Redact de dados sensíveis
  redact: ['req.headers.authorization', '*.password', '*.token'],
  // Serializers customizados
  serializers: {
    req: pino.stdSerializers.req,
    err: pino.stdSerializers.err,
  },
});

// Pino é ~5x mais rápido que Winston porque:
// 1. Serializa JSON de forma otimizada (sonic-boom)
// 2. Escreve de forma assíncrona por padrão
// 3. Não processa formatação — isso fica para pino-pretty em dev
```

---

## 3. Os Três Pilares da Observabilidade

### 3.1 Logs — O Quê Aconteceu

Registros discretos de eventos. Úteis para debugging específico, mas difíceis de agregar.

### 3.2 Métricas — Quanto e Quão Rápido

Valores numéricos agregados ao longo do tempo. Quatro tipos fundamentais:

| Tipo | O que mede | Exemplo |
|------|-----------|---------|
| **Counter** | Total acumulado (só sobe) | Total de requests, erros |
| **Gauge** | Valor atual (sobe e desce) | Conexões ativas, uso de memória |
| **Histogram** | Distribuição de valores | Latência de requests (p50, p95, p99) |
| **Summary** | Quantis pré-calculados | Similar ao histogram, calculado no client |

### 3.3 Traces — O Caminho Completo

Um trace representa o caminho completo de um request através do sistema:

```
[API Gateway] → [Auth Service] → [User Service] → [PostgreSQL]
     2ms            5ms              3ms              8ms
                                                Total: 18ms
```

Cada serviço gera um **span** (segmento do trace). Spans são conectados por um **trace ID** compartilhado e relações parent-child.

---

## 4. OpenTelemetry

OpenTelemetry (OTel) é o padrão aberto (CNCF) para instrumentação. Suporta traces, métricas e logs com propagação automática de contexto.

```javascript
// Configuração básica do OpenTelemetry para Node.js
import { NodeSDK } from '@opentelemetry/sdk-node';
import { getNodeAutoInstrumentations } from '@opentelemetry/auto-instrumentations-node';
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';

const sdk = new NodeSDK({
  traceExporter: new OTLPTraceExporter({
    url: 'http://collector:4318/v1/traces',
  }),
  instrumentations: [
    getNodeAutoInstrumentations({
      // Auto-instrumenta HTTP, Express, pg, Redis, etc.
      '@opentelemetry/instrumentation-fs': { enabled: false },
    }),
  ],
});

sdk.start();
// Agora todas as chamadas HTTP, queries SQL e operações Redis
// geram spans automaticamente, com propagação de contexto
```

---

## 5. Frameworks de Métricas: USE e RED

### 5.1 USE Method (Brendan Gregg)

Para cada **recurso** (CPU, memória, disco, rede):
- **U**tilization: % do tempo que o recurso está ocupado
- **S**aturation: trabalho enfileirado que não pode ser processado
- **E**rrors: contagem de eventos de erro

### 5.2 RED Method (Tom Wilkie)

Para cada **serviço**:
- **R**ate: requests por segundo
- **E**rrors: requests com falha por segundo
- **D**uration: distribuição de latência (histograma)

USE é para infraestrutura. RED é para serviços. Juntos cobrem a maioria dos cenários de monitoramento.

---

## 6. Alertas: Sintomas, Não Causas

```yaml
# ❌ Alerta baseado em causa — frágil
- alert: HighCPUUsage
  expr: cpu_usage > 80%
  # CPU alta pode ser normal! Não indica problema para o usuário.

# ✅ Alerta baseado em sintoma — actionable
- alert: HighErrorRate
  expr: rate(http_requests_total{status=~"5.."}[5m]) / rate(http_requests_total[5m]) > 0.01
  for: 5m
  # 1% de erros por 5 minutos = usuários afetados = precisa de ação
```

---

## 7. Referências e Aprofundamento

- **"Observability Engineering"** (Charity Majors, Liz Fong-Jones, George Miranda) — o livro definitivo sobre observabilidade moderna
- **"Site Reliability Engineering"** (Google) — capítulos sobre monitoramento e alertas, disponível gratuitamente online
- **Joyent Guide to Error Handling in Node.js** — taxonomia de erros operacionais vs programação
- **OpenTelemetry Documentation** — especificação e SDKs para todas as linguagens
- **Brendan Gregg's USE Method** — framework para análise de performance de sistemas
