---
title: "Lógica de Programação"
description: "Pensamento algorítmico, decomposição de problemas, fluxo de controle, invariantes, pré/pós-condições e as técnicas de raciocínio formal que separam quem programa de quem resolve problemas"
track: "cs"
order: 4
section: "Fundamentos da Computação"
priority: "high"
tags: ["lógica", "algoritmos", "pseudocódigo", "invariantes", "decomposição", "fluxo-de-controle"]
prerequisites: ["logica-e-matematica"]
keyTakeaways:
  - "Programar é decompor problemas em subproblemas menores e combinar soluções — o código é consequência do raciocínio, não o objetivo"
  - "Invariantes de loop são a ferramenta formal para provar que um algoritmo está correto — todo loop tem uma invariante, mesmo que implícita"
  - "Pré-condições, pós-condições e contratos formam a base de Design by Contract — código defensivo sem fundamento formal é apenas superstição"
  - "Abstração é escolher o que ignorar: funções abstraem computação, tipos abstraem dados, módulos abstraem dependências"
  - "Debugging eficiente é raciocínio dedutivo: formular hipóteses, testar sistematicamente, eliminar causas — não é tentativa e erro"
---

# Lógica de Programação

> **Lógica de programação não é sintaxe.** Sintaxe é a gramática de uma linguagem. Lógica de programação é a capacidade de **decompor um problema em passos computáveis, raciocinar sobre a corretude desses passos e combiná-los em uma solução**. Você pode dominar a sintaxe de C, Python e Rust e ainda assim não conseguir resolver um problema novo — porque resolver problemas exige raciocínio estruturado, não memorização de keywords. Esta lição trata do raciocínio, não da linguagem.

---

## Pensamento Algorítmico

Pensar como programador não é pensar em código. É pensar em **transformações**: dado um estado inicial (input), qual sequência de operações produz o estado final desejado (output)? Esse processo envolve quatro habilidades fundamentais.

### Decomposição

Decompor é quebrar um problema complexo em subproblemas menores e independentes que você sabe resolver. Nenhum programador experiente olha um problema grande e escreve a solução de uma vez. O processo é sempre top-down: o que preciso fazer no nível mais alto? Que partes compõem esse todo?

Exemplo concreto: "Verificar se um CPF é válido."

Um iniciante tenta escrever tudo em um bloco. Um programador experiente decompõe:

1. Remover caracteres não numéricos (pontos, traços)
2. Verificar se tem exatamente 11 dígitos
3. Rejeitar sequências de dígitos iguais (111.111.111-11)
4. Calcular o primeiro dígito verificador
5. Calcular o segundo dígito verificador
6. Comparar dígitos calculados com os informados

Cada passo é um subproblema trivial. O problema "complexo" é apenas a **composição** de subproblemas simples. Essa é a essência da decomposição.

### Reconhecimento de padrões

Problemas novos raramente são completamente novos. Na maioria das vezes, eles são variações de problemas que você já resolveu. Reconhecer padrões é a habilidade de identificar a **estrutura subjacente** de um problema:

- "Preciso encontrar um elemento em uma coleção ordenada" → busca binária
- "Preciso processar cada elemento e acumular um resultado" → redução/fold
- "Preciso testar todas as combinações possíveis" → backtracking
- "Preciso tomar uma decisão ótima em cada passo" → algoritmo guloso (talvez)

Essa habilidade se desenvolve resolvendo problemas, não lendo sobre eles. Cada problema resolvido adiciona um padrão ao seu repertório mental.

### Abstração

Abstração é a arte de **escolher o que ignorar**. Quando você descreve como ir do ponto A ao ponto B para alguém, você não explica a biomecânica de cada passo — você abstrai isso em "caminhe até a esquina". Programação é a mesma coisa em múltiplos níveis:

- Uma **variável** abstrai um endereço de memória
- Uma **função** abstrai uma sequência de operações
- Um **tipo** abstrai a representação de dados
- Um **módulo** abstrai dependências internas
- Uma **API** abstrai toda a implementação de um sistema

O nível correto de abstração depende do contexto. Abstrair demais esconde detalhes que importam; abstrair de menos sobrecarrega o raciocínio com detalhes irrelevantes. Saber calibrar é uma habilidade que vem com experiência.

### Design de algoritmos

Um algoritmo é uma sequência **finita**, **precisa** e **efetiva** de instruções que transforma um input em um output. "Finita" significa que termina. "Precisa" significa que cada passo é inequívoco. "Efetiva" significa que cada passo pode ser executado em tempo finito.

A diferença entre "saber sintaxe" e "resolver problemas" é exatamente esta: sintaxe é a ferramenta, algoritmo é a solução. Você pode conhecer todas as estruturas de uma linguagem e ainda não saber **qual sequência de passos** resolve o problema. O gap entre conhecer a linguagem e resolver problemas é preenchido pelo pensamento algorítmico.

---

## Representação e Pseudocódigo

Antes de escrever código, você precisa de uma forma de **expressar o algoritmo** sem se prender a detalhes de sintaxe. Duas ferramentas clássicas: fluxogramas e pseudocódigo.

### Fluxogramas

Fluxogramas representam o fluxo de execução visualmente. São úteis para comunicar algoritmos com não-programadores e para visualizar fluxos de controle complexos. As formas padrão:

```
┌─────────────┐
│   Início    │   ← Terminador (oval/retângulo arredondado)
└──────┬──────┘
       ▼
┌─────────────┐
│  Processar  │   ← Processo (retângulo)
│   dados     │
└──────┬──────┘
       ▼
      ╱ ╲
    ╱     ╲
   ╱ cond? ╲      ← Decisão (losango)
   ╲       ╱
    ╲     ╱
      ╲ ╱
    S/ ╱╲ N/
      ╱  ╲
     ▼    ▼
   ...   ...
```

Fluxogramas escalam mal para problemas grandes — o diagrama vira um emaranhado de setas. Na prática, pseudocódigo é mais usado por programadores.

### Pseudocódigo estruturado

Pseudocódigo é uma linguagem semiformal que descreve algoritmos sem se prender à sintaxe de uma linguagem específica. Não existe um padrão universal, mas as convenções são simples: use indentação para blocos, palavras em português ou inglês para estruturas de controle, e notação matemática quando conveniente.

Exemplo não trivial — verificar se um número é primo por tentativa de divisão:

```
ALGORITMO é_primo(n)
    SE n < 2
        RETORNE falso

    SE n < 4
        RETORNE verdadeiro

    SE n mod 2 = 0 OU n mod 3 = 0
        RETORNE falso

    divisor ← 5
    ENQUANTO divisor * divisor ≤ n FAÇA
        SE n mod divisor = 0 OU n mod (divisor + 2) = 0
            RETORNE falso
        divisor ← divisor + 6
    FIM ENQUANTO

    RETORNE verdadeiro
FIM ALGORITMO
```

Por que esse algoritmo verifica apenas até a raiz quadrada? Porque se `n = a × b` e ambos `a` e `b` fossem maiores que `√n`, teríamos `a × b > n` — contradição. Portanto, pelo menos um fator é `≤ √n`.

Por que pula de 6 em 6? Todo primo maior que 3 tem a forma `6k ± 1`. Números da forma `6k`, `6k+2`, `6k+3`, `6k+4` são divisíveis por 2 ou 3. Essa otimização reduz o número de divisões por um fator de 3.

Note como o pseudocódigo captura a **lógica** sem se perder em detalhes de implementação (incluir headers, declarar tipos, compilar). A tradução para qualquer linguagem se torna mecânica.

### Do pseudocódigo ao código

A mesma lógica em C:

```c
#include <stdbool.h>

bool eh_primo(int n) {
    if (n < 2)  return false;
    if (n < 4)  return true;
    if (n % 2 == 0 || n % 3 == 0) return false;

    for (int d = 5; d * d <= n; d += 6) {
        if (n % d == 0 || n % (d + 2) == 0)
            return false;
    }
    return true;
}
```

O pseudocódigo e o código são quase idênticos. Essa é a ideia: quando o raciocínio está claro, o código se escreve sozinho.

---

## Variáveis, Estado e Memória

### O que é uma variável

Uma variável é um **mapeamento nome → endereço de memória → valor**. Em C, quando você declara `int x = 42;`, o compilador reserva 4 bytes na stack, associa o nome `x` a esse endereço e armazena o valor 42 (como `2A 00 00 00` em little-endian).

```
Nome      Endereço      Conteúdo (hex)    Valor
x         0x7ffd0010    2A 00 00 00       42
y         0x7ffd0014    00 00 00 00       0
ptr       0x7ffd0018    10 00 fd 7f ...   0x7ffd0010 (endereço de x)
```

Em linguagens de alto nível, essa camada de endereços é abstraída. Em C, você lida com ela diretamente via ponteiros. Mas o conceito é universal: uma variável é um nome que referencia um valor armazenado em algum lugar da memória.

### Estado do programa

O **estado** de um programa em um dado momento é o conjunto de todas as variáveis e seus valores naquele instante. A execução de um programa é uma **sequência de transições de estado**: cada instrução transforma o estado atual em um novo estado.

```c
int a = 5;       // Estado: {a=5}
int b = 3;       // Estado: {a=5, b=3}
a = a + b;       // Estado: {a=8, b=3}
b = a - b;       // Estado: {a=8, b=5}
a = a - b;       // Estado: {a=3, b=5}
```

O trecho acima troca os valores de `a` e `b` sem variável temporária. Mas para entender **por que** funciona, você precisa rastrear o estado a cada passo. Esse rastreamento é chamado de **trace table** (tabela de rastreamento).

### Tabelas de rastreamento

Uma tabela de rastreamento registra o valor de cada variável após cada instrução. É a ferramenta mais fundamental para entender o comportamento de um programa:

```c
// Algoritmo: Máximo Divisor Comum (Euclides)
int mdc(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}
```

Trace table para `mdc(48, 18)`:

```
Passo   a     b     temp    a % b    Condição (b != 0)
─────   ──    ──    ────    ─────    ─────────────────
init    48    18    —       —        true
1       18    12    18      12       true
2       12     6    12       6       true
3        6     0     6       0       false → sai do loop
─────
return: 6
```

Resultado: `mdc(48, 18) = 6`. Correto.

A trace table é o equivalente a um debugger manual. Todo programador experiente consegue executar mentalmente trechos curtos de código — essa habilidade vem de praticar trace tables até o processo se tornar automático.

---

## Estruturas de Controle

Todo programa, por mais complexo, é construído com apenas três estruturas de controle fundamentais (teorema de Bohm-Jacopini, 1966): **sequência**, **seleção** e **repetição**.

### Sequência

Instruções executadas na ordem em que aparecem. Parece trivial, mas a sequência importa:

```c
// Ordem IMPORTA — estas duas versões produzem resultados diferentes:
// Versão 1:
x = x + 1;
y = x * 2;

// Versão 2:
y = x * 2;
x = x + 1;
```

Se `x = 5`: versão 1 produz `{x=6, y=12}`, versão 2 produz `{x=6, y=10}`. A sequência define as dependências entre instruções.

### Seleção (if/else, switch)

Desvio condicional baseado em uma expressão booleana:

```c
#include <stdio.h>

// Classificação de triângulos — exemplo de seleção aninhada
void classificar_triangulo(double a, double b, double c) {
    // Pré-condição: a, b, c > 0
    if (a + b <= c || a + c <= b || b + c <= a) {
        printf("Não forma triângulo\n");
        return;
    }

    // Classificação por lados
    if (a == b && b == c) {
        printf("Equilátero\n");
    } else if (a == b || b == c || a == c) {
        printf("Isósceles\n");
    } else {
        printf("Escaleno\n");
    }
}
```

### Repetição (while, for, do-while)

Execução repetida enquanto uma condição é verdadeira:

```c
// while — testa ANTES de executar (pode executar 0 vezes)
int i = 0;
while (i < n) {
    processar(i);
    i++;
}

// for — sintaxe compacta para o padrão init/test/update
for (int i = 0; i < n; i++) {
    processar(i);
}

// do-while — testa DEPOIS de executar (executa pelo menos 1 vez)
// Útil quando a primeira execução é necessária antes do teste
int tentativas;
do {
    tentativas = obter_input();
} while (tentativas < 0);
```

A diferença entre `while` e `do-while` não é trivial. Usar `while` quando deveria usar `do-while` (ou vice-versa) é uma fonte comum de bugs off-by-one.

### Aninhamento profundo: o code smell que todo sênior reconhece

Considere este código:

```c
void processar_pedido(Pedido *p) {
    if (p != NULL) {
        if (p->status == ATIVO) {
            if (p->itens_count > 0) {
                if (validar_estoque(p)) {
                    if (cobrar_pagamento(p)) {
                        enviar_pedido(p);
                    } else {
                        log_erro("Pagamento falhou");
                    }
                } else {
                    log_erro("Sem estoque");
                }
            } else {
                log_erro("Pedido vazio");
            }
        } else {
            log_erro("Pedido inativo");
        }
    }
}
```

Sete níveis de indentação. O fluxo principal está enterrado no meio de condições de erro. Complexidade ciclomática alta (muitos caminhos de execução). Difícil de ler, difícil de manter, fácil de introduzir bugs.

### Guard clauses e early returns

O padrão sênior para o mesmo problema:

```c
void processar_pedido(Pedido *p) {
    if (p == NULL) return;
    if (p->status != ATIVO) {
        log_erro("Pedido inativo");
        return;
    }
    if (p->itens_count == 0) {
        log_erro("Pedido vazio");
        return;
    }
    if (!validar_estoque(p)) {
        log_erro("Sem estoque");
        return;
    }
    if (!cobrar_pagamento(p)) {
        log_erro("Pagamento falhou");
        return;
    }
    enviar_pedido(p);
}
```

Mesmo comportamento, zero aninhamento além do primeiro nível. O fluxo principal é lido de cima para baixo sem desvios mentais. Cada guard clause elimina um caso inválido e sai cedo.

Essa técnica é tão importante que é praticamente um indicador de experiência: código com 4+ níveis de indentação quase sempre pode ser reescrito com guard clauses. A ideia central é **lidar com os casos excepcionais primeiro e deixar o caminho feliz como fluxo linear**.

### Complexidade ciclomática

A complexidade ciclomática de uma função é o número de caminhos de execução independentes — informalmente, é o número de decisões (if, while, for, case) + 1. Funções com complexidade ciclomática alta são difíceis de testar (cada caminho precisa de pelo menos um teste) e propensas a bugs.

Regra prática:

- **1-4**: função simples, fácil de entender
- **5-10**: moderada, considere decompor
- **11+**: complexa demais, refatore obrigatoriamente

Guard clauses não reduzem a complexidade ciclomática (o número de caminhos é o mesmo), mas reduzem a **complexidade cognitiva** — que é o que importa para humanos lendo código.

---

## Funções e Decomposição

### Funções como unidades de abstração

Uma função encapsula uma sequência de operações sob um nome. Isso permite:

1. **Reutilização** — escreva uma vez, use N vezes
2. **Abstração** — o chamador não precisa saber como funciona, apenas o que faz
3. **Testabilidade** — funções pequenas são testáveis isoladamente
4. **Legibilidade** — nomes de funções documentam a intenção

### Decomposição top-down

Decomposição top-down é o processo de dividir um problema em subproblemas, dividir cada subproblema em sub-subproblemas, e assim por diante, até chegar a problemas triviais.

Exemplo: escrever um programa que lê um arquivo CSV de notas, calcula a média de cada aluno e gera um relatório.

Nível 0 (problema):
```
gerar_relatorio_notas(arquivo_entrada, arquivo_saida)
```

Nível 1 (decomposição):
```
1. ler_csv(arquivo_entrada) → lista de registros
2. calcular_medias(registros) → lista de resultados
3. gerar_saida(resultados, arquivo_saida)
```

Nível 2 (decomposição de cada parte):
```
ler_csv:
    1.1 abrir_arquivo(caminho)
    1.2 para cada linha: parsear_linha(linha) → registro
    1.3 fechar_arquivo()

calcular_medias:
    2.1 para cada registro: media(registro.notas)

gerar_saida:
    3.1 formatar_cabecalho()
    3.2 para cada resultado: formatar_linha(resultado)
    3.3 escrever_arquivo(conteudo, caminho)
```

Em C, isso se traduz em funções pequenas e compostas:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_ALUNOS    100
#define MAX_NOTAS      10
#define MAX_NOME       64
#define MAX_LINHA     256

typedef struct {
    char nome[MAX_NOME];
    double notas[MAX_NOTAS];
    int num_notas;
} Registro;

typedef struct {
    char nome[MAX_NOME];
    double media;
} Resultado;

// --- Nível mais baixo: operações atômicas ---

double calcular_media(const double *notas, int n) {
    if (n <= 0) return 0.0;
    double soma = 0.0;
    for (int i = 0; i < n; i++) {
        soma += notas[i];
    }
    return soma / n;
}

int parsear_linha(const char *linha, Registro *reg) {
    // Formato esperado: "Nome;nota1;nota2;...;notaN"
    char copia[MAX_LINHA];
    strncpy(copia, linha, MAX_LINHA - 1);
    copia[MAX_LINHA - 1] = '\0';

    char *token = strtok(copia, ";");
    if (!token) return 0;
    strncpy(reg->nome, token, MAX_NOME - 1);
    reg->nome[MAX_NOME - 1] = '\0';

    reg->num_notas = 0;
    while ((token = strtok(NULL, ";")) != NULL && reg->num_notas < MAX_NOTAS) {
        reg->notas[reg->num_notas++] = atof(token);
    }
    return 1;
}

// --- Nível intermediário: composição ---

int ler_csv(const char *caminho, Registro *regs, int max) {
    FILE *f = fopen(caminho, "r");
    if (!f) return -1;

    char linha[MAX_LINHA];
    int count = 0;

    // Pula cabeçalho
    if (!fgets(linha, MAX_LINHA, f)) { fclose(f); return 0; }

    while (fgets(linha, MAX_LINHA, f) && count < max) {
        linha[strcspn(linha, "\n")] = '\0';  // Remove newline
        if (parsear_linha(linha, &regs[count])) {
            count++;
        }
    }

    fclose(f);
    return count;
}

void calcular_resultados(const Registro *regs, int n, Resultado *res) {
    for (int i = 0; i < n; i++) {
        strncpy(res[i].nome, regs[i].nome, MAX_NOME);
        res[i].media = calcular_media(regs[i].notas, regs[i].num_notas);
    }
}

int gerar_relatorio(const char *caminho, const Resultado *res, int n) {
    FILE *f = fopen(caminho, "w");
    if (!f) return -1;

    fprintf(f, "%-30s %s\n", "Aluno", "Média");
    fprintf(f, "%-30s %s\n", "-----", "-----");
    for (int i = 0; i < n; i++) {
        fprintf(f, "%-30s %.2f\n", res[i].nome, res[i].media);
    }

    fclose(f);
    return 0;
}

// --- Nível mais alto: orquestração ---

int main(int argc, char *argv[]) {
    if (argc != 3) {
        fprintf(stderr, "Uso: %s <entrada.csv> <saida.txt>\n", argv[0]);
        return 1;
    }

    Registro registros[MAX_ALUNOS];
    int n = ler_csv(argv[1], registros, MAX_ALUNOS);
    if (n < 0) {
        perror("Erro ao ler CSV");
        return 1;
    }

    Resultado resultados[MAX_ALUNOS];
    calcular_resultados(registros, n, resultados);

    if (gerar_relatorio(argv[2], resultados, n) < 0) {
        perror("Erro ao gerar relatório");
        return 1;
    }

    printf("Relatório gerado: %d alunos processados.\n", n);
    return 0;
}
```

Observe a estrutura: `main` lê como prosa — "leia o CSV, calcule os resultados, gere o relatório". Os detalhes estão encapsulados nas funções de nível inferior. Cada função tem uma responsabilidade clara e pode ser testada isoladamente.

### Contratos de função: pré-condições e pós-condições

Toda função tem um **contrato implícito**: o que ela espera do chamador (pré-condições) e o que ela garante em troca (pós-condições).

```c
/*
 * Busca binária em array ordenado.
 *
 * PRÉ-CONDIÇÕES:
 *   - arr != NULL
 *   - n > 0
 *   - arr está ordenado em ordem crescente (arr[i] <= arr[i+1] para todo i)
 *
 * PÓS-CONDIÇÕES:
 *   - Se target existe em arr: retorna índice i tal que arr[i] == target
 *   - Se target não existe: retorna -1
 *   - arr não é modificado
 */
int busca_binaria(const int *arr, int n, int target) {
    int lo = 0;
    int hi = n - 1;

    while (lo <= hi) {
        int mid = lo + (hi - lo) / 2;  // Evita overflow de (lo + hi) / 2
        if (arr[mid] == target) return mid;
        if (arr[mid] < target) lo = mid + 1;
        else hi = mid - 1;
    }
    return -1;
}
```

Se o chamador violar a pré-condição (passar um array desordenado), a função não garante nada — o comportamento é indefinido. Isso não é um bug da função, é um bug do chamador. O contrato define a fronteira de responsabilidade.

### Efeitos colaterais e funções puras

Uma **função pura** depende apenas de seus parâmetros e produz apenas seu valor de retorno — sem efeitos colaterais:

```c
// PURA: mesmo input → mesmo output, sempre. Sem efeitos colaterais.
int soma(int a, int b) {
    return a + b;
}

// IMPURA: modifica estado externo (stdout é estado global)
void imprimir_soma(int a, int b) {
    printf("%d\n", a + b);
}

// IMPURA: depende de estado externo (variável global)
int contador = 0;
int proximo_id(void) {
    return ++contador;  // Retorna valor diferente a cada chamada
}
```

Funções puras são mais fáceis de testar, raciocinar e paralelizar. Nem toda função pode ser pura (I/O é inerentemente impuro), mas maximizar a proporção de funções puras em um programa é uma prática sólida de engenharia.

---

## Invariantes e Corretude

Esta seção é onde a lógica de programação se conecta com a engenharia de software rigorosa. Invariantes são a ponte entre "o código parece funcionar" e "o código está correto por construção".

### O que é uma invariante de loop

Uma **invariante de loop** é uma propriedade que é verdadeira:

1. **Antes** da primeira iteração (inicialização)
2. **Após** cada iteração (manutenção)
3. **Quando o loop termina** — a invariante combinada com a condição de saída implica a pós-condição desejada (terminação)

Se você provar essas três propriedades, o loop está correto. Isso não é teoria abstrata — é a forma como algoritmos em livros como o CLRS (Cormen et al.) são demonstrados corretos.

### Invariante da busca binária

```c
/*
 * INVARIANTE: se target está em arr, então arr[lo..hi] contém target.
 * Equivalente: target não está em arr[0..lo-1] nem em arr[hi+1..n-1].
 */
int busca_binaria(const int *arr, int n, int target) {
    int lo = 0;
    int hi = n - 1;

    // INICIALIZAÇÃO: lo=0, hi=n-1 → arr[lo..hi] = arr inteiro.
    // Se target está em arr, está em arr[0..n-1]. Invariante vale.

    while (lo <= hi) {
        int mid = lo + (hi - lo) / 2;

        if (arr[mid] == target) {
            return mid;  // Encontrou — pós-condição satisfeita
        }

        if (arr[mid] < target) {
            // arr[mid] < target E arr é ordenado →
            // target não está em arr[lo..mid] →
            // MANUTENÇÃO: arr[mid+1..hi] contém target (se existir)
            lo = mid + 1;
        } else {
            // arr[mid] > target E arr é ordenado →
            // target não está em arr[mid..hi] →
            // MANUTENÇÃO: arr[lo..mid-1] contém target (se existir)
            hi = mid - 1;
        }
    }

    // TERMINAÇÃO: lo > hi → arr[lo..hi] é vazio →
    // target não está em nenhum subarray → target não está em arr.
    return -1;
}
```

A invariante garante que nunca "pulamos" o target. A cada iteração, o intervalo `[lo, hi]` diminui em pelo menos 1 (porque `mid` é excluído). Como o intervalo é finito e diminui a cada passo, o loop termina. Quando termina com `lo > hi`, o intervalo está vazio, provando que target não existe no array.

### Invariante do Insertion Sort

```c
/*
 * INVARIANTE: ao início de cada iteração do loop externo (índice i),
 * o subarray arr[0..i-1] contém os mesmos elementos que estavam
 * originalmente em arr[0..i-1], mas em ordem crescente.
 */
void insertion_sort(int *arr, int n) {
    // INICIALIZAÇÃO: i=1 → arr[0..0] tem um único elemento,
    // que está trivialmente ordenado. Invariante vale.

    for (int i = 1; i < n; i++) {
        int chave = arr[i];
        int j = i - 1;

        // Loop interno: desloca elementos maiores que chave
        // para abrir espaço na posição correta.
        // INVARIANTE INTERNA: arr[j+2..i] contém elementos
        // maiores que chave, em ordem crescente.
        while (j >= 0 && arr[j] > chave) {
            arr[j + 1] = arr[j];
            j--;
        }

        arr[j + 1] = chave;

        // MANUTENÇÃO: após inserir chave na posição j+1,
        // arr[0..i] está ordenado. A invariante do loop externo
        // vale para i+1.
    }

    // TERMINAÇÃO: i == n → arr[0..n-1] está ordenado.
    // Invariante + condição de saída → array inteiro ordenado.
}
```

### Design by Contract (Bertrand Meyer)

Bertrand Meyer formalizou o conceito de contratos em seu livro "Object-Oriented Software Construction" (1988) e na linguagem Eiffel. A ideia central:

- **Pré-condição**: o que deve ser verdade ANTES da execução da função. Responsabilidade do **chamador**.
- **Pós-condição**: o que deve ser verdade DEPOIS da execução. Responsabilidade da **função**.
- **Invariante de classe/módulo**: o que deve ser verdade sempre que o módulo está em um estado "observável" (entre chamadas de função).

Em C, contratos são documentados em comentários e verificados com `assert`:

```c
#include <assert.h>
#include <stdlib.h>

typedef struct {
    int *dados;
    int tamanho;
    int capacidade;
} VetorDinamico;

// INVARIANTE DO MÓDULO:
// - dados != NULL (quando capacidade > 0)
// - 0 <= tamanho <= capacidade
// - dados aponta para bloco de capacidade * sizeof(int) bytes

void vetor_inserir(VetorDinamico *v, int valor) {
    // PRÉ-CONDIÇÃO
    assert(v != NULL);
    assert(v->tamanho >= 0 && v->tamanho <= v->capacidade);

    if (v->tamanho == v->capacidade) {
        int nova_cap = v->capacidade == 0 ? 4 : v->capacidade * 2;
        int *novo = realloc(v->dados, nova_cap * sizeof(int));
        assert(novo != NULL);  // Em produção, trate o erro propriamente
        v->dados = novo;
        v->capacidade = nova_cap;
    }

    v->dados[v->tamanho] = valor;
    v->tamanho++;

    // PÓS-CONDIÇÃO
    assert(v->tamanho <= v->capacidade);
    assert(v->dados[v->tamanho - 1] == valor);
}

int vetor_obter(const VetorDinamico *v, int indice) {
    // PRÉ-CONDIÇÃO
    assert(v != NULL);
    assert(indice >= 0 && indice < v->tamanho);

    return v->dados[indice];

    // PÓS-CONDIÇÃO: retorna o valor armazenado na posição indice
    // (implícita — o retorno é o próprio valor)
}
```

A distinção entre "código defensivo com if" e "contrato com assert" é fundamental:

- **`assert`** documenta uma condição que **nunca deveria ser falsa** — se for, é um bug no programa (não um input inválido do usuário). Asserts podem ser desabilitados em produção com `-DNDEBUG`.
- **`if` com tratamento de erro** lida com condições que **podem legitimamente acontecer** — arquivo não encontrado, rede fora do ar, input malformado.

Código defensivo que trata tudo com `if` sem fundamento formal é superstição: você não sabe o que está protegendo nem por quê. Contratos formais tornam as responsabilidades explícitas.

---

## Raciocínio sobre Complexidade

Esta seção não trata de notação Big O formal (que é tema de uma lição dedicada). Trata do **raciocínio intuitivo** sobre quanto trabalho um algoritmo faz — a habilidade de olhar um trecho de código e estimar seu custo sem precisar formalizar.

### Um loop: trabalho proporcional a N

```c
// Soma dos elementos de um array
int soma(const int *arr, int n) {
    int s = 0;
    for (int i = 0; i < n; i++) {  // Executa n vezes
        s += arr[i];                // Cada iteração: tempo constante
    }
    return s;
}
// Trabalho total: proporcional a n
// Se n dobra, o tempo dobra
```

### Loops aninhados: trabalho proporcional a N x M

```c
// Verificar se dois arrays têm elementos em comum
int tem_comum(const int *a, int na, const int *b, int nb) {
    for (int i = 0; i < na; i++) {        // Executa na vezes
        for (int j = 0; j < nb; j++) {    // Cada iteração: nb vezes
            if (a[i] == b[j]) return 1;
        }
    }
    return 0;
}
// Pior caso: na × nb comparações
// Se ambos têm tamanho n: proporcional a n²
// Se n = 1000, ~1.000.000 comparações — ok
// Se n = 1.000.000, ~10^12 comparações — inviável
```

### Loop que reduz o problema pela metade: proporcional a log N

```c
// Busca binária: a cada iteração, o espaço de busca é dividido por 2
int busca_binaria(const int *arr, int n, int target) {
    int lo = 0, hi = n - 1;
    while (lo <= hi) {       // Quantas vezes executa?
        int mid = (lo + hi) / 2;
        if (arr[mid] == target) return mid;
        if (arr[mid] < target) lo = mid + 1;
        else hi = mid - 1;
    }
    return -1;
}
// Intervalo começa com tamanho n
// Após 1 iteração: n/2
// Após 2 iterações: n/4
// Após k iterações: n/2^k
// Termina quando n/2^k ≤ 1 → k ≥ log₂(n)
// Se n = 1.000.000.000, ~30 iterações. Isso é o poder do logaritmo.
```

### Quando brute force é aceitável

Nem todo problema exige o algoritmo mais eficiente. Se o input é pequeno e a operação é rara, brute force é perfeitamente aceitável:

```c
// Ordenar 5 elementos? Bubble sort está ótimo.
// Não precisa de merge sort para n=5.
void ordenar_5(int arr[5]) {
    for (int i = 0; i < 5; i++) {
        for (int j = i + 1; j < 5; j++) {
            if (arr[j] < arr[i]) {
                int tmp = arr[i];
                arr[i] = arr[j];
                arr[j] = tmp;
            }
        }
    }
}
// 5 × 4 / 2 = 10 comparações no máximo. Irrelevante.
```

A regra é: **otimize quando o custo importa, não por princípio**. Se `n` é sempre menor que 20, o algoritmo quadrático é mais simples, mais legível e roda em tempo desprezível. Otimização prematura — trocar clareza por performance sem evidência de que performance é um problema — é um dos erros mais comuns de engenheiros intermediários.

O raciocínio intuitivo que importa é:

- **Loop simples sobre N** → cresce linearmente
- **Loops aninhados N×M** → cresce como um produto, atenção se N e M forem grandes
- **Dividir o problema pela metade a cada passo** → cresce muito devagar (logarítmico)
- **Testar todas as combinações** → cresce exponencialmente, raramente viável para N grande

Se você consegue classificar um trecho de código nessas categorias mentalmente, já sabe o suficiente para tomar decisões informadas sobre quando otimizar.

---

## Debugging como Raciocínio Dedutivo

Debugging não é tentativa e erro. Não é mudar coisas aleatoriamente até funcionar. Debugging eficiente é a aplicação do **método científico**: observar o comportamento, formular hipóteses, testar sistematicamente, eliminar causas.

### O método científico aplicado a bugs

```
1. OBSERVAR: O que exatamente acontece? Qual é o output esperado vs. obtido?
2. FORMULAR HIPÓTESE: Qual poderia ser a causa? Onde no código essa divergência pode surgir?
3. TESTAR: Projetar um experimento que confirme ou refute a hipótese
4. CONCLUIR: A hipótese foi confirmada? Se não, formular nova hipótese
5. CORRIGIR: Aplicar a correção e verificar que o bug original foi resolvido
                sem introduzir novos bugs (testes de regressão)
```

### Debugging por bisseção (binary search no espaço do problema)

Quando o bug está em algum lugar entre o input e o output errado, divida o programa ao meio:

```c
#include <stdio.h>

// Bug: esta função deveria retornar o índice do segundo maior
// elemento, mas retorna um resultado errado para certos inputs.
int segundo_maior(const int *arr, int n) {
    int max_idx = 0;
    int seg_idx = -1;  // -1 indica "não encontrado ainda"

    for (int i = 1; i < n; i++) {
        if (arr[i] > arr[max_idx]) {
            seg_idx = max_idx;
            max_idx = i;
        } else if (seg_idx == -1 || arr[i] > arr[seg_idx]) {
            seg_idx = i;
        }
    }
    return seg_idx;
}

// DEBUGGING POR BISSEÇÃO:
// Input: {5, 5, 3, 1}
// Output esperado: 1 (arr[1] = 5, segundo maior)
// Output obtido: ?
//
// Passo 1: Imprimir estado no MEIO do loop
int segundo_maior_debug(const int *arr, int n) {
    int max_idx = 0;
    int seg_idx = -1;

    for (int i = 1; i < n; i++) {
        printf("[DEBUG] i=%d, arr[i]=%d, max_idx=%d, seg_idx=%d\n",
               i, arr[i], max_idx, seg_idx);

        if (arr[i] > arr[max_idx]) {
            seg_idx = max_idx;
            max_idx = i;
        } else if (seg_idx == -1 || arr[i] > arr[seg_idx]) {
            seg_idx = i;
        }

        printf("[DEBUG] após: max_idx=%d, seg_idx=%d\n", max_idx, seg_idx);
    }
    return seg_idx;
}
```

Trace com `{5, 5, 3, 1}`:

```
i=1, arr[1]=5, max_idx=0, seg_idx=-1
  arr[1] (5) > arr[0] (5)? NÃO (5 não é > 5)
  seg_idx == -1? SIM → seg_idx = 1
  após: max_idx=0, seg_idx=1 ✓

i=2, arr[2]=3, max_idx=0, seg_idx=1
  arr[2] (3) > arr[0] (5)? NÃO
  arr[2] (3) > arr[1] (5)? NÃO
  após: max_idx=0, seg_idx=1 ✓

i=3, arr[3]=1, max_idx=0, seg_idx=1
  ... (sem mudança)

Resultado: seg_idx=1. Correto!
```

Agora teste com `{3, 3, 3}`:

```
i=1, arr[1]=3, max_idx=0, seg_idx=-1
  arr[1] (3) > arr[0] (3)? NÃO
  seg_idx == -1? SIM → seg_idx = 1
  após: max_idx=0, seg_idx=1

i=2, arr[2]=3, max_idx=0, seg_idx=1
  arr[2] (3) > arr[0] (3)? NÃO
  arr[2] (3) > arr[1] (3)? NÃO
  após: max_idx=0, seg_idx=1

Resultado: seg_idx=1.
```

Mas qual deveria ser o resultado? Se todos são iguais, existe "segundo maior"? Depende da especificação. Isso revela um problema na pré-condição, não necessariamente no código: o **contrato** da função precisa definir o comportamento para empates.

### Printf debugging: hipótese primeiro, print depois

O erro mais comum de debugging é colocar `printf` em todo lugar e ler quilômetros de output esperando que o bug "apareça". Isso é ineficiente. A abordagem correta:

1. Formule uma hipótese: "Acredito que o valor de `x` está errado após a linha 42"
2. Coloque **um** printf estratégico para confirmar ou refutar
3. Se confirmada: investigue o que causa o valor errado de `x`
4. Se refutada: formule nova hipótese e coloque o printf em outro lugar

Cada printf é um **experimento** com uma hipótese associada, não um ato aleatório.

### Erros lógicos comuns

#### Off-by-one (OBOE)

O erro mais frequente em programação. Ocorre quando um loop executa uma iteração a mais ou a menos do que deveria:

```c
// ERRADO: não processa o último elemento
for (int i = 0; i < n - 1; i++) {
    processar(arr[i]);
}

// ERRADO: acessa arr[n], que está fora dos limites
for (int i = 0; i <= n; i++) {
    processar(arr[i]);
}

// CORRETO
for (int i = 0; i < n; i++) {
    processar(arr[i]);
}
```

O padrão para evitar OBOE em C: use `i < n` (exclusivo no limite superior), nunca `i <= n - 1` (que é equivalente mas mais propenso a erro mental).

#### Fence post error (erro de poste de cerca)

Se uma cerca tem 10 seções, quantos postes tem? 11. Esse erro aparece quando confundimos intervalos com pontos:

```c
// Quantos inteiros existem de 1 a 10 (inclusive)?
// Resposta: 10 - 1 + 1 = 10 (não 10 - 1 = 9)

// ERRADO: aloca espaço para 9 separadores, mas precisa de 10
// entre 11 elementos
char resultado[256];
int pos = 0;
for (int i = 0; i < n; i++) {
    if (i > 0) {
        resultado[pos++] = ',';  // Separador ANTES de cada elemento exceto o primeiro
    }
    pos += sprintf(&resultado[pos], "%d", arr[i]);
}
```

#### Erros de lógica booleana

```c
// ERRADO: De Morgan invertido
// Quero: "não é nem A nem B"
if (!a && !b) { ... }   // CORRETO: ¬A ∧ ¬B
if (!(a && b)) { ... }  // ERRADO: ¬(A ∧ B) = ¬A ∨ ¬B (diferente!)

// ERRADO: condição sempre verdadeira
if (x != 1 || x != 2) { ... }
// Se x=1: (1 != 1) || (1 != 2) = false || true = true
// Se x=2: (2 != 1) || (2 != 2) = true || false = true
// Se x=3: (3 != 1) || (3 != 2) = true || true = true
// Sempre true! O correto é:
if (x != 1 && x != 2) { ... }
```

Revisitar as leis de De Morgan da lição de lógica booleana é o remédio para esses bugs.

#### Variáveis não inicializadas

```c
int soma;  // Não inicializada! Contém lixo da stack.
for (int i = 0; i < n; i++) {
    soma += arr[i];  // Soma lixo + arr[0] + arr[1] + ...
}
// Resultado: imprevisível. Pode "funcionar" em debug mode
// e falhar em release (porque o compilador otimiza diferente).
```

Regra: **sempre inicialize variáveis no ponto de declaração**. Em C, o compilador não garante valor zero para variáveis locais (apenas para globais e estáticas).

### Rubber duck debugging

A técnica mais simples e surpreendentemente eficaz: **explique o problema em voz alta** para alguém (ou para um pato de borracha). O ato de articular o problema verbalmente força você a organizar seu raciocínio e frequentemente revela a falha lógica no processo.

Funciona porque debugging é fundamentalmente um problema de **modelo mental incorreto**. Você tem um modelo de como o código deveria funcionar, mas o código faz outra coisa. Ao explicar passo a passo, você confronta seu modelo com a realidade e descobre onde divergem.

---

## Exercícios

### Exercício 1: Decomposição de problema real

Decomponha o seguinte problema em subproblemas, escreva o pseudocódigo e depois implemente em C:

**Problema:** Dado um texto (string), calcule a frequência de cada palavra e imprima as 5 palavras mais frequentes em ordem decrescente. Ignore diferenças de maiúsculas/minúsculas e pontuação.

Dica de decomposição: (1) normalizar texto, (2) separar em palavras, (3) contar frequências, (4) encontrar as top-5, (5) imprimir resultado. Cada subproblema vira uma ou mais funções.

### Exercício 2: Identificar invariantes

Analise o código abaixo e identifique a invariante do loop externo e do loop interno. Prove que o algoritmo está correto usando inicialização/manutenção/terminação.

```c
// Selection Sort
void selection_sort(int *arr, int n) {
    for (int i = 0; i < n - 1; i++) {
        int min_idx = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[min_idx]) {
                min_idx = j;
            }
        }
        int tmp = arr[i];
        arr[i] = arr[min_idx];
        arr[min_idx] = tmp;
    }
}
```

Perguntas guia: O que é verdade sobre `arr[0..i-1]` no início de cada iteração do loop externo? O que `min_idx` representa ao final do loop interno?

### Exercício 3: Trace de execução

Faça a trace table completa (todas as variáveis, todos os passos) para a seguinte função com o input `arr = {4, 2, 7, 1, 5, 3}`, `n = 6`, `k = 3`:

```c
int particionar(int *arr, int n, int k) {
    int menores = 0;
    int iguais = 0;

    for (int i = 0; i < n; i++) {
        if (arr[i] < k)
            menores++;
        else if (arr[i] == k)
            iguais++;
    }

    return menores + iguais;
}
```

Após completar a trace, responda: o que essa função calcula em termos genéricos? Identifique a invariante do loop.

### Exercício 4: Encontrar e corrigir bugs lógicos

O código abaixo deveria inverter uma string in-place, mas tem dois bugs. Encontre-os sem executar o código — use apenas raciocínio e trace tables.

```c
void inverter_string(char *s) {
    int n = strlen(s);
    for (int i = 0; i <= n; i++) {
        char tmp = s[i];
        s[i] = s[n - i];
        s[n - i] = tmp;
    }
}
```

Dicas: (1) Considere o que está na posição `s[n]` em uma string C. (2) Considere o que acontece quando `i` ultrapassa a metade da string.

### Exercício 5: Raciocínio sobre eficiência

Sem calcular Big O formalmente, classifique intuitivamente o custo de cada função abaixo (linear, quadrático, logarítmico, etc.) e explique em uma frase por quê:

```c
// Função A
int funcA(int n) {
    int s = 0;
    for (int i = 1; i < n; i *= 2) {
        s += i;
    }
    return s;
}

// Função B
int funcB(int *arr, int n) {
    int count = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i; j < n; j++) {
            if (arr[i] + arr[j] == 0)
                count++;
        }
    }
    return count;
}

// Função C
void funcC(int *arr, int n) {
    for (int i = 0; i < n; i++) {
        arr[i] = arr[i] * 2 + 1;
    }
    for (int j = 0; j < n; j++) {
        arr[j] = arr[j] - 1;
    }
}

// Função D
int funcD(int n) {
    if (n <= 1) return 1;
    return funcD(n - 1) + funcD(n - 2);
}
```

---

## Referências

- **"Introduction to Algorithms" (CLRS) — Cormen, Leiserson, Rivest, Stein** — O tratamento canônico de invariantes de loop e prova de corretude de algoritmos
- **"Object-Oriented Software Construction" — Bertrand Meyer** — A formalização original de Design by Contract
- **"How to Solve It" — George Pólya** — O clássico sobre resolução de problemas que influenciou o pensamento algorítmico
- **"A Discipline of Programming" — Edsger W. Dijkstra** — Raciocínio formal sobre programas, pré/pós-condições, derivação de programas a partir de especificações
- **"The Practice of Programming" — Kernighan & Pike** — Debugging, teste e estilo — pragmatismo de quem construiu Unix
- **"Thinking Forth" — Leo Brodie** — Decomposição de problemas levada ao extremo (relevante além de Forth)
