---
title: "Lógica Booleana, Matemática Discreta e Sistemas Numéricos"
description: "Fundamentos formais de lógica proposicional, álgebra booleana, aritmética binária, operações bitwise, ponto flutuante IEEE 754, teoria dos conjuntos e lógica de predicados"
track: "cs"
order: 1
section: "Fundamentos Matemáticos"
priority: "high"
tags: ["lógica", "booleana", "binário", "hexadecimal", "bitwise", "matemática", "IEEE 754", "conjuntos", "predicados"]
prerequisites: []
keyTakeaways:
  - "Toda condição no código (if, while, &&, ||) é álgebra booleana — dominar as leis formais permite simplificações não triviais"
  - "As leis de De Morgan, distributiva, absorção e idempotência são ferramentas de refatoração lógica"
  - "Sistemas numéricos (binário, octal, hex) são a base de permissões Unix, máscaras de rede, cores CSS e endereços de memória"
  - "Complemento a dois é a representação padrão de inteiros com sinal — entender overflow previne bugs críticos"
  - "IEEE 754 explica por que 0.1 + 0.2 !== 0.3 e por que comparações de ponto flutuante exigem epsilon"
  - "Operações bitwise são O(1) e fundamentais para flags, masks, hashing e otimizações de baixo nível"
  - "Lógica de predicados (∀, ∃) mapeia diretamente para .every() e .some() em JavaScript"
---

# Lógica Booleana, Matemática Discreta e Sistemas Numéricos

Esta lição cobre os fundamentos matemáticos que sustentam toda a computação. Não se trata de teoria abstrata — cada conceito aqui tem aplicação direta no código que você escreve diariamente. O objetivo é que você domine a formalização por trás das decisões que já toma intuitivamente.

---

## 1. Lógica Proposicional Formal

### 1.1 Proposições e Conectivos

Uma **proposição** é uma sentença declarativa que possui exatamente um valor-verdade: **verdadeiro** (V, 1, `true`) ou **falso** (F, 0, `false`). Sentenças interrogativas, imperativas ou paradoxais ("esta frase é falsa") não são proposições.

Os **conectivos lógicos** fundamentais são:

| Conectivo | Símbolo | Nome | JS/TS |
|---|---|---|---|
| Negação | ¬P | NOT | `!p` |
| Conjunção | P ∧ Q | AND | `p && q` |
| Disjunção | P ∨ Q | OR | `p \|\| q` |
| Condicional | P → Q | Implicação | — |
| Bicondicional | P ↔ Q | Se e somente se | `===` (para booleanos) |
| Disjunção exclusiva | P ⊕ Q | XOR | `p !== q` (para booleanos) |

A **implicação** (P → Q) merece atenção especial: ela é **falsa apenas quando P é verdadeiro e Q é falso**. Isso significa que `false → qualquer_coisa` é sempre verdadeiro (vacuous truth). Esse conceito é fundamental em provas matemáticas e em type systems (o tipo `never` em TypeScript é habitado por zero valores, então qualquer afirmação sobre ele é vacuamente verdadeira).

### 1.2 Tabelas-Verdade Completas

Para duas variáveis P e Q, temos 2² = 4 combinações. Para n variáveis, temos 2ⁿ linhas.

| P | Q | ¬P | P ∧ Q | P ∨ Q | P → Q | P ↔ Q | P ⊕ Q |
|---|---|---|---|---|---|---|---|
| V | V | F | V | V | V | V | F |
| V | F | F | F | V | F | F | V |
| F | V | V | F | V | V | F | V |
| F | F | V | F | F | V | V | F |

**Observação crítica:** Note que P → Q é equivalente a ¬P ∨ Q. Isso não é coincidência — é a definição material da implicação e é a base de muitas simplificações em sistemas de tipos e verificação formal.

### 1.3 Implementação Computacional de Tabelas-Verdade

```typescript
type TruthRow = { vars: boolean[]; result: boolean };

function generateTruthTable(
  numVars: number,
  expression: (...args: boolean[]) => boolean
): TruthRow[] {
  const rows: TruthRow[] = [];
  const totalRows = 1 << numVars; // 2^n usando shift

  for (let i = 0; i < totalRows; i++) {
    const vars: boolean[] = [];
    for (let j = numVars - 1; j >= 0; j--) {
      // Extrai cada bit da posição j
      vars.push(Boolean((i >> j) & 1));
    }
    rows.push({ vars, result: expression(...vars) });
  }
  return rows;
}

// Exemplo: gerar tabela para (P → Q) ↔ (¬P ∨ Q)
const table = generateTruthTable(2, (p, q) => {
  const implication = !p || q;        // P → Q
  const equivalent = !p || q;          // ¬P ∨ Q
  return implication === equivalent;   // Bicondicional: sempre true (tautologia)
});

console.log(table.every(row => row.result)); // true — é uma tautologia
```

Note o uso de `1 << numVars` para calcular 2ⁿ. Essa é uma aplicação direta de shift bitwise que veremos em profundidade mais adiante.

---

## 2. Álgebra Booleana — Leis Formais

A álgebra booleana é um reticulado complementado distributivo. Na prática, isso significa que temos um conjunto {0, 1} com operações (∧, ∨, ¬) que obedecem axiomas específicos. As leis abaixo são **identidades** — valem para quaisquer valores de A, B, C.

### 2.1 Leis Fundamentais

```
Identidade:       A ∧ 1 = A          A ∨ 0 = A
Dominação:        A ∧ 0 = 0          A ∨ 1 = 1
Idempotência:     A ∧ A = A          A ∨ A = A
Complemento:      A ∧ ¬A = 0         A ∨ ¬A = 1
Dupla negação:    ¬(¬A) = A
Comutatividade:   A ∧ B = B ∧ A      A ∨ B = B ∨ A
Associatividade:  (A∧B)∧C = A∧(B∧C)  (A∨B)∨C = A∨(B∨C)
Distributividade: A∧(B∨C) = (A∧B)∨(A∧C)
                  A∨(B∧C) = (A∨B)∧(A∨C)
Absorção:         A ∧ (A ∨ B) = A    A ∨ (A ∧ B) = A
```

### 2.2 Leis de De Morgan

```
¬(A ∧ B) = ¬A ∨ ¬B
¬(A ∨ B) = ¬A ∧ ¬B
```

Generalizadas para n variáveis:

```
¬(A₁ ∧ A₂ ∧ ... ∧ Aₙ) = ¬A₁ ∨ ¬A₂ ∨ ... ∨ ¬Aₙ
¬(A₁ ∨ A₂ ∨ ... ∨ Aₙ) = ¬A₁ ∧ ¬A₂ ∧ ... ∧ ¬Aₙ
```

### 2.3 Prova e Simplificação de Expressões

**Exemplo 1:** Simplificar `¬(A ∧ B) ∨ (A ∧ ¬B)`

```
  ¬(A ∧ B) ∨ (A ∧ ¬B)
= (¬A ∨ ¬B) ∨ (A ∧ ¬B)       [De Morgan]
= ¬A ∨ ¬B ∨ (A ∧ ¬B)          [Associatividade]
= ¬A ∨ (¬B ∨ (A ∧ ¬B))        [Associatividade]
= ¬A ∨ ((¬B ∨ A) ∧ (¬B ∨ ¬B)) [Distributividade]
= ¬A ∨ ((¬B ∨ A) ∧ ¬B)        [Idempotência: ¬B ∨ ¬B = ¬B]
= ¬A ∨ ¬B                      [Absorção: (¬B ∨ A) ∧ ¬B = ¬B]
= ¬(A ∧ B)                     [De Morgan]
```

**Exemplo 2 — Aplicação direta em código:**

```typescript
// Antes da simplificação — condição difícil de ler:
if (!(user.isAdmin && user.isActive) || (user.isAdmin && !user.isActive)) {
  revokeAccess();
}

// Após simplificação algébrica: ¬(A ∧ B) ∨ (A ∧ ¬B) = ¬(A ∧ B) = ¬A ∨ ¬B
if (!user.isAdmin || !user.isActive) {
  revokeAccess();
}
```

**Exemplo 3:** Simplificar `(A ∨ B) ∧ (A ∨ ¬B)`

```
  (A ∨ B) ∧ (A ∨ ¬B)
= A ∨ (B ∧ ¬B)                 [Distributividade (∨ sobre ∧)]
= A ∨ 0                        [Complemento]
= A                             [Identidade]
```

Isso significa que se você tem um código assim:

```typescript
if ((isReady || hasPermission) && (isReady || !hasPermission)) {
  proceed();
}
// É exatamente equivalente a:
if (isReady) {
  proceed();
}
```

---

## 3. Sistemas Numéricos

### 3.1 Representação Posicional

Todo sistema numérico posicional de base **b** representa um número N como:

```
N = dₙ · bⁿ + dₙ₋₁ · bⁿ⁻¹ + ... + d₁ · b¹ + d₀ · b⁰
```

onde cada dígito dᵢ satisfaz 0 ≤ dᵢ < b.

| Base | Nome | Dígitos | Prefixo JS |
|---|---|---|---|
| 2 | Binário | 0, 1 | `0b` |
| 8 | Octal | 0–7 | `0o` |
| 10 | Decimal | 0–9 | (nenhum) |
| 16 | Hexadecimal | 0–9, A–F | `0x` |

### 3.2 Conversão Decimal → Base b (Divisões Sucessivas)

O algoritmo consiste em dividir repetidamente por b e coletar os restos na ordem inversa.

**Exemplo: 237₁₀ para binário (base 2):**

```
237 ÷ 2 = 118  resto 1
118 ÷ 2 =  59  resto 0
 59 ÷ 2 =  29  resto 1
 29 ÷ 2 =  14  resto 1
 14 ÷ 2 =   7  resto 0
  7 ÷ 2 =   3  resto 1
  3 ÷ 2 =   1  resto 1
  1 ÷ 2 =   0  resto 1

Leitura de baixo para cima: 11101101₂
```

Verificação pelo peso posicional:
`1·2⁷ + 1·2⁶ + 1·2⁵ + 0·2⁴ + 1·2³ + 1·2² + 0·2¹ + 1·2⁰ = 128 + 64 + 32 + 8 + 4 + 1 = 237` ✓

**Exemplo: 237₁₀ para hexadecimal (base 16):**

```
237 ÷ 16 = 14  resto 13 (D)
 14 ÷ 16 =  0  resto 14 (E)

Resultado: ED₁₆
```

Verificação: `14·16¹ + 13·16⁰ = 224 + 13 = 237` ✓

### 3.3 Conversão entre Binário, Octal e Hexadecimal

Como 8 = 2³ e 16 = 2⁴, cada dígito octal corresponde a exatamente 3 bits e cada dígito hexadecimal a 4 bits. Isso torna a conversão direta, sem necessidade de passar pelo decimal.

```
Binário:       1  1  1  0  1  1  0  1
Agrupado (4):  1110      1101
Hex:           E         D         → ED₁₆

Agrupado (3):  011  101  101
Octal:         3    5    5         → 355₈
```

```typescript
// Conversões nativas em JavaScript
const n = 237;
console.log(n.toString(2));    // "11101101"
console.log(n.toString(8));    // "355"
console.log(n.toString(16));   // "ed"

// Parse de volta
console.log(parseInt("11101101", 2));  // 237
console.log(parseInt("355", 8));       // 237
console.log(parseInt("ED", 16));       // 237

// Literais numéricos
const bin = 0b11101101; // 237
const oct = 0o355;      // 237
const hex = 0xED;       // 237
```

### 3.4 Aplicação Real — Cores CSS

Uma cor CSS `#1A2B3C` é composta por 3 bytes (24 bits): R=0x1A, G=0x2B, B=0x3C.

```typescript
function hexToRGB(hex: string): [number, number, number] {
  const n = parseInt(hex.replace("#", ""), 16);
  return [
    (n >> 16) & 0xFF,  // Red:   desloca 16 bits, mascara 8 bits
    (n >> 8) & 0xFF,   // Green: desloca 8 bits, mascara 8 bits
    n & 0xFF           // Blue:  mascara 8 bits inferiores
  ];
}

console.log(hexToRGB("#1A2B3C")); // [26, 43, 60]
```

---

## 4. Aritmética Binária

### 4.1 Soma Binária

As regras são idênticas à soma decimal, mas com carry quando a soma ≥ 2:

```
  0 + 0 = 0
  0 + 1 = 1
  1 + 0 = 1
  1 + 1 = 10  (0, carry 1)
1 + 1 + 1 = 11  (1, carry 1)
```

**Exemplo: 1011₂ + 0110₂**

```
    1 1       ← carries
    1 0 1 1   (11)
  + 0 1 1 0   ( 6)
  ---------
  1 0 0 0 1   (17)
```

### 4.2 Complemento a Dois — Representação de Inteiros com Sinal

Para representar números negativos em n bits, usamos **complemento a dois**. O bit mais significativo (MSB) tem peso **-2ⁿ⁻¹** em vez de +2ⁿ⁻¹.

Para n = 8 bits, o intervalo é: **-128 a +127** (ou seja, -2⁷ a 2⁷ - 1).

Fórmula geral para n bits: **[-2ⁿ⁻¹, 2ⁿ⁻¹ - 1]**

**Algoritmo para obter -X em complemento a dois:**
1. Inverta todos os bits de X (complemento a um / bitwise NOT)
2. Some 1

**Exemplo: representar -42 em 8 bits:**

```
 42₁₀ = 00101010₂
Inversão: 11010101
    + 1:  11010110   ← isso é -42 em complemento a dois
```

Verificação: `−128 + 64 + 16 + 4 + 2 = −128 + 86 = −42` ✓

**Subtração via complemento a dois:**

A − B = A + (−B). O hardware só precisa de um circuito somador.

```
  42 - 17 = 42 + (-17)
  42₁₀ = 00101010
 -17₁₀ = 11101111  (inversão de 00010001 + 1)

     1111111      ← carries
     00101010
   + 11101111
   ----------
   (1)00011001    ← descarta o carry do bit 8 → 00011001₂ = 25₁₀ ✓
```

### 4.3 Overflow — O Bug Silencioso

Overflow ocorre quando o resultado de uma operação excede o intervalo representável. Em complemento a dois com n bits, overflow acontece quando:
- Somamos dois positivos e obtemos negativo, ou
- Somamos dois negativos e obtemos positivo

```typescript
// Em JavaScript, números são IEEE 754 double por padrão.
// Mas com operações bitwise, JS trunca para int32.
console.log(0x7FFFFFFF | 0);   //  2147483647 (MAX_INT32)
console.log((0x7FFFFFFF + 1) | 0); // -2147483648 (overflow! wraps para MIN_INT32)

// Isso é o famoso Integer Overflow — causa bugs reais.
// Exemplo histórico: o bug do Gangnam Style no YouTube
// (contador de views era int32, estourou em ~2.1 bilhões).
```

Detecção formal de overflow em soma de A + B com sinal:
```
overflow = (A[n-1] == B[n-1]) && (resultado[n-1] != A[n-1])
```

Se ambos operandos têm o mesmo sinal e o resultado tem sinal diferente, houve overflow.

---

## 5. Operações Bitwise

Operações bitwise operam em cada bit individualmente. São executadas em **O(1)** pelo hardware — um único ciclo de clock — e são a base de inúmeras otimizações.

### 5.1 Operadores Fundamentais

```typescript
// AND (&): bit é 1 somente se ambos forem 1
0b1100 & 0b1010  // 0b1000 (8)

// OR (|): bit é 1 se pelo menos um for 1
0b1100 | 0b1010  // 0b1110 (14)

// XOR (^): bit é 1 se os bits forem diferentes
0b1100 ^ 0b1010  // 0b0110 (6)

// NOT (~): inverte todos os bits (complemento a um)
~0b00001100      // depende da largura; em int32: -13

// Left shift (<<): desloca bits para a esquerda, preenche com 0
0b0001 << 3      // 0b1000 (equivale a multiplicar por 2³ = 8)

// Right shift (>>): desloca para a direita (preserva sinal — arithmetic shift)
0b1000 >> 2      // 0b0010 (equivale a dividir por 2² = 4)

// Unsigned right shift (>>>): desloca para a direita, preenche com 0 (ignora sinal)
(-1 >>> 0)       // 4294967295 (0xFFFFFFFF — todos os 32 bits são 1)
```

### 5.2 Padrões Comuns (Bit Manipulation Idioms)

```typescript
// 1. Verificar se n é par/ímpar — O(1), mais rápido que módulo
const isEven = (n: number): boolean => (n & 1) === 0;

// 2. Verificar se n é potência de 2
// Potência de 2 tem exatamente 1 bit setado: 1000...0
// n-1 tem todos os bits abaixo setados: 0111...1
// AND deles é sempre 0 se n for potência de 2
const isPowerOf2 = (n: number): boolean => n > 0 && (n & (n - 1)) === 0;

// 3. Contar bits setados (population count / Hamming weight)
function popcount(n: number): number {
  let count = 0;
  while (n) {
    n &= n - 1; // Remove o bit setado mais à direita (Brian Kernighan's algorithm)
    count++;
  }
  return count;
}

// 4. Swap sem variável temporária (XOR swap)
let a = 5, b = 3;
a ^= b; // a = 5^3
b ^= a; // b = 3^(5^3) = 5
a ^= b; // a = (5^3)^5 = 3

// 5. Extrair o bit setado mais à direita (lowest set bit)
const lowestBit = (n: number): number => n & (-n);
// Isso funciona porque -n = ~n + 1 (complemento a dois)
```

### 5.3 Aplicação: Sistema de Flags e Permissões

```typescript
// Permissões Unix — cada categoria (owner, group, other) tem 3 bits: rwx
const PERM = {
  OWNER_R: 0o400,  // 100 000 000
  OWNER_W: 0o200,  // 010 000 000
  OWNER_X: 0o100,  // 001 000 000
  GROUP_R: 0o040,  // 000 100 000
  GROUP_W: 0o020,  // 000 010 000
  GROUP_X: 0o010,  // 000 001 000
  OTHER_R: 0o004,  // 000 000 100
  OTHER_W: 0o002,  // 000 000 010
  OTHER_X: 0o001,  // 000 000 001
} as const;

// chmod 755 = owner: rwx (7=4+2+1), group: r-x (5=4+1), other: r-x (5=4+1)
const chmod755 =
  PERM.OWNER_R | PERM.OWNER_W | PERM.OWNER_X |
  PERM.GROUP_R | PERM.GROUP_X |
  PERM.OTHER_R | PERM.OTHER_X;

console.log(chmod755.toString(8)); // "755"

// Verificar permissão específica
function hasPermission(mode: number, perm: number): boolean {
  return (mode & perm) === perm;
}

console.log(hasPermission(chmod755, PERM.GROUP_W));  // false
console.log(hasPermission(chmod755, PERM.OWNER_X));  // true

// Adicionar permissão: OR
const withGroupWrite = chmod755 | PERM.GROUP_W;
console.log(withGroupWrite.toString(8)); // "775"

// Remover permissão: AND NOT
const noOtherExec = chmod755 & ~PERM.OTHER_X;
console.log(noOtherExec.toString(8)); // "754"

// Toggle permissão: XOR
const toggleOwnerWrite = chmod755 ^ PERM.OWNER_W;
console.log(toggleOwnerWrite.toString(8)); // "555"
```

### 5.4 Aplicação: Bitmask para Feature Flags

```typescript
// Sistema de feature flags compacto — um único número armazena N flags
const enum Feature {
  DarkMode    = 1 << 0,  // 1
  BetaAccess  = 1 << 1,  // 2
  AdminPanel  = 1 << 2,  // 4
  Analytics   = 1 << 3,  // 8
  ExportCSV   = 1 << 4,  // 16
}

class FeatureFlags {
  constructor(private flags: number = 0) {}

  enable(feature: Feature): void { this.flags |= feature; }
  disable(feature: Feature): void { this.flags &= ~feature; }
  toggle(feature: Feature): void { this.flags ^= feature; }
  has(feature: Feature): boolean { return (this.flags & feature) === feature; }

  // Verificar se TEM TODAS as features (conjunção)
  hasAll(...features: Feature[]): boolean {
    const mask = features.reduce((m, f) => m | f, 0);
    return (this.flags & mask) === mask;
  }

  // Verificar se TEM PELO MENOS UMA feature (disjunção)
  hasAny(...features: Feature[]): boolean {
    const mask = features.reduce((m, f) => m | f, 0);
    return (this.flags & mask) !== 0;
  }

  // Serialização: um único inteiro transmitido via rede/banco
  serialize(): number { return this.flags; }
  static deserialize(n: number): FeatureFlags { return new FeatureFlags(n); }
}

const user = new FeatureFlags();
user.enable(Feature.DarkMode);
user.enable(Feature.Analytics);
console.log(user.serialize());              // 9 (0b1001)
console.log(user.has(Feature.DarkMode));    // true
console.log(user.has(Feature.AdminPanel));  // false
```

### 5.5 Aplicação: Hashing com XOR

```typescript
// XOR é amplamente usado em funções de hash porque:
// 1. É reversível: a ^ b ^ b = a
// 2. Distribui bits uniformemente
// 3. É comutativo e associativo

// Exemplo clássico: encontrar o número único em array onde todos os outros aparecem 2x
function findUnique(nums: number[]): number {
  return nums.reduce((acc, n) => acc ^ n, 0);
  // Pares se cancelam: a ^ a = 0, e 0 ^ x = x
}

console.log(findUnique([2, 3, 5, 3, 2])); // 5

// Variação: encontrar os DOIS números únicos em O(n) tempo, O(1) espaço
function findTwoUnique(nums: number[]): [number, number] {
  const xorAll = nums.reduce((acc, n) => acc ^ n, 0);
  // xorAll = a ^ b (onde a e b são os dois únicos)
  // Como a ≠ b, existe pelo menos 1 bit diferente entre eles

  const diffBit = xorAll & (-xorAll); // Isola o bit mais à direita que difere

  let group1 = 0, group2 = 0;
  for (const n of nums) {
    if (n & diffBit) group1 ^= n;
    else group2 ^= n;
  }
  return [group1, group2];
}

console.log(findTwoUnique([1, 2, 3, 1, 2, 5])); // [3, 5] (ou [5, 3])
```

---

## 6. Ponto Flutuante — IEEE 754

### 6.1 Estrutura do Formato

O padrão IEEE 754 double precision (64 bits) — o `number` do JavaScript — divide os bits assim:

```
| 1 bit sinal | 11 bits expoente | 52 bits mantissa (fração) |
|     S       |     E            |         M                  |
```

O valor representado é:

```
(-1)^S × 2^(E - 1023) × (1 + M/2^52)
```

onde 1023 é o **bias** do expoente para double precision (permite expoentes negativos sem usar complemento a dois).

### 6.2 Por que 0.1 + 0.2 !== 0.3

O número 0.1 em decimal é uma dízima periódica em binário:

```
0.1₁₀ = 0.0001100110011001100110011... ₂  (período: 0011)
```

Assim como 1/3 = 0.333... não pode ser representado exatamente em decimal finito, 1/10 não pode ser representado exatamente em binário finito. O hardware arredonda para o valor representável mais próximo em 52 bits de mantissa.

```typescript
console.log(0.1 + 0.2);             // 0.30000000000000004
console.log(0.1 + 0.2 === 0.3);     // false

// Solução 1: comparação com epsilon
const EPSILON = Number.EPSILON; // 2^-52 ≈ 2.22e-16
function floatEqual(a: number, b: number, eps = EPSILON): boolean {
  return Math.abs(a - b) < eps;
}

// Solução 2: aritmética inteira (centavos em vez de reais)
// NUNCA use float para dinheiro. Sempre trabalhe com a menor unidade.
const precoEmCentavos = 1999; // R$ 19,99
const desconto = 500;         // R$ 5,00
const total = precoEmCentavos - desconto; // 1499 = R$ 14,99 — exato!

// Solução 3: para display, use toFixed() mas saiba que é apenas formatação
console.log((0.1 + 0.2).toFixed(1)); // "0.3" (string, não número!)
```

### 6.3 Valores Especiais do IEEE 754

```typescript
console.log(1 / 0);          // Infinity    (expoente = 2047, mantissa = 0)
console.log(-1 / 0);         // -Infinity
console.log(0 / 0);          // NaN         (expoente = 2047, mantissa ≠ 0)
console.log(NaN === NaN);    // false — NaN não é igual a nada, nem a si mesmo!
console.log(Number.isNaN(NaN)); // true — use ESTA função, não x === NaN

// Limites do double
console.log(Number.MAX_SAFE_INTEGER);  // 2^53 - 1 = 9007199254740991
console.log(Number.MIN_SAFE_INTEGER);  // -(2^53 - 1)

// Acima de MAX_SAFE_INTEGER, inteiros perdem precisão
console.log(9007199254740992 === 9007199254740993); // true (!)
// Solução: BigInt
console.log(9007199254740992n === 9007199254740993n); // false ✓

// Zero negativo existe em IEEE 754
console.log(-0 === 0);             // true (!)
console.log(Object.is(-0, 0));     // false — Object.is distingue
console.log(1 / -0);               // -Infinity (revela a diferença)
```

### 6.4 Implicações Práticas

```typescript
// PERIGO: loops com float podem nunca terminar ou ter iterações inesperadas
// NÃO faça:
for (let x = 0.0; x !== 1.0; x += 0.1) {
  // Loop INFINITO — x nunca será exatamente 1.0
}

// Faça:
for (let i = 0; i < 10; i++) {
  const x = i / 10;
  // Use x aqui — controle o loop com inteiro
}
```

---

## 7. Teoria dos Conjuntos

### 7.1 Definições e Operações

Um **conjunto** é uma coleção não ordenada de elementos distintos. As operações fundamentais são:

```
União:         A ∪ B = { x | x ∈ A  ∨  x ∈ B }
Interseção:    A ∩ B = { x | x ∈ A  ∧  x ∈ B }
Diferença:     A \ B = { x | x ∈ A  ∧  x ∉ B }
Dif. simétrica: A △ B = (A \ B) ∪ (B \ A) = (A ∪ B) \ (A ∩ B)
Complemento:   Aᶜ = U \ A  (onde U é o conjunto universo)
```

A conexão com lógica booleana é direta — as leis de De Morgan valem para conjuntos:

```
(A ∪ B)ᶜ = Aᶜ ∩ Bᶜ
(A ∩ B)ᶜ = Aᶜ ∪ Bᶜ
```

### 7.2 Implementação com Set do JavaScript

```typescript
// JavaScript Set implementa a estrutura matemática de conjunto
function union<T>(a: Set<T>, b: Set<T>): Set<T> {
  return new Set([...a, ...b]);
}

function intersection<T>(a: Set<T>, b: Set<T>): Set<T> {
  return new Set([...a].filter(x => b.has(x)));
}

function difference<T>(a: Set<T>, b: Set<T>): Set<T> {
  return new Set([...a].filter(x => !b.has(x)));
}

function symmetricDifference<T>(a: Set<T>, b: Set<T>): Set<T> {
  return union(difference(a, b), difference(b, a));
}

function isSubset<T>(a: Set<T>, b: Set<T>): boolean {
  return [...a].every(x => b.has(x)); // A ⊆ B ↔ ∀x(x ∈ A → x ∈ B)
}

// Exemplo prático: encontrar permissões em comum entre dois roles
const adminPerms = new Set(["read", "write", "delete", "manage_users"]);
const editorPerms = new Set(["read", "write", "publish"]);

console.log(intersection(adminPerms, editorPerms)); // Set {"read", "write"}
console.log(difference(adminPerms, editorPerms));    // Set {"delete", "manage_users"}
```

### 7.3 Conjuntos em SQL e Tipos

A teoria dos conjuntos é o fundamento de SQL:

```sql
-- União (∪)
SELECT * FROM tabela_a UNION SELECT * FROM tabela_b;

-- Interseção (∩)
SELECT * FROM tabela_a INTERSECT SELECT * FROM tabela_b;

-- Diferença (\ )
SELECT * FROM tabela_a EXCEPT SELECT * FROM tabela_b;
```

Em TypeScript, os tipos `union` e `intersection` seguem a mesma lógica:

```typescript
// Union type: A | B — valor pode ser de A OU de B (∪ sobre os valores)
type StringOrNumber = string | number;

// Intersection type: A & B — valor deve satisfazer A E B (∩ sobre as restrições)
type WithId = { id: string };
type WithName = { name: string };
type Entity = WithId & WithName; // { id: string; name: string }

// Atenção: a terminologia pode parecer invertida em relação a conjuntos.
// Union type = conjunto MAIOR (mais valores possíveis)
// Intersection type = conjunto MENOR (mais restrições)
// Isso faz sentido se você pensar em termos de conjuntos de VALORES possíveis:
// (valores de A) ∪ (valores de B) → mais valores → tipo mais amplo
// (restrições de A) ∩ (restrições de B) → mais restrições → tipo mais estreito
```

---

## 8. Lógica de Predicados

### 8.1 Quantificadores

A lógica proposicional lida com valores fixos. A **lógica de predicados** (ou de primeira ordem) introduz **variáveis** e **quantificadores**:

- **∀x P(x)** — "Para todo x, P(x) é verdadeiro" (quantificador universal)
- **∃x P(x)** — "Existe pelo menos um x tal que P(x) é verdadeiro" (quantificador existencial)

A negação dos quantificadores segue regras análogas a De Morgan:

```
¬(∀x P(x)) ≡ ∃x ¬P(x)    "nem todo x satisfaz P" ↔ "existe x que não satisfaz P"
¬(∃x P(x)) ≡ ∀x ¬P(x)    "não existe x que satisfaz P" ↔ "para todo x, P não vale"
```

### 8.2 Mapeamento Direto para JavaScript

```typescript
const users = [
  { name: "Alice", age: 30, active: true },
  { name: "Bob", age: 17, active: true },
  { name: "Carol", age: 25, active: false },
];

// ∀x (age(x) ≥ 18) — "todos os usuários são maiores de idade?"
const allAdults = users.every(u => u.age >= 18);
console.log(allAdults); // false (Bob tem 17)

// ∃x (active(x) ∧ age(x) < 18) — "existe algum usuário ativo menor de idade?"
const hasActiveMinor = users.some(u => u.active && u.age < 18);
console.log(hasActiveMinor); // true (Bob)

// Negação: ¬(∀x P(x)) ≡ ∃x ¬P(x)
// "Nem todos são adultos" ↔ "existe alguém que não é adulto"
console.log(!users.every(u => u.age >= 18) === users.some(u => !(u.age >= 18))); // true

// Implicação com quantificador: ∀x (active(x) → age(x) ≥ 18)
// "Todo usuário ativo é maior de idade?"
// Lembre: P → Q ≡ ¬P ∨ Q
const allActiveAreAdults = users.every(u => !u.active || u.age >= 18);
console.log(allActiveAreAdults); // false (Bob é ativo e < 18)
```

### 8.3 Aplicação: Validação de Invariantes

```typescript
// Predicados são fundamentais para validação de invariantes de dados.
// Um sistema robusto define invariantes formalmente e as verifica.

interface Order {
  items: { price: number; quantity: number }[];
  total: number;
  status: "pending" | "paid" | "shipped";
}

// Invariante formal:
// ∀ order ∈ Orders:
//   order.total = Σ(item.price × item.quantity) para todo item ∈ order.items
//   ∧ (order.status = "shipped" → order.status foi "paid" em algum momento)
//   ∧ ∀ item ∈ order.items: item.price > 0 ∧ item.quantity > 0

function validateOrderInvariant(order: Order): boolean {
  const calculatedTotal = order.items.reduce(
    (sum, item) => sum + item.price * item.quantity, 0
  );

  // ∀ item: price > 0 ∧ quantity > 0
  const allItemsValid = order.items.every(
    item => item.price > 0 && item.quantity > 0
  );

  // total = Σ(price × quantity)
  const totalMatches = floatEqual(order.total, calculatedTotal, 0.01);

  return allItemsValid && totalMatches;
}

function floatEqual(a: number, b: number, eps: number): boolean {
  return Math.abs(a - b) < eps;
}
```

---

## 9. Síntese — Conectando os Conceitos

Todos os tópicos desta lição estão interconectados:

1. **Lógica proposicional** é a base das condições no código e da álgebra booleana usada em circuitos digitais.
2. **Álgebra booleana** fornece as leis formais para simplificar condições complexas — refatoração com prova matemática.
3. **Sistemas numéricos** são a ponte entre a abstração humana (decimal) e a realidade do hardware (binário).
4. **Aritmética binária** e **complemento a dois** explicam como o hardware soma, subtrai e por que overflow acontece.
5. **Operações bitwise** são a aplicação direta de lógica booleana no nível de bits — usadas em flags, permissões, hashing e otimizações.
6. **IEEE 754** explica as armadilhas de ponto flutuante que afetam todo código que lida com números não inteiros.
7. **Teoria dos conjuntos** fundamenta SQL, sistemas de tipos e modelagem de dados.
8. **Lógica de predicados** formaliza quantificadores que usamos implicitamente em `.every()`, `.some()`, validações e queries.

Dominar esses fundamentos não é exercício acadêmico — é o que separa o engenheiro que _usa_ ferramentas do engenheiro que _entende_ por que elas funcionam (e por que, às vezes, não funcionam).
