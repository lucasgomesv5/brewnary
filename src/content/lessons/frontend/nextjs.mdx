---
title: "Next.js â€” SSR, SSG e Full-Stack React"
description: "App Router, Server Components, SSR, SSG, ISR, API Routes, middleware, caching, deploy e as decisÃµes arquiteturais para aplicaÃ§Ãµes React em produÃ§Ã£o"
track: "frontend"
order: 14
section: "Frameworks"
priority: "high"
tags: ["nextjs", "react", "ssr", "ssg", "server-components", "app-router", "full-stack"]
prerequisites: ["react-internals", "typescript"]
keyTakeaways:
  - "Next.js Ã© o framework React full-stack dominante: App Router com Server Components Ã© o padrÃ£o moderno, mas Pages Router ainda Ã© amplamente usado"
  - "Server Components (RSC) rodam no servidor e enviam HTML + payload serializado â€” reduzem bundle size e permitem acesso direto a banco/filesystem"
  - "SSR, SSG, ISR e PPR sÃ£o estratÃ©gias de rendering com trade-offs distintos entre freshness, performance e custo de infraestrutura"
  - "O sistema de caching do Next.js tem 4 camadas: Request Memoization, Data Cache, Full Route Cache e Router Cache â€” entender cada uma evita bugs sutis"
  - "Middleware, route handlers, server actions e revalidation sÃ£o as primitivas para construir aplicaÃ§Ãµes full-stack sem API separada"
---

> **Ponto chave:** Next.js nÃ£o Ã© "React com rotas". Ã‰ um framework full-stack que controla como, quando e onde cada componente Ã© renderizado. Entender as estratÃ©gias de rendering, o sistema de caching e os limites entre servidor e cliente Ã© o que separa um dev que "usa Next" de um que domina o framework.

---

## 1. Por que Next.js

### 1.1 Os Problemas que o React Puro NÃ£o Resolve

Uma aplicaÃ§Ã£o React com Vite (SPA pura) tem limitaÃ§Ãµes reais em produÃ§Ã£o:

```
Problema 1: SEO
  SPA renderiza no client â†’ crawler recebe <div id="root"></div>
  Google indexa SPAs, mas com delay e inconsistÃªncia.
  Redes sociais (OG tags) e bots simples nÃ£o executam JS.

Problema 2: Performance percebida
  SPA: baixa HTML vazio â†’ baixa JS bundle â†’ executa â†’ fetch dados â†’ renderiza
  SSR: servidor entrega HTML completo â†’ usuÃ¡rio vÃª conteÃºdo imediatamente
  DiferenÃ§a de LCP pode ser de segundos em conexÃµes lentas.

Problema 3: Data fetching no client
  Waterfalls: componente monta â†’ useEffect â†’ fetch â†’ filho monta â†’ useEffect â†’ fetch
  Cada nÃ­vel da Ã¡rvore adiciona uma round-trip.
  No servidor, o fetch Ã© local (microsegundos vs centenas de ms).

Problema 4: Bundle size
  SPA envia TODO o JavaScript para o client.
  Uma lib de markdown rendering (50KB) usada em uma pÃ¡gina de blog
  Ã© baixada por todos os usuÃ¡rios, mesmo os que nunca acessam o blog.
```

### 1.2 O que o Next.js Adiciona

```
React puro (Vite/CRA):
  - Client-side rendering only
  - Sem routing built-in
  - Sem server-side data fetching
  - Bundle Ãºnico (sem code splitting automÃ¡tico por rota)

Next.js:
  - Server Components (zero JS no client por padrÃ£o)
  - SSR, SSG, ISR, PPR â€” rendering strategy por rota
  - File-based routing com layouts aninhados
  - API routes / Route Handlers
  - Middleware (edge runtime)
  - Image/Font/Script optimization
  - Caching automÃ¡tico em mÃºltiplas camadas
```

### 1.3 App Router vs Pages Router

O Next.js tem dois sistemas de routing que coexistem:

```
Pages Router (pre-13, ainda suportado):
  pages/
    index.tsx         â†’ /
    about.tsx         â†’ /about
    blog/[slug].tsx   â†’ /blog/:slug
    api/hello.ts      â†’ /api/hello

  - getServerSideProps (SSR), getStaticProps (SSG), getStaticPaths
  - Tudo Ã© Client Component por padrÃ£o
  - _app.tsx e _document.tsx para layout global

App Router (13+, padrÃ£o atual):
  app/
    page.tsx          â†’ /
    about/page.tsx    â†’ /about
    blog/[slug]/page.tsx â†’ /blog/:slug
    api/hello/route.ts   â†’ /api/hello

  - Server Components por padrÃ£o
  - Layouts aninhados com state preservado
  - Streaming com Suspense
  - Server Actions
  - Parallel e intercepting routes
```

**Quando usar cada um:**

```
App Router (escolha padrÃ£o para projetos novos):
  âœ“ Server Components e bundle size reduzido
  âœ“ Streaming e loading states granulares
  âœ“ Layouts aninhados sem re-render
  âœ“ Server Actions para mutations

Pages Router (ainda vÃ¡lido):
  âœ“ Projetos existentes â€” migraÃ§Ã£o gradual Ã© possÃ­vel
  âœ“ Bibliotecas que ainda nÃ£o suportam RSC
  âœ“ Equipes que jÃ¡ dominam o modelo mental
```

### 1.4 Quando NÃƒO Usar Next.js

```
Use Vite + React quando:
  - A aplicaÃ§Ã£o Ã© um dashboard autenticado (SEO irrelevante)
  - NÃ£o precisa de SSR/SSG
  - Quer controle total sobre bundling e infra
  - Equipe pequena e deploy em S3/CDN estÃ¡tico

Use Remix quando:
  - Prefere o modelo de web standards (Form, Request, Response)
  - Quer progressive enhancement real
  - NÃ£o quer ficar preso ao ecossistema Vercel

Use Astro quando:
  - O site Ã© primariamente conteÃºdo (blog, docs, marketing)
  - Quer zero JS por padrÃ£o e islands architecture
```

---

## 2. App Router e File-Based Routing

### 2.1 Estrutura do DiretÃ³rio app/

Cada rota no App Router Ã© um diretÃ³rio dentro de `app/`. O Next.js reconhece arquivos especiais por convenÃ§Ã£o de nome:

```
app/
â”œâ”€â”€ layout.tsx          # Layout raiz (obrigatÃ³rio, wraps todas as pÃ¡ginas)
â”œâ”€â”€ page.tsx            # Rota / (home)
â”œâ”€â”€ loading.tsx         # UI de loading (Suspense boundary automÃ¡tico)
â”œâ”€â”€ error.tsx           # Error boundary automÃ¡tico
â”œâ”€â”€ not-found.tsx       # UI para 404
â”œâ”€â”€ global-error.tsx    # Error boundary para o layout raiz
â”‚
â”œâ”€â”€ about/
â”‚   â””â”€â”€ page.tsx        # /about
â”‚
â”œâ”€â”€ blog/
â”‚   â”œâ”€â”€ page.tsx        # /blog
â”‚   â””â”€â”€ [slug]/
â”‚       â”œâ”€â”€ page.tsx    # /blog/meu-post (rota dinÃ¢mica)
â”‚       â””â”€â”€ loading.tsx # Loading especÃ­fico para esta rota
â”‚
â”œâ”€â”€ dashboard/
â”‚   â”œâ”€â”€ layout.tsx      # Layout aninhado (sidebar, header do dashboard)
â”‚   â”œâ”€â”€ page.tsx        # /dashboard
â”‚   â”œâ”€â”€ settings/
â”‚   â”‚   â””â”€â”€ page.tsx    # /dashboard/settings (herda layout do dashboard)
â”‚   â””â”€â”€ [...catchAll]/
â”‚       â””â”€â”€ page.tsx    # /dashboard/qualquer/coisa (catch-all)
â”‚
â””â”€â”€ api/
    â””â”€â”€ webhook/
        â””â”€â”€ route.ts    # POST /api/webhook (Route Handler)
```

### 2.2 Layout, Page e Template

```tsx
// app/layout.tsx â€” Layout raiz (renderiza uma vez, NÃƒO re-renderiza na navegaÃ§Ã£o)
import type { Metadata } from 'next'

export const metadata: Metadata = {
  title: { default: 'Meu App', template: '%s | Meu App' },
  description: 'DescriÃ§Ã£o do app',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="pt-BR">
      <body>
        <nav>
          {/* Navbar persistente â€” nÃ£o re-renderiza entre pÃ¡ginas */}
        </nav>
        <main>{children}</main>
      </body>
    </html>
  )
}
```

```tsx
// app/dashboard/layout.tsx â€” Layout aninhado
export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <div className="flex">
      <aside className="w-64">
        {/* Sidebar do dashboard â€” preserva state entre sub-rotas */}
      </aside>
      <section className="flex-1">{children}</section>
    </div>
  )
}
```

**Diferenca entre layout.tsx e template.tsx:**

```
layout.tsx:
  - Renderiza uma vez e preserva state entre navegaÃ§Ãµes
  - Ideal para navbars, sidebars, providers
  - children muda, mas o layout nÃ£o re-monta

template.tsx:
  - Re-monta a cada navegaÃ§Ã£o (nova instÃ¢ncia)
  - Ãštil para animaÃ§Ãµes de entrada/saÃ­da (useEffect roda a cada navegaÃ§Ã£o)
  - Fica entre o layout e o page na hierarquia
```

### 2.3 Loading, Error e Not Found

```tsx
// app/dashboard/loading.tsx â€” Suspense boundary automÃ¡tico
export default function DashboardLoading() {
  return <div className="animate-pulse">Carregando dashboard...</div>
}

// O Next.js wrapa o page.tsx automaticamente:
// <Suspense fallback={<Loading />}>
//   <Page />
// </Suspense>
```

```tsx
// app/dashboard/error.tsx â€” Error boundary automÃ¡tico
'use client' // Error boundaries PRECISAM ser Client Components

import { useEffect } from 'react'

export default function DashboardError({
  error,
  reset,
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  useEffect(() => {
    // Log para serviÃ§o de monitoramento
    console.error(error)
  }, [error])

  return (
    <div>
      <h2>Algo deu errado no dashboard</h2>
      <p>{error.message}</p>
      <button onClick={() => reset()}>Tentar novamente</button>
    </div>
  )
}
```

```tsx
// app/not-found.tsx â€” PÃ¡gina 404 customizada
import Link from 'next/link'

export default function NotFound() {
  return (
    <div>
      <h2>PÃ¡gina nÃ£o encontrada</h2>
      <Link href="/">Voltar para o inÃ­cio</Link>
    </div>
  )
}
```

### 2.4 Route Groups e OrganizaÃ§Ã£o

Route groups permitem organizar arquivos sem afetar a URL:

```
app/
â”œâ”€â”€ (marketing)/            # Grupo â€” NÃƒO aparece na URL
â”‚   â”œâ”€â”€ layout.tsx          # Layout prÃ³prio para marketing
â”‚   â”œâ”€â”€ page.tsx            # /
â”‚   â”œâ”€â”€ about/page.tsx      # /about
â”‚   â””â”€â”€ pricing/page.tsx    # /pricing
â”‚
â”œâ”€â”€ (dashboard)/            # Grupo â€” NÃƒO aparece na URL
â”‚   â”œâ”€â”€ layout.tsx          # Layout prÃ³prio com sidebar
â”‚   â”œâ”€â”€ dashboard/page.tsx  # /dashboard
â”‚   â””â”€â”€ settings/page.tsx   # /settings
â”‚
â””â”€â”€ (auth)/                 # Grupo para pÃ¡ginas de auth
    â”œâ”€â”€ layout.tsx          # Layout sem navbar
    â”œâ”€â”€ login/page.tsx      # /login
    â””â”€â”€ register/page.tsx   # /register
```

### 2.5 Parallel Routes e Intercepting Routes

**Parallel Routes** renderizam mÃºltiplas pÃ¡ginas na mesma view:

```
app/
â”œâ”€â”€ layout.tsx
â”œâ”€â”€ @analytics/           # Slot "analytics"
â”‚   â””â”€â”€ page.tsx
â”œâ”€â”€ @team/                # Slot "team"
â”‚   â””â”€â”€ page.tsx
â””â”€â”€ page.tsx
```

```tsx
// app/layout.tsx â€” recebe os slots como props
export default function Layout({
  children,
  analytics,
  team,
}: {
  children: React.ReactNode
  analytics: React.ReactNode
  team: React.ReactNode
}) {
  return (
    <div>
      {children}
      <div className="grid grid-cols-2">
        {analytics}
        {team}
      </div>
    </div>
  )
}
```

**Intercepting Routes** permitem mostrar uma rota dentro do contexto atual (ex: modal de foto sem perder o feed):

```
app/
â”œâ”€â”€ feed/
â”‚   â”œâ”€â”€ page.tsx              # Lista de posts
â”‚   â””â”€â”€ (..)photo/[id]/       # Intercepta /photo/[id] mostrando um modal
â”‚       â””â”€â”€ page.tsx
â”œâ”€â”€ photo/[id]/
â”‚   â””â”€â”€ page.tsx              # PÃ¡gina full do photo (acesso direto ou refresh)
```

```
ConvenÃ§Ã£o de interceptaÃ§Ã£o:
  (.)  â†’ mesmo nÃ­vel
  (..) â†’ um nÃ­vel acima
  (..)(..) â†’ dois nÃ­veis acima
  (...) â†’ raiz do app
```

---

## 3. Server Components vs Client Components

### 3.1 O Modelo Mental

No App Router, **todo componente Ã© Server Component por padrÃ£o**. Server Components rodam exclusivamente no servidor â€” o JavaScript deles nunca Ã© enviado ao browser.

```
Server Component (padrÃ£o):
  âœ“ Acessa banco de dados diretamente
  âœ“ LÃª arquivos do filesystem
  âœ“ Usa secrets/env vars do servidor
  âœ“ Zero impacto no bundle size do client
  âœ— NÃ£o pode usar useState, useEffect, useRef
  âœ— NÃ£o pode usar event handlers (onClick, onChange)
  âœ— NÃ£o pode usar browser APIs (window, document)

Client Component ('use client'):
  âœ“ Interatividade (state, effects, events)
  âœ“ Browser APIs
  âœ“ Hooks do React
  âœ— CÃ³digo vai para o bundle do client
  âœ— NÃ£o pode importar diretamente Server Components
```

### 3.2 A Diretiva 'use client'

```tsx
'use client' // Esta diretiva marca o BOUNDARY â€” este componente e tudo que ele
             // importa serÃ¡ incluÃ­do no bundle do client

import { useState } from 'react'

export function Counter() {
  const [count, setCount] = useState(0)

  return (
    <button onClick={() => setCount(count + 1)}>
      Contagem: {count}
    </button>
  )
}
```

**Regra fundamental:** `'use client'` define uma **fronteira de serializaÃ§Ã£o**. Tudo acima Ã© servidor, tudo abaixo (incluindo imports) Ã© client.

```
                        SERVIDOR
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  ServerPage (pode fazer fetch direto)
      â”‚
      â”œâ”€â”€ ServerHeader (HTML puro, zero JS)
      â”‚
      â”œâ”€â”€ ClientInteractiveSection â† 'use client' boundary
      â”‚       â”‚
      â”‚       â”œâ”€â”€ ClientForm (useState, onChange)
      â”‚       â””â”€â”€ ClientButton (onClick)
      â”‚
      â””â”€â”€ ServerFooter (HTML puro, zero JS)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                        CLIENT
```

### 3.3 Patterns de ComposiÃ§Ã£o

**Pattern 1: Empurrar 'use client' para as folhas**

```tsx
// RUIM: marca a pÃ¡gina inteira como Client Component
'use client'

export default function ProductPage() {
  const [qty, setQty] = useState(1)

  return (
    <div>
      <h1>Produto X</h1>           {/* EstÃ¡tico â€” nÃ£o precisava de JS */}
      <p>DescriÃ§Ã£o longa...</p>    {/* EstÃ¡tico â€” nÃ£o precisava de JS */}
      <img src="/product.jpg" />   {/* EstÃ¡tico â€” nÃ£o precisava de JS */}
      <QuantitySelector qty={qty} onChange={setQty} />  {/* Interativo */}
    </div>
  )
}
```

```tsx
// BOM: sÃ³ o componente interativo Ã© Client Component
// app/products/[id]/page.tsx â€” Server Component (padrÃ£o)
import { getProduct } from '@/lib/db'
import { QuantitySelector } from './quantity-selector'

export default async function ProductPage({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const { id } = await params
  const product = await getProduct(id)  // Fetch direto no servidor

  return (
    <div>
      <h1>{product.name}</h1>           {/* Zero JS */}
      <p>{product.description}</p>      {/* Zero JS */}
      <img src={product.imageUrl} />    {/* Zero JS */}
      <QuantitySelector productId={id} /> {/* SÃ³ este Ã© client */}
    </div>
  )
}
```

```tsx
// app/products/[id]/quantity-selector.tsx
'use client'

import { useState } from 'react'

export function QuantitySelector({ productId }: { productId: string }) {
  const [qty, setQty] = useState(1)

  return (
    <div>
      <button onClick={() => setQty(q => Math.max(1, q - 1))}>-</button>
      <span>{qty}</span>
      <button onClick={() => setQty(q => q + 1)}>+</button>
    </div>
  )
}
```

**Pattern 2: Server Component como children de Client Component**

```tsx
// Client Components NÃƒO podem importar Server Components,
// mas podem RECEBÃŠ-LOS como children (ou qualquer prop React.ReactNode)

'use client'
export function Modal({ children }: { children: React.ReactNode }) {
  const [open, setOpen] = useState(false)

  return (
    <>
      <button onClick={() => setOpen(true)}>Abrir</button>
      {open && <dialog open>{children}</dialog>}
    </>
  )
}

// Em um Server Component:
import { Modal } from './modal'
import { ProductDetails } from './product-details' // Server Component

export default async function Page() {
  return (
    <Modal>
      {/* ProductDetails roda no servidor, mas Ã© renderizado dentro do Modal */}
      <ProductDetails />
    </Modal>
  )
}
```

### 3.4 Serialization Boundary

Props passadas de Server para Client Components precisam ser **serializÃ¡veis**:

```
SerializÃ¡vel (pode passar como prop):
  âœ“ Primitivos: string, number, boolean, null, undefined
  âœ“ Arrays e objetos simples (sem mÃ©todos)
  âœ“ Date (serializado como string)
  âœ“ FormData
  âœ“ React elements (JSX) â€” incluindo Server Components como children

NÃƒO serializÃ¡vel:
  âœ— FunÃ§Ãµes (exceto Server Actions)
  âœ— Classes com mÃ©todos
  âœ— InstÃ¢ncias de Map, Set, WeakMap
  âœ— SÃ­mbolos
  âœ— Streams, ReadableStream
```

---

## 4. Rendering Strategies

### 4.1 VisÃ£o Geral

```
EstratÃ©gia    Quando renderiza    HTML gerado    Freshness    Performance
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SSG           Build time          EstÃ¡tico       Stale        MÃ¡xima (CDN)
ISR           Build + revalida    EstÃ¡tico*      ConfigurÃ¡vel Muito boa
SSR           Cada request        DinÃ¢mico       Sempre fresh Boa
Streaming     Cada request        Progressivo    Sempre fresh Boa (TTFB rÃ¡pido)
PPR           Build + request     HÃ­brido        Parcial      Excelente
```

### 4.2 Static Site Generation (SSG)

No App Router, uma rota Ã© estÃ¡tica por padrÃ£o se nÃ£o usa nada dinÃ¢mico:

```tsx
// app/about/page.tsx â€” automaticamente SSG
// Sem fetch dinÃ¢mico, sem cookies, sem headers â†’ HTML gerado no build

export default function AboutPage() {
  return (
    <div>
      <h1>Sobre nÃ³s</h1>
      <p>ConteÃºdo estÃ¡tico gerado no build.</p>
    </div>
  )
}
```

Para rotas dinÃ¢micas com SSG, use `generateStaticParams`:

```tsx
// app/blog/[slug]/page.tsx
import { getAllPosts, getPost } from '@/lib/posts'

// Gera as rotas estÃ¡ticas no build
export async function generateStaticParams() {
  const posts = await getAllPosts()
  return posts.map((post) => ({ slug: post.slug }))
}

export default async function BlogPost({
  params,
}: {
  params: Promise<{ slug: string }>
}) {
  const { slug } = await params
  const post = await getPost(slug)

  return (
    <article>
      <h1>{post.title}</h1>
      <div dangerouslySetInnerHTML={{ __html: post.content }} />
    </article>
  )
}
```

### 4.3 Server-Side Rendering (SSR)

Uma rota se torna SSR (dinÃ¢mica) quando usa funÃ§Ãµes dinÃ¢micas:

```tsx
// app/dashboard/page.tsx â€” SSR (renderiza a cada request)
import { cookies, headers } from 'next/headers'

export default async function DashboardPage() {
  const cookieStore = await cookies()
  const token = cookieStore.get('session')?.value

  const headersList = await headers()
  const ip = headersList.get('x-forwarded-for')

  const data = await fetch('https://api.example.com/dashboard', {
    headers: { Authorization: `Bearer ${token}` },
    cache: 'no-store',  // Explicitamente desabilita cache
  })

  const dashboard = await data.json()

  return <DashboardView data={dashboard} />
}
```

**O que torna uma rota dinÃ¢mica:**

```
FunÃ§Ãµes que forÃ§am SSR:
  cookies()          â€” leitura de cookies (depende do request)
  headers()          â€” leitura de headers (depende do request)
  searchParams       â€” prop de page que depende de query string

OpÃ§Ãµes de fetch:
  fetch(url, { cache: 'no-store' })    â€” desabilita cache
  fetch(url, { next: { revalidate: 0 } })  â€” mesmo efeito

Config explÃ­cita:
  export const dynamic = 'force-dynamic'  â€” forÃ§a SSR
  export const dynamic = 'force-static'   â€” forÃ§a SSG
```

### 4.4 Incremental Static Regeneration (ISR)

ISR combina o melhor de SSG e SSR: serve HTML estÃ¡tico, mas revalida em background:

```tsx
// app/products/page.tsx â€” ISR com revalidaÃ§Ã£o a cada 60 segundos
export const revalidate = 60 // segundos

export default async function ProductsPage() {
  const products = await fetch('https://api.example.com/products', {
    next: { revalidate: 60 },  // Alternativa: configurar no fetch
  })

  const data = await products.json()

  return (
    <ul>
      {data.map((p: { id: string; name: string; price: number }) => (
        <li key={p.id}>{p.name} â€” R$ {p.price}</li>
      ))}
    </ul>
  )
}
```

```
Fluxo ISR (stale-while-revalidate):

  Request 1 (build ou primeiro acesso):
    â†’ Renderiza no servidor â†’ salva HTML no cache â†’ serve

  Request 2 (dentro de 60s):
    â†’ Serve HTML do cache instantaneamente (CDN hit)

  Request 3 (apÃ³s 60s):
    â†’ Serve HTML stale do cache (usuÃ¡rio nÃ£o espera)
    â†’ Em background: re-renderiza a pÃ¡gina com dados frescos
    â†’ Salva novo HTML no cache

  Request 4:
    â†’ Serve o HTML fresco gerado no background
```

### 4.5 Streaming com Suspense

Streaming envia HTML progressivamente, melhorando TTFB e UX:

```tsx
// app/dashboard/page.tsx
import { Suspense } from 'react'
import { RevenueChart } from './revenue-chart'
import { LatestOrders } from './latest-orders'
import { UserStats } from './user-stats'

export default function DashboardPage() {
  return (
    <div>
      <h1>Dashboard</h1>

      {/* UserStats Ã© rÃ¡pido â€” renderiza no HTML inicial */}
      <Suspense fallback={<StatsSkeleton />}>
        <UserStats />
      </Suspense>

      <div className="grid grid-cols-2 gap-4">
        {/* RevenueChart Ã© lento â€” streama quando pronto */}
        <Suspense fallback={<ChartSkeleton />}>
          <RevenueChart />
        </Suspense>

        {/* LatestOrders Ã© lento â€” streama independentemente */}
        <Suspense fallback={<OrdersSkeleton />}>
          <LatestOrders />
        </Suspense>
      </div>
    </div>
  )
}
```

```
Fluxo de streaming:

  1. Servidor envia HTML com <h1>Dashboard</h1> + skeletons â†’ TTFB rÃ¡pido
  2. UserStats resolve â†’ servidor envia chunk HTML para substituir o skeleton
  3. RevenueChart resolve â†’ servidor envia chunk (independente dos outros)
  4. LatestOrders resolve â†’ servidor envia Ãºltimo chunk
  5. PÃ¡gina completa â€” cada seÃ§Ã£o apareceu assim que ficou pronta
```

### 4.6 Partial Prerendering (PPR)

PPR Ã© a estratÃ©gia mais recente â€” combina shell estÃ¡tico com partes dinÃ¢micas:

```tsx
// next.config.ts
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  experimental: {
    ppr: true,  // Habilita Partial Prerendering
  },
}

export default nextConfig
```

```tsx
// app/product/[id]/page.tsx â€” PPR
import { Suspense } from 'react'
import { ProductInfo } from './product-info'
import { UserReviews } from './user-reviews'
import { RecommendedProducts } from './recommended'

export default function ProductPage({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  return (
    <div>
      {/* Parte estÃ¡tica: gerada no build, servida do CDN */}
      <ProductInfo params={params} />

      {/* Parte dinÃ¢mica: renderizada no request, streamed */}
      <Suspense fallback={<ReviewsSkeleton />}>
        <UserReviews params={params} />
      </Suspense>

      {/* Parte dinÃ¢mica: personalizada por usuÃ¡rio */}
      <Suspense fallback={<RecommendedSkeleton />}>
        <RecommendedProducts />
      </Suspense>
    </div>
  )
}
```

```
PPR combina SSG + Streaming:
  - O shell (header, layout, conteÃºdo estÃ¡tico) Ã© prÃ©-renderizado no build
  - As partes dinÃ¢micas (dentro de Suspense) sÃ£o renderizadas no request
  - Resultado: TTFB de um site estÃ¡tico com freshness de SSR
```

---

## 5. Data Fetching e Caching

### 5.1 Fetch no Server Component

No App Router, data fetching acontece diretamente nos Server Components com `async/await`:

```tsx
// app/posts/page.tsx â€” Server Component (async Ã© suportado naturalmente)
export default async function PostsPage() {
  // fetch() no Next.js Ã© estendido com opÃ§Ãµes de cache
  const res = await fetch('https://api.example.com/posts', {
    next: {
      revalidate: 3600,      // ISR: revalida a cada 1 hora
      tags: ['posts'],        // Tag para revalidaÃ§Ã£o sob demanda
    },
  })

  if (!res.ok) throw new Error('Falha ao carregar posts')

  const posts: Post[] = await res.json()

  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

### 5.2 As 4 Camadas de Cache

O Next.js tem um sistema de caching em 4 camadas. Entender cada uma evita bugs sutis e comportamentos inesperados:

```
Camada 1: REQUEST MEMOIZATION (Server, por request)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  O que faz: deduplica fetch() idÃªnticos dentro do MESMO request
  Escopo: dura apenas um render do servidor
  Onde: React estende fetch() para memorizar por URL + options

  CenÃ¡rio: Layout e Page ambos fazem fetch('/api/user')
    â†’ Apenas 1 request HTTP Ã© feito (o segundo retorna do cache em memÃ³ria)

  NÃ£o precisa de configuraÃ§Ã£o â€” Ã© automÃ¡tico.
  SÃ³ funciona com GET requests via fetch().


Camada 2: DATA CACHE (Server, persistente)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  O que faz: armazena respostas de fetch() entre requests e deploys
  Escopo: persistente (sobrevive a redeploys na Vercel)
  Comportamento padrÃ£o: cache HABILITADO (fetch() faz cache por padrÃ£o)

  Para desabilitar:
    fetch(url, { cache: 'no-store' })
    fetch(url, { next: { revalidate: 0 } })

  Para revalidar:
    fetch(url, { next: { revalidate: 3600 } })  â€” time-based
    revalidateTag('posts')                        â€” on-demand
    revalidatePath('/posts')                      â€” on-demand por rota


Camada 3: FULL ROUTE CACHE (Server, persistente)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  O que faz: armazena o HTML e RSC Payload de rotas estÃ¡ticas
  Escopo: persistente (gerado no build para SSG, regenerado no ISR)

  Rotas estÃ¡ticas: HTML + RSC payload cacheados no CDN
  Rotas dinÃ¢micas: NÃƒO sÃ£o cacheadas (SSR a cada request)

  Para invalidar: revalidatePath() ou revalidateTag() invalidam
  tanto o Data Cache quanto o Full Route Cache.


Camada 4: ROUTER CACHE (Client, em memÃ³ria)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  O que faz: armazena RSC payload de rotas visitadas no browser
  Escopo: sessÃ£o do usuÃ¡rio (limpa no refresh)

  - Prefetch de <Link> armazena no Router Cache
  - NavegaÃ§Ã£o para rota jÃ¡ visitada Ã© instantÃ¢nea (sem request ao servidor)
  - Rotas estÃ¡ticas: prefetch completo
  - Rotas dinÃ¢micas: prefetch parcial (sÃ³ o layout compartilhado)

  Para invalidar:
    router.refresh()          â€” limpa o Router Cache da rota atual
    revalidatePath/Tag        â€” invalida no prÃ³ximo request
    cookies.set/delete        â€” invalida automaticamente (seguranÃ§a)
```

### 5.3 Opting Out de Cache

```tsx
// OpÃ§Ã£o 1: no-store no fetch individual
const data = await fetch('https://api.example.com/live-data', {
  cache: 'no-store',
})

// OpÃ§Ã£o 2: segment config (aplica Ã  rota inteira)
export const dynamic = 'force-dynamic'
export const revalidate = 0

// OpÃ§Ã£o 3: usando funÃ§Ãµes dinÃ¢micas (cookies, headers, searchParams)
import { cookies } from 'next/headers'

export default async function Page() {
  const cookieStore = await cookies() // Torna a rota dinÃ¢mica automaticamente
  // ...
}
```

### 5.4 RevalidaÃ§Ã£o On-Demand

```tsx
// app/api/revalidate/route.ts â€” Webhook que revalida cache
import { revalidateTag, revalidatePath } from 'next/cache'
import { NextRequest } from 'next/server'

export async function POST(request: NextRequest) {
  const secret = request.headers.get('x-revalidation-secret')

  if (secret !== process.env.REVALIDATION_SECRET) {
    return Response.json({ error: 'Unauthorized' }, { status: 401 })
  }

  const { tag, path } = await request.json()

  if (tag) {
    revalidateTag(tag)    // Invalida todos os fetch() com essa tag
  }

  if (path) {
    revalidatePath(path)  // Invalida a rota inteira
  }

  return Response.json({ revalidated: true, now: Date.now() })
}
```

### 5.5 Data Fetching sem fetch() â€” unstable_cache

Para acessos a banco de dados (Prisma, Drizzle) que nÃ£o usam `fetch()`:

```tsx
import { unstable_cache } from 'next/cache'
import { db } from '@/lib/db'

const getCachedUser = unstable_cache(
  async (userId: string) => {
    return db.user.findUnique({ where: { id: userId } })
  },
  ['user-by-id'],          // Cache key prefix
  {
    revalidate: 900,        // 15 minutos
    tags: ['users'],        // Tag para revalidaÃ§Ã£o sob demanda
  }
)

export default async function UserProfile({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const { id } = await params
  const user = await getCachedUser(id)

  return <div>{user?.name}</div>
}
```

---

## 6. Server Actions

### 6.1 O que SÃ£o

Server Actions sÃ£o funÃ§Ãµes assÃ­ncronas que rodam no servidor e podem ser chamadas diretamente do client. Substituem a necessidade de criar API routes para mutations simples.

```tsx
// A diretiva 'use server' marca a funÃ§Ã£o como uma Server Action
// Pode ser usada em arquivo separado ou inline em Server Components

// app/actions/posts.ts
'use server'

import { revalidatePath } from 'next/cache'
import { db } from '@/lib/db'
import { z } from 'zod'

const createPostSchema = z.object({
  title: z.string().min(3).max(200),
  content: z.string().min(10),
})

export async function createPost(formData: FormData) {
  const parsed = createPostSchema.safeParse({
    title: formData.get('title'),
    content: formData.get('content'),
  })

  if (!parsed.success) {
    return { error: parsed.error.flatten().fieldErrors }
  }

  await db.post.create({
    data: {
      title: parsed.data.title,
      content: parsed.data.content,
    },
  })

  revalidatePath('/posts')  // Invalida o cache da lista de posts
}
```

### 6.2 Usando com Forms

```tsx
// app/posts/new/page.tsx â€” Server Component com form
import { createPost } from '@/app/actions/posts'

export default function NewPostPage() {
  return (
    <form action={createPost}>
      <label htmlFor="title">TÃ­tulo</label>
      <input id="title" name="title" type="text" required />

      <label htmlFor="content">ConteÃºdo</label>
      <textarea id="content" name="content" required />

      <button type="submit">Publicar</button>
    </form>
  )
}
```

### 6.3 Com useActionState (Feedback e ValidaÃ§Ã£o)

```tsx
'use client'

import { useActionState } from 'react'
import { createPost } from '@/app/actions/posts'

// A Server Action precisa receber prevState como primeiro argumento
// quando usada com useActionState
type ActionState = {
  error?: Record<string, string[]>
  success?: boolean
}

export function CreatePostForm() {
  const [state, formAction, isPending] = useActionState<ActionState, FormData>(
    async (_prevState, formData) => {
      const result = await createPost(formData)
      if (result?.error) return { error: result.error }
      return { success: true }
    },
    { error: undefined, success: undefined }
  )

  return (
    <form action={formAction}>
      <input name="title" type="text" required />
      {state.error?.title && (
        <p className="text-red-500">{state.error.title[0]}</p>
      )}

      <textarea name="content" required />
      {state.error?.content && (
        <p className="text-red-500">{state.error.content[0]}</p>
      )}

      <button type="submit" disabled={isPending}>
        {isPending ? 'Publicando...' : 'Publicar'}
      </button>

      {state.success && <p className="text-green-500">Post criado!</p>}
    </form>
  )
}
```

### 6.4 Optimistic Updates

```tsx
'use client'

import { useOptimistic } from 'react'
import { toggleLike } from '@/app/actions/likes'

type Post = {
  id: string
  title: string
  liked: boolean
  likeCount: number
}

export function PostCard({ post }: { post: Post }) {
  const [optimisticPost, addOptimistic] = useOptimistic(
    post,
    (currentPost, _action: 'toggle') => ({
      ...currentPost,
      liked: !currentPost.liked,
      likeCount: currentPost.liked
        ? currentPost.likeCount - 1
        : currentPost.likeCount + 1,
    })
  )

  async function handleLike() {
    addOptimistic('toggle')         // Atualiza UI imediatamente
    await toggleLike(post.id)       // Server Action em background
    // Se falhar, o React reverte automaticamente para o state real
  }

  return (
    <div>
      <h2>{optimisticPost.title}</h2>
      <button onClick={handleLike}>
        {optimisticPost.liked ? 'â¤ï¸' : 'ğŸ¤'} {optimisticPost.likeCount}
      </button>
    </div>
  )
}
```

### 6.5 Seguranca em Server Actions

```tsx
'use server'

import { auth } from '@/lib/auth'
import { redirect } from 'next/navigation'

export async function deletePost(postId: string) {
  // SEMPRE valide autenticaÃ§Ã£o em Server Actions
  // Elas sÃ£o endpoints HTTP â€” qualquer pessoa pode chamÃ¡-las
  const session = await auth()

  if (!session?.user) {
    redirect('/login')
  }

  // Valide autorizaÃ§Ã£o
  const post = await db.post.findUnique({ where: { id: postId } })

  if (post?.authorId !== session.user.id) {
    throw new Error('NÃ£o autorizado')
  }

  // Valide input (nunca confie no client)
  if (typeof postId !== 'string' || postId.length === 0) {
    throw new Error('ID invÃ¡lido')
  }

  await db.post.delete({ where: { id: postId } })
  revalidatePath('/posts')
}
```

---

## 7. API Routes e Middleware

### 7.1 Route Handlers

Route Handlers substituem as API Routes do Pages Router:

```tsx
// app/api/posts/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'

// GET /api/posts
export async function GET(request: NextRequest) {
  const { searchParams } = request.nextUrl
  const page = parseInt(searchParams.get('page') ?? '1')
  const limit = 20

  const posts = await db.post.findMany({
    skip: (page - 1) * limit,
    take: limit,
    orderBy: { createdAt: 'desc' },
  })

  return NextResponse.json(posts)
}

// POST /api/posts
export async function POST(request: NextRequest) {
  const body = await request.json()

  const post = await db.post.create({ data: body })

  return NextResponse.json(post, { status: 201 })
}
```

```tsx
// app/api/posts/[id]/route.ts â€” Rota dinÃ¢mica
import { NextRequest, NextResponse } from 'next/server'

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params
  const post = await db.post.findUnique({ where: { id } })

  if (!post) {
    return NextResponse.json({ error: 'Not found' }, { status: 404 })
  }

  return NextResponse.json(post)
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params
  await db.post.delete({ where: { id } })

  return new NextResponse(null, { status: 204 })
}
```

**Quando usar Route Handlers vs Server Actions:**

```
Server Actions:
  - Mutations disparadas pelo usuÃ¡rio (forms, buttons)
  - IntegraÃ§Ã£o nativa com revalidation e redirect
  - Suporta progressive enhancement (funciona sem JS)

Route Handlers:
  - Webhooks de serviÃ§os externos
  - APIs pÃºblicas consumidas por outros clients (mobile, terceiros)
  - Streaming responses (SSE, file download)
  - Quando precisa de controle fino sobre headers/status codes
```

### 7.2 Middleware

Middleware roda no Edge Runtime antes de cada request, ideal para auth, redirects e headers:

```tsx
// middleware.ts (na raiz do projeto, fora de app/)
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl

  // Exemplo 1: Redirect baseado em condiÃ§Ã£o
  if (pathname === '/old-page') {
    return NextResponse.redirect(new URL('/new-page', request.url))
  }

  // Exemplo 2: ProteÃ§Ã£o de rotas
  const token = request.cookies.get('session')?.value

  if (pathname.startsWith('/dashboard') && !token) {
    const loginUrl = new URL('/login', request.url)
    loginUrl.searchParams.set('redirect', pathname)
    return NextResponse.redirect(loginUrl)
  }

  // Exemplo 3: Adicionar headers
  const response = NextResponse.next()
  response.headers.set('x-request-id', crypto.randomUUID())

  return response
}

// Matcher: define em quais rotas o middleware roda
export const config = {
  matcher: [
    // Roda em tudo EXCETO arquivos estÃ¡ticos e _next
    '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
  ],
}
```

### 7.3 Pattern: Auth com Middleware

```tsx
// middleware.ts â€” Pattern completo de autenticaÃ§Ã£o
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'
import { verifyToken } from '@/lib/auth-edge'  // VersÃ£o Edge-compatible do JWT verify

const publicRoutes = ['/', '/login', '/register', '/about', '/pricing']

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl

  // Rotas pÃºblicas: nÃ£o precisa de auth
  if (publicRoutes.includes(pathname)) {
    return NextResponse.next()
  }

  // API routes: validaÃ§Ã£o diferente (Bearer token)
  if (pathname.startsWith('/api/')) {
    const authHeader = request.headers.get('authorization')
    if (!authHeader?.startsWith('Bearer ')) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const token = authHeader.split(' ')[1]
    const payload = await verifyToken(token)

    if (!payload) {
      return NextResponse.json({ error: 'Invalid token' }, { status: 401 })
    }

    // Injeta user info nos headers para os Route Handlers
    const response = NextResponse.next()
    response.headers.set('x-user-id', payload.sub)
    return response
  }

  // Rotas protegidas: cookie-based auth
  const sessionCookie = request.cookies.get('session')?.value

  if (!sessionCookie) {
    return NextResponse.redirect(
      new URL(`/login?redirect=${pathname}`, request.url)
    )
  }

  const payload = await verifyToken(sessionCookie)

  if (!payload) {
    const response = NextResponse.redirect(new URL('/login', request.url))
    response.cookies.delete('session')
    return response
  }

  return NextResponse.next()
}
```

**Limitacoes do Edge Runtime no Middleware:**

```
O Middleware roda no Edge Runtime (V8 isolate, NÃƒO Node.js).

NÃ£o disponÃ­vel:
  âœ— fs, path, child_process (APIs do Node.js)
  âœ— ConexÃµes TCP diretas (banco de dados via driver nativo)
  âœ— Bibliotecas que dependem de Node.js APIs

DisponÃ­vel:
  âœ“ fetch() (Web API)
  âœ“ crypto.subtle (Web Crypto)
  âœ“ TextEncoder/TextDecoder
  âœ“ Headers, Request, Response (Web APIs)
  âœ“ Bibliotecas edge-compatible (jose para JWT, por exemplo)

ConsequÃªncia: validaÃ§Ã£o de JWT no middleware deve usar
jose (Edge-compatible) em vez de jsonwebtoken (Node-only).
```

---

## 8. Deploy e Performance

### 8.1 Deploy na Vercel

A Vercel Ã© a plataforma criada pelo time do Next.js. O deploy Ã© zero-config:

```
Vantagens:
  - Automatic Edge Network (CDN global)
  - Serverless Functions para SSR/API routes
  - ISR nativo (Data Cache persistente entre deploys)
  - Preview deployments por PR
  - Analytics e Speed Insights integrados

ConsideraÃ§Ãµes:
  - Vendor lock-in para features avanÃ§adas (ISR persistente, Edge Middleware)
  - Custos escalam com trÃ¡fego (serverless pricing)
  - Limites de cold start em serverless functions
```

### 8.2 Self-Hosting com Docker

```tsx
// next.config.ts â€” output standalone para Docker
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  output: 'standalone',  // Gera um build auto-contido com dependÃªncias
}

export default nextConfig
```

```dockerfile
# Dockerfile multi-stage para Next.js
FROM node:20-alpine AS base

# Instala dependÃªncias
FROM base AS deps
WORKDIR /app
COPY package.json package-lock.json ./
RUN npm ci --only=production

# Build da aplicaÃ§Ã£o
FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .
RUN npm run build

# Imagem final (mÃ­nima)
FROM base AS runner
WORKDIR /app

ENV NODE_ENV=production
ENV NEXT_TELEMETRY_DISABLED=1

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

# Copia apenas o necessÃ¡rio do standalone output
COPY --from=builder /app/public ./public
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

USER nextjs

EXPOSE 3000
ENV PORT=3000
ENV HOSTNAME="0.0.0.0"

CMD ["node", "server.js"]
```

```
Resultado do standalone output:
  .next/standalone/
  â”œâ”€â”€ server.js          # Servidor Node.js minimalista
  â”œâ”€â”€ node_modules/      # Apenas dependÃªncias de produÃ§Ã£o (tree-shaken)
  â””â”€â”€ .next/             # Build output

  Tamanho tÃ­pico: ~50MB vs ~500MB+ com node_modules completo
```

### 8.3 Otimizacao de Imagens

```tsx
// O componente Image do Next.js otimiza automaticamente
import Image from 'next/image'

export function ProductImage({ src, alt }: { src: string; alt: string }) {
  return (
    <Image
      src={src}
      alt={alt}
      width={800}
      height={600}
      // OtimizaÃ§Ãµes automÃ¡ticas:
      // - Converte para WebP/AVIF
      // - Gera srcset responsivo
      // - Lazy loading por padrÃ£o
      // - Previne CLS com width/height
      placeholder="blur"          // Mostra blur enquanto carrega
      blurDataURL="/placeholder.png"
      sizes="(max-width: 768px) 100vw, 50vw"
      priority={false}            // true para imagens above-the-fold (LCP)
    />
  )
}
```

### 8.4 Bundle Analysis

```bash
# Instalar o analyzer
npm install @next/bundle-analyzer

# next.config.ts
import type { NextConfig } from 'next'
import withBundleAnalyzer from '@next/bundle-analyzer'

const nextConfig: NextConfig = {
  // ... config
}

export default withBundleAnalyzer({
  enabled: process.env.ANALYZE === 'true',
})(nextConfig)

# Rodar anÃ¡lise
ANALYZE=true npm run build
# Abre um relatÃ³rio visual com o tamanho de cada mÃ³dulo
```

```
EstratÃ©gias para reduzir bundle size:

1. Server Components (padrÃ£o no App Router)
   â†’ Bibliotecas usadas sÃ³ no servidor (marked, prisma) = zero client JS

2. Dynamic imports para componentes pesados
   import dynamic from 'next/dynamic'
   const HeavyChart = dynamic(() => import('./chart'), {
     loading: () => <ChartSkeleton />,
     ssr: false,  // Se nÃ£o precisa de SSR, nem roda no servidor
   })

3. Substituir bibliotecas pesadas
   moment.js (300KB) â†’ date-fns (tree-shakeable) ou Temporal API
   lodash (70KB) â†’ lodash-es (tree-shakeable) ou mÃ©todos nativos

4. Barrel file problem
   import { Button } from '@/components'  // Importa TUDO do barrel
   import { Button } from '@/components/button'  // Importa sÃ³ o necessÃ¡rio

   Ou configure optimizePackageImports no next.config.ts:
   experimental: {
     optimizePackageImports: ['@/components', 'lucide-react'],
   }
```

### 8.5 Core Web Vitals no Next.js

```tsx
// Monitoramento de Web Vitals
// app/components/web-vitals.tsx
'use client'

import { useReportWebVitals } from 'next/web-vitals'

export function WebVitals() {
  useReportWebVitals((metric) => {
    // Envia para analytics (ex: Vercel Analytics, DataDog, etc.)
    console.log(metric)

    // metric.name: 'LCP' | 'FID' | 'CLS' | 'INP' | 'TTFB' | 'FCP'
    // metric.value: nÃºmero (ms para timing, score para CLS)
    // metric.rating: 'good' | 'needs-improvement' | 'poor'
  })

  return null
}
```

```
Checklist de performance no Next.js:

LCP (Largest Contentful Paint):
  â–¡ Imagens hero com priority={true} no componente Image
  â–¡ Fonts com next/font (evita FOUT/FOIT)
  â–¡ Preload de dados crÃ­ticos
  â–¡ Evitar client-side fetch para conteÃºdo above-the-fold (usar RSC)

INP (Interaction to Next Paint):
  â–¡ Mover lÃ³gica pesada para Server Components
  â–¡ useTransition para updates nÃ£o-urgentes
  â–¡ Dynamic import para componentes pesados
  â–¡ Evitar hydration mismatch (causa re-renders completos)

CLS (Cumulative Layout Shift):
  â–¡ width + height em todas as imagens
  â–¡ Skeleton loaders com dimensÃµes fixas
  â–¡ Evitar inject de conteÃºdo acima do fold apÃ³s load
  â–¡ Font display swap com tamanhos consistentes (next/font)

TTFB (Time to First Byte):
  â–¡ ISR/SSG para rotas que podem ser estÃ¡ticas
  â–¡ Streaming com Suspense para rotas dinÃ¢micas
  â–¡ Edge Runtime para middleware leve
  â–¡ CDN na frente (Vercel, Cloudflare, etc.)
```

### 8.6 Configuracoes Avancadas do next.config.ts

```tsx
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  // Output mode
  output: 'standalone',               // Para Docker/self-hosting

  // Imagens de domÃ­nios externos
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: '**.example.com',    // Wildcard para subdomÃ­nios
      },
    ],
  },

  // Headers customizados
  async headers() {
    return [
      {
        source: '/api/:path*',
        headers: [
          { key: 'Access-Control-Allow-Origin', value: 'https://meusite.com' },
          { key: 'Access-Control-Allow-Methods', value: 'GET, POST, OPTIONS' },
        ],
      },
    ]
  },

  // Redirects (processados antes de rotas)
  async redirects() {
    return [
      {
        source: '/blog/:slug',
        destination: '/posts/:slug',
        permanent: true,               // 308 (SEO: transfere ranking)
      },
    ]
  },

  // Rewrites (proxy transparente)
  async rewrites() {
    return [
      {
        source: '/api/v1/:path*',
        destination: 'https://api-legacy.example.com/:path*',
      },
    ]
  },

  // OtimizaÃ§Ã£o de imports (tree-shaking em barrel files)
  experimental: {
    optimizePackageImports: ['lucide-react', '@headlessui/react'],
  },
}

export default nextConfig
```

---

## Mapa Mental: Decisoes Arquiteturais

```
Preciso de SEO?
â”œâ”€â”€ NÃ£o â†’ SPA (Vite + React) pode ser suficiente
â””â”€â”€ Sim â†’ Next.js
        â”‚
        ConteÃºdo muda com frequÃªncia?
        â”œâ”€â”€ NÃ£o (ou raramente) â†’ SSG + ISR
        â”‚     Exemplo: blog, docs, e-commerce catalog
        â”‚
        â”œâ”€â”€ A cada request â†’ SSR
        â”‚     Exemplo: dashboard personalizado, feed social
        â”‚
        â””â”€â”€ Parte estÃ¡tica + parte dinÃ¢mica â†’ PPR
              Exemplo: pÃ¡gina de produto (info estÃ¡tica + reviews dinÃ¢micas)

Preciso de API?
â”œâ”€â”€ Mutations simples (CRUD) â†’ Server Actions
â”œâ”€â”€ API pÃºblica / webhooks â†’ Route Handlers
â””â”€â”€ API complexa com muitos consumers â†’ Backend separado (NestJS, Go, etc.)

Onde deployar?
â”œâ”€â”€ MÃ­nimo esforÃ§o â†’ Vercel (zero-config, ISR nativo)
â”œâ”€â”€ Controle total â†’ Docker + standalone output
â””â”€â”€ Edge performance â†’ Cloudflare Workers (com adapter)
```

---

## Erros Comuns e Como Evitar

```
1. "Hydration mismatch" â€” HTML do servidor â‰  HTML do client
   Causa: usar Date.now(), Math.random(), ou window em render
   Fix: useEffect para valores client-only, ou suppressHydrationWarning

2. "Cannot use useState in a Server Component"
   Causa: tentou usar hooks em componente sem 'use client'
   Fix: extrair a parte interativa para um Client Component separado

3. Cache servindo dados stale e vocÃª nÃ£o sabe por quÃª
   Causa: Data Cache + Full Route Cache + Router Cache combinados
   Fix: entender qual camada estÃ¡ cacheando e usar revalidate/no-store

4. Server Action nÃ£o atualiza a UI
   Causa: esqueceu de chamar revalidatePath/revalidateTag apÃ³s mutaÃ§Ã£o
   Fix: sempre revalidar o cache relevante no final da action

5. Middleware pesado aumentando latÃªncia
   Causa: operaÃ§Ãµes complexas no Edge Runtime (ex: consultas a banco)
   Fix: middleware deve ser leve â€” validar JWT, redirect, headers apenas

6. Bundle size nÃ£o diminuiu com App Router
   Causa: 'use client' no topo de componentes que poderiam ser Server
   Fix: empurrar 'use client' para as folhas da Ã¡rvore de componentes

7. "Dynamic server usage" em rota que deveria ser estÃ¡tica
   Causa: cookies(), headers() ou searchParams usados na rota
   Fix: mover a lÃ³gica dinÃ¢mica para dentro de Suspense (PPR) ou aceitar SSR
```
