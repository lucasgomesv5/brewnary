---
title: "Vue.js — Fundamentos e Composition API"
description: "Reatividade, Composition API, componentes, Pinia, Vue Router, Nuxt, testing e as decisões de design que fazem Vue uma alternativa pragmática ao React"
track: "frontend"
order: 15
section: "Frameworks"
priority: "medium"
tags: ["vuejs", "composition-api", "reatividade", "pinia", "nuxt", "vue-router"]
prerequisites: ["typescript", "closures"]
keyTakeaways:
  - "Vue usa um sistema de reatividade baseado em Proxy (Vue 3) que rastreia dependências automaticamente — sem necessidade de setState ou hooks"
  - "A Composition API (setup, ref, reactive, computed, watch) substituiu a Options API como padrão, oferecendo melhor TypeScript support e composabilidade"
  - "Single File Components (.vue) encapsulam template, script e style num único arquivo com scoped CSS nativo"
  - "Pinia é o state manager oficial: type-safe, devtools integration, sem boilerplate de mutations como Vuex"
  - "Nuxt é o meta-framework Vue (equivalente ao Next.js): SSR, SSG, file-based routing, server routes e auto-imports"
---

> **Ponto chave:** Vue é um framework progressivo — você pode adotá-lo incrementalmente, de um widget isolado até uma SPA completa com SSR. O sistema de reatividade baseado em Proxy rastreia dependências automaticamente sem que você precise declarar arrays de dependências como no React. Entender como Vue funciona por dentro permite tomar decisões arquiteturais fundamentadas e evitar armadilhas de performance que nenhum tutorial cobre.

---

## 1. Por que Vue

### 1.1 Filosofia: Framework Progressivo

Vue foi projetado para ser adotado incrementalmente. Diferente do Angular (que exige buy-in total) e do React (que é uma library e precisa de decisões para routing, state, etc.), Vue oferece um caminho gradual:

```
Nível 1: Substituir jQuery em páginas existentes (CDN script tag)
Nível 2: Componentes interativos com build tool (Vite)
Nível 3: SPA completa (Vue Router + Pinia)
Nível 4: SSR/SSG com meta-framework (Nuxt)

Cada nível adiciona complexidade apenas quando necessário.
O core do Vue (~33KB gzipped) inclui reatividade + componentes.
O restante é opt-in.
```

### 1.2 Comparação com React e Angular

```
                Vue 3              React 18+            Angular 17+
─────────────────────────────────────────────────────────────────────
Reatividade    Proxy automático    useState/hooks       Signals/ZoneJS
Templates      HTML-based          JSX                  HTML-based
Scoped CSS     Nativo (.vue)       CSS Modules/etc      ViewEncapsulation
State mgmt     Pinia (oficial)     Nenhum oficial       Signals/Services
Routing        Vue Router          React Router (3rd)   @angular/router
SSR            Nuxt                Next.js              Angular Universal
TypeScript     Bom (melhorou v3)   Excelente            Nativo
Learning curve Baixa-média         Média                Alta
Bundle size    ~33KB               ~40KB (+react-dom)   ~130KB
```

**Onde Vue se destaca:**

- **DX (Developer Experience):** SFCs com scoped CSS, auto-import de componentes, DevTools excelentes
- **Reatividade granular:** Diferente do React (re-renderiza componente inteiro), Vue rastreia exatamente qual dado mudou e atualiza apenas o DOM afetado
- **Curva de aprendizado:** Templates são HTML válido com diretivas — mais acessível para quem vem de HTML/CSS
- **Ecossistema coeso:** Vue Router, Pinia, Vitest, Nuxt — tudo mantido pelo core team

### 1.3 Adoção no Mercado

Vue é usado em produção por empresas de escala global: **Alibaba** (core do ecossistema de e-commerce), **GitLab** (frontend inteiro migrado de jQuery para Vue), **Nintendo** (sites institucionais), **Xiaomi**, **Grammarly**, **Adobe** (segmentos do portfólio), **Wikimedia Foundation**, e **Baidu**. No ecossistema Laravel, Vue é o framework frontend padrão de facto. Na China, Vue rivaliza com React em market share.

---

## 2. Sistema de Reatividade

### 2.1 Como Funciona por Dentro (Proxy)

No Vue 2, a reatividade usava `Object.defineProperty` — o que impedia detectar adição/remoção de propriedades e mudanças em arrays por índice. O Vue 3 reescreveu o sistema inteiro com `Proxy` do ES6:

```javascript
// Modelo mental simplificado do sistema reativo do Vue 3
const targetMap = new WeakMap() // { target → Map { key → Set<effects> } }
let activeEffect = null

function reactive(target) {
  return new Proxy(target, {
    get(obj, key, receiver) {
      track(obj, key)          // Registra qual effect depende desta propriedade
      const result = Reflect.get(obj, key, receiver)
      // Se o valor é um objeto, torna-o reativo também (lazy)
      return typeof result === 'object' && result !== null
        ? reactive(result)
        : result
    },
    set(obj, key, value, receiver) {
      const oldValue = obj[key]
      const result = Reflect.set(obj, key, value, receiver)
      if (!Object.is(oldValue, value)) {
        trigger(obj, key)      // Notifica todos os effects que dependem desta propriedade
      }
      return result
    },
    deleteProperty(obj, key) {
      const result = Reflect.deleteProperty(obj, key)
      trigger(obj, key)
      return result
    }
  })
}

function track(target, key) {
  if (!activeEffect) return
  let depsMap = targetMap.get(target)
  if (!depsMap) targetMap.set(target, (depsMap = new Map()))
  let deps = depsMap.get(key)
  if (!deps) depsMap.set(key, (deps = new Set()))
  deps.add(activeEffect)      // Associa o effect à propriedade
}

function trigger(target, key) {
  const depsMap = targetMap.get(target)
  if (!depsMap) return
  const deps = depsMap.get(key)
  if (deps) deps.forEach(effect => effect.run()) // Re-executa todos os effects
}
```

```
Fluxo de rastreamento automático:

1. Um effect (computed, watch, template render) é registrado como activeEffect
2. Durante a execução do effect, propriedades reativas são lidas → GET interceptado
3. track() associa cada propriedade lida ao activeEffect
4. Quando uma propriedade muda → SET interceptado
5. trigger() re-executa todos os effects que dependem daquela propriedade
6. Apenas o DOM afetado é atualizado

React: "setState → re-renderiza componente inteiro → diffing → patch DOM"
Vue:   "mutação → trigger effects específicos → patch DOM direto"
```

### 2.2 ref() vs reactive()

```vue
<script setup lang="ts">
import { ref, reactive, toRefs, toRef } from 'vue'

// ref() — para valores primitivos (e objetos quando você quer substituir o valor inteiro)
const count = ref(0)
const name = ref('Lucas')
const user = ref<User | null>(null) // Pode ser objeto — útil quando reatribui o valor inteiro

// Acesso no script: .value obrigatório
count.value++
name.value = 'João'
user.value = { id: 1, name: 'Lucas' }

// Acesso no template: auto-unwrap (sem .value)
// <p>{{ count }}</p>  → funciona sem .value

// reactive() — para objetos/arrays quando você quer reatividade profunda
const state = reactive({
  items: [] as string[],
  loading: false,
  pagination: {
    page: 1,
    total: 0
  }
})

// Acesso direto sem .value
state.loading = true
state.items.push('novo item')       // Detectado! (Proxy intercepta métodos de array)
state.pagination.page = 2           // Reatividade profunda — objetos aninhados são reativos

// ARMADILHA: não desestruture reactive — perde a reatividade
const { loading } = state           // loading é um boolean primitivo — NÃO reativo!
const { loading } = toRefs(state)   // Agora loading é um Ref<boolean> — reativo

// ARMADILHA: não reatribua reactive inteiro
let form = reactive({ name: '', email: '' })
form = reactive({ name: 'Lucas', email: 'lucas@dev.com' }) // A referência antiga perdeu-se!
// Use Object.assign ou ref() para substituição total:
Object.assign(form, { name: 'Lucas', email: 'lucas@dev.com' })
</script>
```

```
Quando usar ref() vs reactive():

ref()      → Valores primitivos (string, number, boolean)
           → Objetos que serão substituídos inteiramente (user = null → user = {...})
           → Retorno de composables (sempre ref para preservar reatividade na desestruturação)

reactive() → Objetos/estado complexo que será mutado (state.loading = true)
           → Formulários onde você modifica propriedades individualmente
           → Nunca para primitivos (não funciona)

Regra prática: na dúvida, use ref(). É mais seguro e consistente.
O time do Vue recomenda ref() como default.
```

### 2.3 computed()

```vue
<script setup lang="ts">
import { ref, computed } from 'vue'

const items = ref<{ name: string; price: number; active: boolean }[]>([])
const searchTerm = ref('')

// Computed é cached — só recomputa quando as dependências mudam
const filteredItems = computed(() => {
  return items.value
    .filter(item => item.active)
    .filter(item => item.name.toLowerCase().includes(searchTerm.value.toLowerCase()))
})

// Computed de leitura e escrita (raro, mas útil)
const firstName = ref('Lucas')
const lastName = ref('Vieira')

const fullName = computed({
  get: () => `${firstName.value} ${lastName.value}`,
  set: (newValue: string) => {
    const [first, ...rest] = newValue.split(' ')
    firstName.value = first
    lastName.value = rest.join(' ')
  }
})

fullName.value = 'João Silva' // Dispara o setter

// Computed vs method no template:
// {{ filteredItems }}     → cached, recalcula só quando dependências mudam
// {{ getFiltered() }}     → recalcula em TODO re-render do template
</script>
```

### 2.4 watch() e watchEffect()

```vue
<script setup lang="ts">
import { ref, watch, watchEffect } from 'vue'

const userId = ref(1)
const userData = ref(null)

// watch — observa fonte(s) específica(s), acesso ao valor antigo e novo
watch(userId, async (newId, oldId) => {
  console.log(`Mudou de ${oldId} para ${newId}`)
  userData.value = await fetchUser(newId)
}, {
  immediate: true,  // Executa imediatamente (não só na mudança)
  // deep: true,     // Observa mudanças profundas em objetos (caro!)
  // once: true,     // Executa apenas uma vez (Vue 3.4+)
  // flush: 'post',  // Executa após o DOM atualizar (default: 'pre')
})

// Watch múltiplas fontes
watch(
  [userId, () => route.params.tab],  // Array de fontes (ref ou getter)
  ([newUserId, newTab], [oldUserId, oldTab]) => {
    // Ambos os valores disponíveis
  }
)

// watchEffect — rastreia dependências automaticamente (como useEffect do React,
// mas sem array de dependências manual)
const stop = watchEffect(async (onCleanup) => {
  const controller = new AbortController()

  onCleanup(() => {
    controller.abort() // Cleanup quando re-executa ou componente desmonta
  })

  const response = await fetch(`/api/users/${userId.value}`, {
    signal: controller.signal
  })
  userData.value = await response.json()
  // Vue rastreia automaticamente que este effect depende de userId.value
  // Quando userId muda, o effect re-executa (com cleanup do anterior)
})

// Parar de observar manualmente
stop()

// watchEffect vs watch:
// watchEffect → Rastreia dependências automaticamente, sem acesso ao valor antigo
// watch       → Dependências explícitas, acesso old/new, pode ser lazy (default)
</script>
```

---

## 3. Composition API

### 3.1 `<script setup>` e setup()

O `<script setup>` é uma compilação sugar que simplifica a Composition API. Tudo declarado no top-level fica automaticamente disponível no template:

```vue
<!-- Com <script setup> (recomendado) -->
<script setup lang="ts">
import { ref, onMounted } from 'vue'
import MyComponent from './MyComponent.vue'

// Tudo aqui é exposto ao template automaticamente
const count = ref(0)
const increment = () => count.value++

onMounted(() => {
  console.log('Componente montado')
})
</script>

<!-- Equivalente SEM <script setup> (verboso, raramente necessário) -->
<script lang="ts">
import { ref, onMounted, defineComponent } from 'vue'
import MyComponent from './MyComponent.vue'

export default defineComponent({
  components: { MyComponent },
  setup() {
    const count = ref(0)
    const increment = () => count.value++

    onMounted(() => {
      console.log('Componente montado')
    })

    // Precisa retornar TUDO que o template usa
    return { count, increment }
  }
})
</script>
```

### 3.2 Composables (Custom Hooks)

Composables são funções que encapsulam lógica reativa reutilizável — o equivalente aos custom hooks do React, mas com rastreamento automático de dependências:

```typescript
// composables/useFetch.ts
import { ref, watchEffect, toValue, type MaybeRefOrGetter } from 'vue'

interface UseFetchReturn<T> {
  data: Ref<T | null>
  error: Ref<string | null>
  loading: Ref<boolean>
  refresh: () => Promise<void>
}

export function useFetch<T>(url: MaybeRefOrGetter<string>): UseFetchReturn<T> {
  const data = ref<T | null>(null) as Ref<T | null>
  const error = ref<string | null>(null)
  const loading = ref(false)

  async function execute() {
    loading.value = true
    error.value = null

    try {
      const response = await fetch(toValue(url)) // toValue resolve ref, getter ou valor
      if (!response.ok) throw new Error(`HTTP ${response.status}`)
      data.value = await response.json()
    } catch (e) {
      error.value = e instanceof Error ? e.message : 'Erro desconhecido'
    } finally {
      loading.value = false
    }
  }

  watchEffect(() => {
    execute() // Re-executa quando url (se for ref/getter) mudar
  })

  return { data, error, loading, refresh: execute }
}
```

```typescript
// composables/useLocalStorage.ts
import { ref, watch, type Ref } from 'vue'

export function useLocalStorage<T>(key: string, defaultValue: T): Ref<T> {
  const stored = localStorage.getItem(key)
  const data = ref<T>(stored ? JSON.parse(stored) : defaultValue) as Ref<T>

  watch(
    data,
    (newValue) => {
      localStorage.setItem(key, JSON.stringify(newValue))
    },
    { deep: true }
  )

  return data
}

// Uso no componente:
// const theme = useLocalStorage('theme', 'dark')
// theme.value = 'light' → salva automaticamente no localStorage
```

```typescript
// composables/useDebounce.ts
import { ref, watch, type Ref } from 'vue'

export function useDebounce<T>(source: Ref<T>, delay: number = 300): Ref<T> {
  const debounced = ref(source.value) as Ref<T>

  let timeout: ReturnType<typeof setTimeout>

  watch(source, (newValue) => {
    clearTimeout(timeout)
    timeout = setTimeout(() => {
      debounced.value = newValue
    }, delay)
  })

  return debounced
}
```

### 3.3 Lifecycle Hooks

```vue
<script setup lang="ts">
import {
  onBeforeMount,
  onMounted,
  onBeforeUpdate,
  onUpdated,
  onBeforeUnmount,
  onUnmounted,
  onErrorCaptured,
  onActivated,
  onDeactivated,
} from 'vue'

// Equivalências com Options API:
// beforeCreate / created   → próprio corpo do <script setup> (executa no setup)
// beforeMount              → onBeforeMount
// mounted                  → onMounted
// beforeUpdate             → onBeforeUpdate
// updated                  → onUpdated
// beforeUnmount            → onBeforeUnmount
// unmounted                → onUnmounted

onMounted(() => {
  // DOM disponível aqui — similar a useEffect(fn, []) do React
  console.log('Componente montado, DOM acessível')
})

onUnmounted(() => {
  // Cleanup — similar ao return do useEffect do React
  console.log('Componente desmontado')
})

// Captura erros de componentes filhos (Error Boundary)
onErrorCaptured((err, instance, info) => {
  console.error('Erro capturado:', err, info)
  return false // Propagar o erro para cima? false = parar propagação
})

// Para componentes dentro de <KeepAlive>
onActivated(() => console.log('Componente reativado'))
onDeactivated(() => console.log('Componente desativado'))
</script>
```

### 3.4 provide/inject (Dependency Injection)

```vue
<!-- ParentComponent.vue -->
<script setup lang="ts">
import { provide, ref, readonly } from 'vue'

const theme = ref<'light' | 'dark'>('dark')
const toggleTheme = () => {
  theme.value = theme.value === 'dark' ? 'light' : 'dark'
}

// Provide com chave tipada (recomendado)
// InjectionKey garante type safety no inject
import type { InjectionKey } from 'vue'

export const ThemeKey: InjectionKey<{
  theme: Readonly<Ref<'light' | 'dark'>>
  toggleTheme: () => void
}> = Symbol('theme')

provide(ThemeKey, {
  theme: readonly(theme),  // readonly impede que filhos modifiquem diretamente
  toggleTheme
})
</script>

<!-- DeepChildComponent.vue -->
<script setup lang="ts">
import { inject } from 'vue'
import { ThemeKey } from './ParentComponent.vue'

// inject com fallback padrão
const { theme, toggleTheme } = inject(ThemeKey, {
  theme: ref('light'),
  toggleTheme: () => {}
})
</script>

<template>
  <div :class="theme">
    <button @click="toggleTheme">Trocar tema</button>
  </div>
</template>
```

### 3.5 defineProps e defineEmits

```vue
<!-- ChildComponent.vue -->
<script setup lang="ts">
// defineProps e defineEmits são compiler macros — não precisam de import

// Props com type-based declaration (recomendado com TypeScript)
interface Props {
  title: string
  count?: number
  items: string[]
  variant?: 'primary' | 'secondary'
}

const props = withDefaults(defineProps<Props>(), {
  count: 0,
  variant: 'primary'
})

// Emits com tipagem
interface Emits {
  (e: 'update', id: number): void
  (e: 'delete', id: number, confirm: boolean): void
  (e: 'submit'): void
}

const emit = defineEmits<Emits>()

function handleClick() {
  emit('update', 42)
  emit('delete', 42, true)
}

// defineModel (Vue 3.4+) — two-way binding simplificado
const modelValue = defineModel<string>()        // v-model padrão
const search = defineModel<string>('search')    // v-model:search

// Equivale a:
// const props = defineProps<{ modelValue: string, search: string }>()
// const emit = defineEmits<{ 'update:modelValue': [string], 'update:search': [string] }>()
</script>

<template>
  <div>
    <h2>{{ title }} ({{ count }})</h2>
    <input v-model="search" placeholder="Buscar..." />
    <ul>
      <li v-for="item in items" :key="item">{{ item }}</li>
    </ul>
    <button @click="handleClick">Ação</button>
  </div>
</template>
```

---

## 4. Componentes

### 4.1 Single File Components (SFC)

```vue
<!-- ProductCard.vue -->
<script setup lang="ts">
import { computed } from 'vue'

interface Props {
  product: {
    id: number
    name: string
    price: number
    discount: number
    image: string
  }
}

const props = defineProps<Props>()
const emit = defineEmits<{
  (e: 'add-to-cart', productId: number): void
}>()

const finalPrice = computed(() =>
  props.product.price * (1 - props.product.discount)
)

const hasDiscount = computed(() => props.product.discount > 0)
</script>

<template>
  <article class="product-card">
    <img :src="product.image" :alt="product.name" />
    <h3>{{ product.name }}</h3>
    <div class="price">
      <span v-if="hasDiscount" class="original">
        R$ {{ product.price.toFixed(2) }}
      </span>
      <span class="final">R$ {{ finalPrice.toFixed(2) }}</span>
    </div>
    <button @click="emit('add-to-cart', product.id)">
      Adicionar ao carrinho
    </button>
  </article>
</template>

<!-- Scoped CSS — estilos aplicados APENAS a este componente -->
<!-- Vue adiciona um atributo data-v-xxxxx ao HTML e ajusta os seletores -->
<style scoped>
.product-card {
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 1rem;
}

.original {
  text-decoration: line-through;
  color: var(--text-muted);
}

.final {
  font-weight: bold;
  color: var(--primary);
}

/* :deep() para estilizar componentes filhos de dentro do scoped */
:deep(.child-component-class) {
  color: red;
}

/* :slotted() para estilizar conteúdo passado via slot */
:slotted(p) {
  margin: 0;
}

/* :global() para estilos globais dentro de scoped */
:global(.app-modal) {
  z-index: 1000;
}
</style>
```

### 4.2 Slots: Named e Scoped

```vue
<!-- DataTable.vue -->
<script setup lang="ts" generic="T">
// Generic components (Vue 3.3+) — componentes genéricos tipados
interface Props {
  items: T[]
  columns: { key: keyof T; label: string }[]
  loading?: boolean
}

const props = defineProps<Props>()
</script>

<template>
  <div class="data-table">
    <!-- Slot nomeado para header customizado -->
    <header>
      <slot name="header">
        <h2>Tabela de Dados</h2>
      </slot>
    </header>

    <div v-if="loading" class="loading">
      <!-- Slot para loading state customizado -->
      <slot name="loading">
        <p>Carregando...</p>
      </slot>
    </div>

    <table v-else>
      <thead>
        <tr>
          <th v-for="col in columns" :key="String(col.key)">
            {{ col.label }}
          </th>
          <th>
            <slot name="actions-header">Ações</slot>
          </th>
        </tr>
      </thead>
      <tbody>
        <tr v-for="(item, index) in items" :key="index">
          <td v-for="col in columns" :key="String(col.key)">
            <!-- Scoped slot: expõe dados do filho para o pai customizar a renderização -->
            <slot name="cell" :item="item" :column="col" :value="item[col.key]">
              {{ item[col.key] }}
            </slot>
          </td>
          <td>
            <slot name="actions" :item="item" :index="index" />
          </td>
        </tr>
      </tbody>
    </table>

    <!-- Slot default para footer -->
    <footer>
      <slot :total="items.length" />
    </footer>
  </div>
</template>
```

```vue
<!-- Uso do DataTable com scoped slots -->
<template>
  <DataTable
    :items="users"
    :columns="[
      { key: 'name', label: 'Nome' },
      { key: 'email', label: 'E-mail' },
      { key: 'role', label: 'Papel' }
    ]"
    :loading="isLoading"
  >
    <template #header>
      <h2>Usuários do Sistema</h2>
    </template>

    <template #cell="{ item, column, value }">
      <span v-if="column.key === 'role'" :class="`badge-${value}`">
        {{ value }}
      </span>
      <span v-else>{{ value }}</span>
    </template>

    <template #actions="{ item }">
      <button @click="editUser(item)">Editar</button>
      <button @click="deleteUser(item.id)">Excluir</button>
    </template>

    <template #default="{ total }">
      <p>Total: {{ total }} usuários</p>
    </template>
  </DataTable>
</template>
```

### 4.3 Dynamic Components, Teleport e Suspense

```vue
<script setup lang="ts">
import { ref, shallowRef, defineAsyncComponent } from 'vue'
import TabA from './TabA.vue'
import TabB from './TabB.vue'

// Dynamic components — trocar componente renderizado em runtime
const tabs = { TabA, TabB } as const
const activeTab = ref<keyof typeof tabs>('TabA')

// Async components com defineAsyncComponent
const HeavyChart = defineAsyncComponent({
  loader: () => import('./HeavyChart.vue'),
  loadingComponent: () => h('div', 'Carregando gráfico...'),
  errorComponent: () => h('div', 'Erro ao carregar'),
  delay: 200,      // Mostra loading após 200ms
  timeout: 10000,  // Timeout de 10s
})

// Estado para modal
const showModal = ref(false)
</script>

<template>
  <div>
    <!-- Dynamic component com KeepAlive (preserva estado ao trocar) -->
    <nav>
      <button v-for="(_, name) in tabs" :key="name" @click="activeTab = name">
        {{ name }}
      </button>
    </nav>

    <KeepAlive :max="5">
      <component :is="tabs[activeTab]" />
    </KeepAlive>

    <!-- Suspense — boundary para componentes assíncronos -->
    <Suspense>
      <template #default>
        <HeavyChart :data="chartData" />
      </template>
      <template #fallback>
        <div class="skeleton">Carregando gráfico...</div>
      </template>
    </Suspense>

    <!-- Teleport — renderiza DOM fora da árvore de componentes -->
    <!-- O modal é filho lógico deste componente, mas DOM fica no body -->
    <Teleport to="body">
      <div v-if="showModal" class="modal-overlay" @click.self="showModal = false">
        <div class="modal-content">
          <h2>Modal teleportado para o body</h2>
          <p>Evita problemas de z-index e overflow: hidden</p>
          <button @click="showModal = false">Fechar</button>
        </div>
      </div>
    </Teleport>

    <button @click="showModal = true">Abrir modal</button>
  </div>
</template>
```

### 4.4 v-model em Componentes

```vue
<!-- RangeSlider.vue — componente com múltiplos v-model -->
<script setup lang="ts">
const min = defineModel<number>('min', { required: true })
const max = defineModel<number>('max', { required: true })

// Validação e transformação
const rating = defineModel<number>('rating', {
  default: 0,
  set(value) {
    // Clamp entre 0 e 5
    return Math.min(5, Math.max(0, value))
  }
})
</script>

<template>
  <div class="range-slider">
    <label>
      Min: <input type="range" v-model.number="min" :max="max" />
      {{ min }}
    </label>
    <label>
      Max: <input type="range" v-model.number="max" :min="min" />
      {{ max }}
    </label>
  </div>
</template>

<!-- Uso: -->
<!-- <RangeSlider v-model:min="priceMin" v-model:max="priceMax" /> -->
```

---

## 5. State Management com Pinia

### 5.1 Definindo Stores

Pinia substituiu o Vuex como state manager oficial. Sem mutations, sem modules aninhados, TypeScript nativo:

```typescript
// stores/useCartStore.ts
import { defineStore } from 'pinia'
import { computed, ref } from 'vue'

interface CartItem {
  id: number
  name: string
  price: number
  quantity: number
}

// Setup syntax (Composition API style — recomendado)
export const useCartStore = defineStore('cart', () => {
  // State
  const items = ref<CartItem[]>([])
  const coupon = ref<string | null>(null)
  const discount = ref(0)

  // Getters (computed)
  const totalItems = computed(() =>
    items.value.reduce((sum, item) => sum + item.quantity, 0)
  )

  const subtotal = computed(() =>
    items.value.reduce((sum, item) => sum + item.price * item.quantity, 0)
  )

  const total = computed(() => subtotal.value * (1 - discount.value))

  const isEmpty = computed(() => items.value.length === 0)

  // Actions
  function addItem(product: Omit<CartItem, 'quantity'>) {
    const existing = items.value.find(item => item.id === product.id)
    if (existing) {
      existing.quantity++
    } else {
      items.value.push({ ...product, quantity: 1 })
    }
  }

  function removeItem(productId: number) {
    const index = items.value.findIndex(item => item.id === productId)
    if (index > -1) items.value.splice(index, 1)
  }

  function updateQuantity(productId: number, quantity: number) {
    const item = items.value.find(item => item.id === productId)
    if (item) {
      item.quantity = Math.max(0, quantity)
      if (item.quantity === 0) removeItem(productId)
    }
  }

  async function applyCoupon(code: string) {
    const response = await fetch(`/api/coupons/${code}`)
    if (!response.ok) throw new Error('Cupom inválido')
    const data = await response.json()
    coupon.value = code
    discount.value = data.discount
  }

  function clearCart() {
    items.value = []
    coupon.value = null
    discount.value = 0
  }

  return {
    // State
    items,
    coupon,
    discount,
    // Getters
    totalItems,
    subtotal,
    total,
    isEmpty,
    // Actions
    addItem,
    removeItem,
    updateQuantity,
    applyCoupon,
    clearCart,
  }
})
```

```typescript
// Alternativa: Options syntax (mais familiar para quem vinha do Vuex)
export const useCartStore = defineStore('cart', {
  state: () => ({
    items: [] as CartItem[],
    coupon: null as string | null,
  }),
  getters: {
    totalItems: (state) => state.items.reduce((s, i) => s + i.quantity, 0),
    // Getters podem acessar outros getters via this
    subtotal(): number {
      return this.items.reduce((s, i) => s + i.price * i.quantity, 0)
    },
  },
  actions: {
    addItem(product: Omit<CartItem, 'quantity'>) {
      // this é a store — acesso direto ao state e outros actions
      const existing = this.items.find(i => i.id === product.id)
      if (existing) existing.quantity++
      else this.items.push({ ...product, quantity: 1 })
    },
  },
})
```

### 5.2 Usando Stores em Componentes

```vue
<script setup lang="ts">
import { useCartStore } from '@/stores/useCartStore'
import { storeToRefs } from 'pinia'

const cart = useCartStore()

// storeToRefs preserva reatividade ao desestruturar
// (actions não precisam de storeToRefs — são funções simples)
const { items, totalItems, total, isEmpty } = storeToRefs(cart)
const { addItem, removeItem, clearCart } = cart

// ARMADILHA: sem storeToRefs, as refs perdem reatividade:
// const { items } = cart           → NÃO reativo!
// const { items } = storeToRefs(cart)  → reativo
</script>

<template>
  <div v-if="isEmpty">Carrinho vazio</div>
  <div v-else>
    <div v-for="item in items" :key="item.id">
      {{ item.name }} x{{ item.quantity }} — R$ {{ (item.price * item.quantity).toFixed(2) }}
      <button @click="removeItem(item.id)">Remover</button>
    </div>
    <p>Total ({{ totalItems }} itens): R$ {{ total.toFixed(2) }}</p>
    <button @click="clearCart">Limpar</button>
  </div>
</template>
```

### 5.3 Plugins e Persistência

```typescript
// plugins/piniaLogger.ts
import type { PiniaPluginContext } from 'pinia'

export function piniaLogger({ store }: PiniaPluginContext) {
  store.$onAction(({ name, args, after, onError }) => {
    const start = performance.now()
    console.log(`[${store.$id}] ${name} chamado com:`, args)

    after((result) => {
      const duration = performance.now() - start
      console.log(`[${store.$id}] ${name} concluído em ${duration.toFixed(2)}ms`)
    })

    onError((error) => {
      console.error(`[${store.$id}] ${name} falhou:`, error)
    })
  })
}

// main.ts
import { createPinia } from 'pinia'
import piniaPluginPersistedstate from 'pinia-plugin-persistedstate'
import { piniaLogger } from './plugins/piniaLogger'

const pinia = createPinia()
pinia.use(piniaPluginPersistedstate)  // Persiste em localStorage automaticamente
pinia.use(piniaLogger)

// Na store, habilitar persistência:
export const useAuthStore = defineStore('auth', () => {
  const token = ref<string | null>(null)
  const user = ref<User | null>(null)
  return { token, user }
}, {
  persist: {
    pick: ['token'],              // Persiste apenas o token, não o user inteiro
    storage: sessionStorage,      // sessionStorage ao invés de localStorage
  },
})
```

### 5.4 Pinia vs Vuex

```
                Pinia              Vuex 4
──────────────────────────────────────────────────
Mutations      Não existem         Obrigatórias (síncrona)
TypeScript     Nativo, inferência  Tipagem manual, verbosa
Modules        Stores separadas    Nested modules (complexo)
DevTools       Integração total    Integração total
Composition    ref/computed        state/getters/mutations/actions
Boilerplate    Mínimo              Alto (actions→commit→mutation→state)
Bundle size    ~1.5KB              ~6KB
Hot reload     Funciona            Parcial
```

---

## 6. Vue Router

### 6.1 Configuração e Rotas

```typescript
// router/index.ts
import { createRouter, createWebHistory, type RouteRecordRaw } from 'vue-router'

const routes: RouteRecordRaw[] = [
  {
    path: '/',
    component: () => import('@/layouts/DefaultLayout.vue'),
    children: [
      {
        path: '',
        name: 'home',
        component: () => import('@/pages/HomePage.vue'), // Lazy loading
      },
      {
        path: 'products',
        name: 'products',
        component: () => import('@/pages/ProductsPage.vue'),
        // Meta fields — dados customizados por rota
        meta: { requiresAuth: false, title: 'Produtos' },
      },
      {
        path: 'products/:id',
        name: 'product-detail',
        component: () => import('@/pages/ProductDetailPage.vue'),
        // Props mode — passa params como props do componente
        props: true,
        // Props com transformação
        // props: (route) => ({ id: Number(route.params.id) }),
      },
    ],
  },
  {
    path: '/admin',
    component: () => import('@/layouts/AdminLayout.vue'),
    meta: { requiresAuth: true, role: 'admin' },
    children: [
      {
        path: '',
        name: 'admin-dashboard',
        component: () => import('@/pages/admin/DashboardPage.vue'),
      },
      {
        path: 'users',
        name: 'admin-users',
        component: () => import('@/pages/admin/UsersPage.vue'),
      },
    ],
  },
  {
    // Catch-all 404
    path: '/:pathMatch(.*)*',
    name: 'not-found',
    component: () => import('@/pages/NotFoundPage.vue'),
  },
]

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes,
  // Scroll behavior
  scrollBehavior(to, from, savedPosition) {
    if (savedPosition) return savedPosition     // Back/forward → posição salva
    if (to.hash) return { el: to.hash }         // Anchor links
    return { top: 0, behavior: 'smooth' }       // Scroll to top
  },
})

export default router
```

### 6.2 Navigation Guards

```typescript
// Guard global — roda antes de TODA navegação
router.beforeEach(async (to, from) => {
  const auth = useAuthStore()

  // Atualiza o título da página
  document.title = (to.meta.title as string) || 'Minha App'

  // Verifica autenticação
  if (to.meta.requiresAuth && !auth.isAuthenticated) {
    // Salva a rota pretendida para redirecionar após login
    return { name: 'login', query: { redirect: to.fullPath } }
  }

  // Verifica role
  if (to.meta.role && auth.user?.role !== to.meta.role) {
    return { name: 'forbidden' }
  }

  // return true ou undefined → navegação permitida
  // return false → navegação cancelada
  // return { name: 'rota' } → redirecionamento
})

// Guard por rota (inline)
const routes = [
  {
    path: '/checkout',
    component: () => import('@/pages/CheckoutPage.vue'),
    beforeEnter: (to, from) => {
      const cart = useCartStore()
      if (cart.isEmpty) return { name: 'products' }
    },
  },
]
```

```vue
<!-- Guard dentro do componente -->
<script setup lang="ts">
import { onBeforeRouteLeave } from 'vue-router'

const hasUnsavedChanges = ref(false)

// Confirmação antes de sair da página com dados não salvos
onBeforeRouteLeave((to, from) => {
  if (hasUnsavedChanges.value) {
    const answer = window.confirm('Você tem alterações não salvas. Deseja sair?')
    if (!answer) return false
  }
})
</script>
```

### 6.3 Usando o Router em Componentes

```vue
<script setup lang="ts">
import { useRoute, useRouter } from 'vue-router'

const route = useRoute()     // Informações da rota atual (reativa)
const router = useRouter()   // Instância do router (navegação programática)

// Acessar params e query
const productId = computed(() => Number(route.params.id))
const page = computed(() => Number(route.query.page) || 1)

// Navegação programática
async function goToProduct(id: number) {
  await router.push({ name: 'product-detail', params: { id } })
}

function updateFilters(filters: Record<string, string>) {
  router.replace({ query: { ...route.query, ...filters } })
}
</script>

<template>
  <nav>
    <!-- RouterLink gera <a> com href correto e class active automática -->
    <RouterLink :to="{ name: 'home' }" active-class="nav-active">
      Home
    </RouterLink>
    <RouterLink :to="{ name: 'products' }">
      Produtos
    </RouterLink>
  </nav>

  <!-- RouterView renderiza o componente da rota ativa -->
  <!-- Slot scoped dá acesso ao componente para transições -->
  <RouterView v-slot="{ Component, route: currentRoute }">
    <Transition name="fade" mode="out-in">
      <component :is="Component" :key="currentRoute.path" />
    </Transition>
  </RouterView>
</template>
```

---

## 7. Nuxt

Nuxt é para Vue o que Next.js é para React: um meta-framework com SSR, SSG, file-based routing, server routes e auto-imports. Reduz drasticamente a configuração e oferece convenções produtivas.

### 7.1 File-Based Routing

```
pages/
├── index.vue              → /
├── about.vue              → /about
├── products/
│   ├── index.vue          → /products
│   └── [id].vue           → /products/:id
├── blog/
│   ├── [...slug].vue      → /blog/* (catch-all)
│   └── [[category]].vue   → /blog/:category? (param opcional)
└── admin/
    ├── index.vue           → /admin
    └── users.vue           → /admin/users
```

```vue
<!-- pages/products/[id].vue -->
<script setup lang="ts">
// useRoute e outros composables são auto-importados no Nuxt
const route = useRoute()
const productId = computed(() => Number(route.params.id))

// useFetch — wrapper do Nuxt que faz fetch no servidor (SSR) ou no client
// Evita fetch duplicado: dados buscados no server são serializados para o client
const { data: product, pending, error } = await useFetch(
  () => `/api/products/${productId.value}`,
  {
    // Reexecuta quando productId muda
    watch: [productId],
    // Transforma os dados antes de armazenar
    transform: (data) => ({
      ...data,
      price: Number(data.price),
    }),
  }
)

// SEO — useHead é auto-importado
useHead({
  title: () => product.value?.name ?? 'Carregando...',
  meta: [
    { name: 'description', content: () => product.value?.description ?? '' },
    { property: 'og:title', content: () => product.value?.name ?? '' },
  ],
})

// useSeoMeta — shortcut para meta tags comuns
useSeoMeta({
  title: () => product.value?.name ?? '',
  ogTitle: () => product.value?.name ?? '',
  description: () => product.value?.description ?? '',
  ogDescription: () => product.value?.description ?? '',
  ogImage: () => product.value?.image ?? '',
})
</script>

<template>
  <div v-if="pending">Carregando...</div>
  <div v-else-if="error">Erro: {{ error.message }}</div>
  <article v-else-if="product">
    <h1>{{ product.name }}</h1>
    <p>R$ {{ product.price.toFixed(2) }}</p>
    <p>{{ product.description }}</p>
  </article>
</template>
```

### 7.2 Layouts e Middleware

```vue
<!-- layouts/default.vue -->
<template>
  <div class="layout">
    <AppHeader />
    <main>
      <slot />  <!-- Conteúdo da página é injetado aqui -->
    </main>
    <AppFooter />
  </div>
</template>

<!-- layouts/admin.vue -->
<template>
  <div class="admin-layout">
    <AdminSidebar />
    <div class="admin-content">
      <slot />
    </div>
  </div>
</template>
```

```vue
<!-- Usar layout específico na página -->
<script setup lang="ts">
definePageMeta({
  layout: 'admin',
  middleware: ['auth'],  // Middleware nomeado
})
</script>
```

```typescript
// middleware/auth.ts — route middleware do Nuxt
export default defineNuxtRouteMiddleware((to, from) => {
  const { loggedIn } = useUserSession()

  if (!loggedIn.value) {
    return navigateTo('/login', {
      redirectCode: 302,
      // Salva a rota para redirecionar após login
      external: false,
    })
  }
})

// middleware/admin.ts
export default defineNuxtRouteMiddleware((to) => {
  const { user } = useUserSession()

  if (user.value?.role !== 'admin') {
    return abortNavigation({
      statusCode: 403,
      message: 'Acesso negado',
    })
  }
})
```

### 7.3 Server Routes (API Routes)

```typescript
// server/api/products/index.get.ts — GET /api/products
export default defineEventHandler(async (event) => {
  const query = getQuery(event)
  const page = Number(query.page) || 1
  const limit = Number(query.limit) || 20

  // Acesso direto a banco de dados (roda no servidor)
  const products = await db.product.findMany({
    skip: (page - 1) * limit,
    take: limit,
    orderBy: { createdAt: 'desc' },
  })

  return {
    data: products,
    pagination: {
      page,
      limit,
      total: await db.product.count(),
    },
  }
})

// server/api/products/[id].get.ts — GET /api/products/:id
export default defineEventHandler(async (event) => {
  const id = Number(getRouterParam(event, 'id'))

  if (isNaN(id)) {
    throw createError({
      statusCode: 400,
      message: 'ID inválido',
    })
  }

  const product = await db.product.findUnique({ where: { id } })

  if (!product) {
    throw createError({
      statusCode: 404,
      message: 'Produto não encontrado',
    })
  }

  return product
})

// server/api/products/index.post.ts — POST /api/products
export default defineEventHandler(async (event) => {
  const body = await readBody(event)

  // Validação com zod
  const schema = z.object({
    name: z.string().min(1),
    price: z.number().positive(),
    description: z.string().optional(),
  })

  const parsed = schema.safeParse(body)
  if (!parsed.success) {
    throw createError({
      statusCode: 422,
      data: parsed.error.flatten(),
    })
  }

  const product = await db.product.create({ data: parsed.data })
  return product
})
```

### 7.4 useAsyncData vs useFetch

```vue
<script setup lang="ts">
// useFetch — shortcut para useAsyncData + $fetch
// Usa $fetch (baseado em ofetch) por padrão
const { data } = await useFetch('/api/products')

// useAsyncData — quando você precisa de mais controle
const { data, pending, error, refresh, status } = await useAsyncData(
  'products',  // Chave única para cache/deduplicação
  () => $fetch('/api/products', { query: { page: 1 } }),
  {
    // Opções avançadas
    lazy: false,            // true = não bloqueia navegação (mostra página sem dados)
    server: true,           // Executar no servidor (SSR)
    default: () => ([]),    // Valor padrão enquanto carrega
    transform: (data) => data.map(formatProduct),
    pick: ['id', 'name'],   // Só serializa essas propriedades (reduz payload SSR→client)
    watch: [page],           // Re-executa quando dependências mudam
    getCachedData: (key, nuxtApp) => {
      // Retorna dados do cache se existirem (evita refetch)
      return nuxtApp.payload.data[key] || nuxtApp.static.data[key]
    },
  }
)

// Refresh manual
const handleRefresh = () => refresh()

// useLazyFetch — versão lazy (não bloqueia navegação)
const { data: comments, pending: loadingComments } = useLazyFetch(
  () => `/api/products/${route.params.id}/comments`
)
</script>
```

### 7.5 Deployment

```
Nuxt suporta múltiplos targets de deployment via Nitro (engine de servidor):

npx nuxt build                → Node.js server (default)
npx nuxt generate             → Static site generation (SSG)

Nitro presets:
  node-server     → Node.js standalone
  vercel          → Vercel serverless
  netlify         → Netlify functions
  cloudflare      → Cloudflare Workers (edge)
  aws-lambda      → AWS Lambda
  deno            → Deno Deploy
  bun             → Bun runtime

# nuxt.config.ts
export default defineNuxtConfig({
  nitro: {
    preset: 'vercel'  // Ou detectado automaticamente pelo ambiente
  }
})
```

---

## 8. Testing

### 8.1 Vitest (Unit Tests)

Vitest é o test runner oficial do ecossistema Vue/Vite. API compatível com Jest, mas significativamente mais rápido:

```typescript
// __tests__/utils/formatPrice.test.ts
import { describe, it, expect } from 'vitest'
import { formatPrice } from '@/utils/formatPrice'

describe('formatPrice', () => {
  it('formata valores em reais', () => {
    expect(formatPrice(1999)).toBe('R$ 19,99')
    expect(formatPrice(0)).toBe('R$ 0,00')
    expect(formatPrice(10050)).toBe('R$ 100,50')
  })

  it('lida com valores negativos', () => {
    expect(formatPrice(-500)).toBe('-R$ 5,00')
  })
})
```

### 8.2 Vue Test Utils (Component Tests)

```typescript
// __tests__/components/ProductCard.test.ts
import { describe, it, expect, vi } from 'vitest'
import { mount } from '@vue/test-utils'
import ProductCard from '@/components/ProductCard.vue'

describe('ProductCard', () => {
  const defaultProps = {
    product: {
      id: 1,
      name: 'Camiseta Vue',
      price: 89.90,
      discount: 0.1,
      image: '/img/vue-shirt.jpg',
    },
  }

  it('renderiza nome e preço com desconto', () => {
    const wrapper = mount(ProductCard, { props: defaultProps })

    expect(wrapper.find('h3').text()).toBe('Camiseta Vue')
    expect(wrapper.find('.final').text()).toContain('80.91')  // 89.90 * 0.9
    expect(wrapper.find('.original').exists()).toBe(true)     // Mostra preço original
  })

  it('não mostra preço original quando não há desconto', () => {
    const wrapper = mount(ProductCard, {
      props: {
        product: { ...defaultProps.product, discount: 0 },
      },
    })

    expect(wrapper.find('.original').exists()).toBe(false)
  })

  it('emite add-to-cart com o id do produto ao clicar', async () => {
    const wrapper = mount(ProductCard, { props: defaultProps })

    await wrapper.find('button').trigger('click')

    expect(wrapper.emitted('add-to-cart')).toBeTruthy()
    expect(wrapper.emitted('add-to-cart')![0]).toEqual([1])
  })

  it('aceita slot default para conteúdo customizado', () => {
    const wrapper = mount(ProductCard, {
      props: defaultProps,
      slots: {
        default: '<span class="badge">Novo</span>',
      },
    })

    expect(wrapper.find('.badge').text()).toBe('Novo')
  })
})
```

### 8.3 Testando Composables

```typescript
// __tests__/composables/useDebounce.test.ts
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { ref, nextTick } from 'vue'
import { useDebounce } from '@/composables/useDebounce'

describe('useDebounce', () => {
  beforeEach(() => {
    vi.useFakeTimers()
  })

  afterEach(() => {
    vi.useRealTimers()
  })

  it('retorna o valor inicial imediatamente', () => {
    const source = ref('hello')
    const debounced = useDebounce(source, 300)

    expect(debounced.value).toBe('hello')
  })

  it('debounce atualizações pelo delay especificado', async () => {
    const source = ref('hello')
    const debounced = useDebounce(source, 300)

    source.value = 'world'
    await nextTick()

    // Antes do delay — valor antigo
    expect(debounced.value).toBe('hello')

    vi.advanceTimersByTime(300)
    await nextTick()

    // Após o delay — valor atualizado
    expect(debounced.value).toBe('world')
  })

  it('reseta o timer a cada mudança', async () => {
    const source = ref('a')
    const debounced = useDebounce(source, 300)

    source.value = 'b'
    await nextTick()
    vi.advanceTimersByTime(200) // 200ms < 300ms

    source.value = 'c'          // Reseta o timer
    await nextTick()
    vi.advanceTimersByTime(200) // 200ms desde 'c', total 400ms desde 'b'
    await nextTick()

    expect(debounced.value).toBe('a') // Ainda não disparou

    vi.advanceTimersByTime(100) // 300ms desde 'c'
    await nextTick()

    expect(debounced.value).toBe('c')
  })
})
```

### 8.4 Testando Stores Pinia

```typescript
// __tests__/stores/useCartStore.test.ts
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { setActivePinia, createPinia } from 'pinia'
import { useCartStore } from '@/stores/useCartStore'

describe('useCartStore', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
  })

  it('adiciona item ao carrinho', () => {
    const cart = useCartStore()

    cart.addItem({ id: 1, name: 'Produto A', price: 29.90 })

    expect(cart.items).toHaveLength(1)
    expect(cart.items[0].quantity).toBe(1)
    expect(cart.totalItems).toBe(1)
  })

  it('incrementa quantidade se item já existe', () => {
    const cart = useCartStore()

    cart.addItem({ id: 1, name: 'Produto A', price: 29.90 })
    cart.addItem({ id: 1, name: 'Produto A', price: 29.90 })

    expect(cart.items).toHaveLength(1)
    expect(cart.items[0].quantity).toBe(2)
    expect(cart.totalItems).toBe(2)
  })

  it('calcula subtotal corretamente', () => {
    const cart = useCartStore()

    cart.addItem({ id: 1, name: 'A', price: 10 })
    cart.addItem({ id: 2, name: 'B', price: 20 })
    cart.addItem({ id: 1, name: 'A', price: 10 }) // Incrementa A

    // A: 10 * 2 = 20, B: 20 * 1 = 20 → total = 40
    expect(cart.subtotal).toBe(40)
  })

  it('remove item e recalcula', () => {
    const cart = useCartStore()

    cart.addItem({ id: 1, name: 'A', price: 10 })
    cart.addItem({ id: 2, name: 'B', price: 20 })
    cart.removeItem(1)

    expect(cart.items).toHaveLength(1)
    expect(cart.subtotal).toBe(20)
  })

  it('aplica cupom com desconto', async () => {
    const cart = useCartStore()

    // Mock do fetch
    globalThis.fetch = vi.fn().mockResolvedValue({
      ok: true,
      json: () => Promise.resolve({ discount: 0.15 }),
    })

    cart.addItem({ id: 1, name: 'A', price: 100 })
    await cart.applyCoupon('DESCONTO15')

    expect(cart.coupon).toBe('DESCONTO15')
    expect(cart.discount).toBe(0.15)
    expect(cart.total).toBe(85) // 100 * (1 - 0.15)
  })

  it('limpa carrinho completamente', () => {
    const cart = useCartStore()

    cart.addItem({ id: 1, name: 'A', price: 10 })
    cart.addItem({ id: 2, name: 'B', price: 20 })
    cart.clearCart()

    expect(cart.isEmpty).toBe(true)
    expect(cart.coupon).toBeNull()
    expect(cart.total).toBe(0)
  })
})
```

### 8.5 E2E com Playwright

```typescript
// e2e/checkout.spec.ts
import { test, expect } from '@playwright/test'

test.describe('Fluxo de checkout', () => {
  test('adiciona produto ao carrinho e finaliza compra', async ({ page }) => {
    await page.goto('/products')

    // Adiciona primeiro produto ao carrinho
    const firstProduct = page.locator('.product-card').first()
    await expect(firstProduct).toBeVisible()
    await firstProduct.getByRole('button', { name: 'Adicionar ao carrinho' }).click()

    // Verifica badge do carrinho
    const cartBadge = page.getByTestId('cart-badge')
    await expect(cartBadge).toHaveText('1')

    // Navega para o carrinho
    await page.getByRole('link', { name: 'Carrinho' }).click()
    await expect(page).toHaveURL('/cart')

    // Verifica item no carrinho
    await expect(page.locator('.cart-item')).toHaveCount(1)

    // Aplica cupom
    await page.getByPlaceholder('Código do cupom').fill('DESCONTO10')
    await page.getByRole('button', { name: 'Aplicar' }).click()
    await expect(page.getByText('Cupom aplicado')).toBeVisible()

    // Prossegue para checkout
    await page.getByRole('button', { name: 'Finalizar compra' }).click()
    await expect(page).toHaveURL('/checkout')
  })

  test('impede checkout com carrinho vazio', async ({ page }) => {
    await page.goto('/checkout')

    // Deve redirecionar para produtos
    await expect(page).toHaveURL('/products')
  })
})
```

---

## Resumo: Modelo Mental Vue vs React

```
┌───────────────────────────────────────────────────────────────────┐
│                    VUE 3 — MODELO MENTAL                          │
│                                                                   │
│  Reatividade: Proxy intercepta get/set → rastreamento automático │
│                                                                   │
│  ref(value)     → .value no script, auto-unwrap no template      │
│  reactive(obj)  → acesso direto, não desestruturar               │
│  computed()     → cached, recalcula quando dependências mudam    │
│  watch()        → observa fontes explícitas, acesso old/new      │
│  watchEffect()  → rastreia dependências automaticamente          │
│                                                                   │
│  Componentes: SFC (.vue) = template + script + style (scoped)    │
│  Props:   defineProps<T>() com withDefaults()                    │
│  Events:  defineEmits<T>() → emit('event', payload)              │
│  v-model: defineModel<T>() (Vue 3.4+)                            │
│  Slots:   named (#header), scoped (#cell="{ item }")            │
│                                                                   │
│  State:   Pinia (defineStore → ref + computed + functions)       │
│  Routing: Vue Router (file-based no Nuxt)                        │
│  SSR:     Nuxt (useFetch, server routes, middleware)             │
│  Testing: Vitest + Vue Test Utils + Playwright                   │
│                                                                   │
│  React:  "Diga-me o que renderizar, eu descubro as diferenças"  │
│  Vue:    "Diga-me o que observar, eu atualizo só o necessário"   │
└───────────────────────────────────────────────────────────────────┘
```

A diferença fundamental entre Vue e React é filosófica: React é uma library de rendering com model mental funcional (componente = função pura de props para UI), enquanto Vue é um framework reativo com model mental imperativo (mute o estado, o framework atualiza o DOM). Nenhum é objetivamente superior — são trade-offs. Vue brilha em produtividade e curva de aprendizado; React brilha em ecossistema e flexibilidade. O engenheiro sênior entende ambos e escolhe baseado no contexto do projeto, do time e dos requisitos.
