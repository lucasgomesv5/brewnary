---
title: "Angular — Fundamentos e Boas Práticas"
description: "Componentes, signals, dependency injection, RxJS, routing, forms, HttpClient, standalone components e o ecossistema enterprise mais completo do frontend"
track: "frontend"
order: 16
section: "Frameworks"
priority: "medium"
tags: ["angular", "typescript", "rxjs", "signals", "dependency-injection", "standalone", "enterprise"]
prerequisites: ["typescript", "closures"]
keyTakeaways:
  - "Angular é um framework opinativo e completo: routing, forms, HTTP client, DI, testing e i18n vêm built-in — não precisa escolher bibliotecas para cada necessidade"
  - "Signals (Angular 16+) são a nova primitiva de reatividade: mais simples que RxJS para estado local, com change detection mais eficiente via signal-based components"
  - "Dependency Injection é o core do Angular: providers, injection tokens, hierarchical injectors e tree-shakable providers permitem arquiteturas modulares e testáveis"
  - "Standalone components (Angular 14+) eliminam a necessidade de NgModules, simplificando drasticamente a arquitetura e o bootstrapping"
  - "RxJS continua essencial para streams assíncronos complexos (WebSocket, event streams, polling), mas Signals cobrem a maioria dos casos de estado reativo"
---

> **Ponto chave:** Angular não é apenas mais um framework de UI — é uma plataforma completa para desenvolvimento enterprise. Enquanto React e Vue te dão liberdade de escolha (e a responsabilidade de montar o stack), Angular traz routing, forms, HTTP client, dependency injection, i18n, testing e CLI integrados. Entender o porquê de cada decisão arquitetural te permite tirar proveito real do framework ao invés de lutar contra ele.

---

## 1. Por que Angular

### 1.1 O Contexto

Angular é mantido pelo Google e usado internamente em mais de 600 projetos (Google Cloud Console, Firebase Console, Google Ads). O framework nasceu como AngularJS (2010), foi completamente reescrito como Angular 2 (2016) e desde então segue versionamento semântico com releases semestrais previsíveis.

```
Filosofia do Angular:

React:  "Aqui está uma lib de UI. Monte seu stack."
Vue:    "Aqui está um framework progressivo. Use o que precisar."
Angular: "Aqui está tudo. Siga a convenção."

Angular inclui built-in:
├── Component system com templates declarativos
├── Dependency Injection hierárquico
├── Router com lazy loading, guards, resolvers
├── Reactive Forms e Template-driven Forms
├── HttpClient com interceptors
├── i18n (internacionalização)
├── Animations (@angular/animations)
├── Testing (Karma, Jasmine, TestBed)
├── CLI (scaffolding, build, serve, test, deploy)
└── Language Service (autocomplete no IDE)
```

### 1.2 Onde Angular Brilha

```
Cenário ideal para Angular:
├── Times grandes (> 5 devs) — convenções forçam consistência
├── Aplicações enterprise com ciclo de vida longo (5+ anos)
├── Projetos que precisam de i18n, forms complexos, permissões granulares
├── Organizações que valoram uma upgrade path previsível
└── Equipes com background em Java/C# — DI e decorators são familiares

Cenário onde Angular pode ser overhead:
├── Landing pages e sites estáticos (use Astro, Next.js)
├── Protótipos rápidos e MVPs
├── Aplicações muito simples (< 10 telas)
└── Times pequenos (1-2 devs) que querem flexibilidade máxima
```

---

## 2. Componentes e Templates

### 2.1 Anatomia de um Componente

Todo componente Angular é uma classe TypeScript decorada com `@Component`. A partir do Angular 14+, componentes podem ser **standalone** — eliminando a necessidade de `NgModule`.

```typescript
// user-card.component.ts
import { Component, input, output } from '@angular/core';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-user-card',
  standalone: true,
  imports: [CommonModule],
  template: `
    <div class="card">
      <h2>{{ user().name }}</h2>
      <p>{{ user().email }}</p>
      <span class="role" [class.admin]="user().role === 'admin'">
        {{ user().role }}
      </span>
      <button (click)="onEdit.emit(user().id)">Editar</button>
    </div>
  `,
  styles: [`
    .card {
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      padding: 16px;
    }
    .admin { color: #e53e3e; font-weight: bold; }
  `]
})
export class UserCardComponent {
  // Angular 17+: input signals substituem @Input()
  user = input.required<{ id: string; name: string; email: string; role: string }>();

  // Angular 17+: output substitui @Output()
  onEdit = output<string>();
}
```

### 2.2 Template Syntax — Data Binding

Angular usa quatro formas de data binding, cada uma com uma sintaxe específica:

```typescript
@Component({
  selector: 'app-demo',
  standalone: true,
  template: `
    <!-- 1. Interpolação: component → template (texto) -->
    <h1>{{ title }}</h1>
    <p>Total: {{ items.length }} itens</p>
    <p>Preço: {{ price | currency:'BRL' }}</p>

    <!-- 2. Property binding: component → template (propriedade DOM) -->
    <img [src]="imageUrl" [alt]="imageDescription">
    <button [disabled]="isLoading">Salvar</button>
    <div [style.background-color]="bgColor">Conteúdo</div>
    <input [attr.aria-label]="label">

    <!-- 3. Event binding: template → component -->
    <button (click)="handleClick($event)">Clique</button>
    <input (input)="onInput($event)" (keyup.enter)="onSubmit()">
    <form (ngSubmit)="submitForm()">...</form>

    <!-- 4. Two-way binding: bidirecional -->
    <input [(ngModel)]="searchQuery">
    <!-- Equivalente a: [ngModel]="searchQuery" (ngModelChange)="searchQuery = $event" -->
  `
})
export class DemoComponent {
  title = 'Minha Aplicação';
  items = [1, 2, 3];
  price = 49.90;
  imageUrl = '/assets/logo.png';
  imageDescription = 'Logo';
  isLoading = false;
  bgColor = '#f0f0f0';
  label = 'Campo de busca';
  searchQuery = '';

  handleClick(event: MouseEvent) {
    console.log('Clicou em:', event.target);
  }

  onInput(event: Event) {
    const value = (event.target as HTMLInputElement).value;
    console.log('Digitou:', value);
  }

  onSubmit() {
    console.log('Enviou:', this.searchQuery);
  }

  submitForm() {
    // lógica do form
  }
}
```

### 2.3 Novo Control Flow (Angular 17+)

Angular 17 introduziu uma sintaxe de control flow nativa no template, substituindo as diretivas `*ngIf`, `*ngFor` e `*ngSwitch`:

```html
<!-- ANTES (diretivas estruturais): -->
<div *ngIf="user; else noUser">
  <p>{{ user.name }}</p>
</div>
<ng-template #noUser>
  <p>Nenhum usuário</p>
</ng-template>

<ul>
  <li *ngFor="let item of items; trackBy: trackById">
    {{ item.name }}
  </li>
</ul>

<!-- DEPOIS (control flow nativo — Angular 17+): -->

<!-- @if / @else if / @else -->
@if (user()) {
  <div>
    <p>{{ user().name }}</p>
  </div>
} @else {
  <p>Nenhum usuário</p>
}

<!-- @for com track obrigatório -->
<ul>
  @for (item of items(); track item.id) {
    <li>{{ item.name }}</li>
  } @empty {
    <li>Nenhum item encontrado</li>
  }
</ul>

<!-- @switch -->
@switch (user().role) {
  @case ('admin') {
    <app-admin-panel />
  }
  @case ('editor') {
    <app-editor-panel />
  }
  @default {
    <app-viewer-panel />
  }
}

<!-- @defer — lazy loading declarativo de componentes (Angular 17+) -->
@defer (on viewport) {
  <app-heavy-chart [data]="chartData()" />
} @placeholder {
  <div class="skeleton">Carregando gráfico...</div>
} @loading (minimum 500ms) {
  <app-spinner />
} @error {
  <p>Erro ao carregar o gráfico</p>
}
```

O `@defer` é uma das features mais poderosas: carrega componentes **sob demanda** com triggers declarativos (`on viewport`, `on idle`, `on interaction`, `on hover`, `on timer`, `when condition`).

---

## 3. Signals — A Nova Primitiva de Reatividade

### 3.1 O Problema que Signals Resolvem

O change detection padrão do Angular (Zone.js) intercepta **todas** as operações assíncronas e re-verifica a árvore inteira de componentes. Com Signals, o Angular sabe **exatamente** quais componentes dependem de quais dados — e atualiza somente esses.

```typescript
import { Component, signal, computed, effect } from '@angular/core';

@Component({
  selector: 'app-counter',
  standalone: true,
  template: `
    <div>
      <p>Contagem: {{ count() }}</p>
      <p>Dobro: {{ doubled() }}</p>
      <button (click)="increment()">+1</button>
      <button (click)="decrement()">-1</button>
      <button (click)="reset()">Reset</button>
    </div>
  `
})
export class CounterComponent {
  // signal() — estado reativo (writable)
  count = signal(0);

  // computed() — derivação reativa (readonly, recalcula quando dependências mudam)
  doubled = computed(() => this.count() * 2);

  // effect() — side effect reativo (roda quando dependências mudam)
  private logEffect = effect(() => {
    console.log(`Contagem mudou para: ${this.count()}`);
    // Angular rastreia automaticamente que este effect depende de count
  });

  increment() {
    this.count.update(c => c + 1);  // update com função
  }

  decrement() {
    this.count.set(this.count() - 1);  // set com valor direto
  }

  reset() {
    this.count.set(0);
  }
}
```

### 3.2 Input Signals, Output e Model

Angular 17+ introduziu APIs baseadas em signals para comunicação entre componentes:

```typescript
import { Component, input, output, model, computed } from '@angular/core';

@Component({
  selector: 'app-product-filter',
  standalone: true,
  template: `
    <div>
      <label>
        Categoria:
        <select [value]="category()" (change)="onCategoryChange($event)">
          @for (cat of categories(); track cat) {
            <option [value]="cat">{{ cat }}</option>
          }
        </select>
      </label>

      <label>
        Preço máximo: R$ {{ maxPrice() }}
        <input
          type="range"
          [min]="0"
          [max]="1000"
          [value]="maxPrice()"
          (input)="maxPrice.set(+$any($event.target).value)"
        />
      </label>

      <p>{{ activeFilterCount() }} filtros ativos</p>
    </div>
  `
})
export class ProductFilterComponent {
  // input() — substitui @Input(), é um signal readonly
  categories = input<string[]>([]);

  // input.required() — obrigatório, erro de compilação se não for passado
  category = input.required<string>();

  // model() — two-way binding com signal (substitui @Input() + @Output())
  maxPrice = model(500);
  // No parent: <app-product-filter [(maxPrice)]="selectedMaxPrice" />

  // output() — substitui @Output() com EventEmitter
  filterChanged = output<{ category: string; maxPrice: number }>();

  // computed sobre inputs (que são signals)
  activeFilterCount = computed(() => {
    let count = 0;
    if (this.category() !== 'all') count++;
    if (this.maxPrice() < 1000) count++;
    return count;
  });

  onCategoryChange(event: Event) {
    const value = (event.target as HTMLSelectElement).value;
    this.filterChanged.emit({ category: value, maxPrice: this.maxPrice() });
  }
}
```

### 3.3 Signals vs RxJS — Quando Usar Cada

```
┌─────────────────────────────────┬──────────────────────────────────────┐
│          SIGNALS                │            RxJS OBSERVABLES          │
├─────────────────────────────────┼──────────────────────────────────────┤
│ Estado síncrono e local         │ Streams assíncronos complexos        │
│ Valor sempre disponível (.())   │ Emite valores ao longo do tempo      │
│ Sem conceito de "erro" ou       │ next, error, complete                │
│ "completion"                    │                                      │
│ Recalcula automaticamente       │ Operadores poderosos (switchMap,     │
│ (computed)                      │ debounceTime, combineLatest, etc.)   │
│ Side effects com effect()       │ subscribe() com cleanup              │
│                                 │                                      │
│ USE PARA:                       │ USE PARA:                            │
│ • Estado de componente          │ • HTTP requests (HttpClient retorna  │
│ • Props (input/output)          │   Observable)                        │
│ • Estado de UI (loading, etc.)  │ • WebSocket streams                  │
│ • Derivações simples            │ • Event streams com debounce/throttle│
│ • Formulários simples           │ • Polling e retry com backoff        │
│                                 │ • Composição de múltiplos streams    │
└─────────────────────────────────┴──────────────────────────────────────┘
```

```typescript
// Convertendo entre Signals e Observables
import { toSignal, toObservable } from '@angular/core/rxjs-interop';
import { Subject, debounceTime, distinctUntilChanged, switchMap } from 'rxjs';

@Component({
  selector: 'app-search',
  standalone: true,
  template: `
    <input (input)="onSearch($event)" placeholder="Buscar..." />
    @if (results()) {
      @for (result of results(); track result.id) {
        <div>{{ result.name }}</div>
      }
    }
  `
})
export class SearchComponent {
  private searchSubject = new Subject<string>();
  private http = inject(HttpClient);

  // Observable → Signal (com toSignal)
  results = toSignal(
    this.searchSubject.pipe(
      debounceTime(300),
      distinctUntilChanged(),
      switchMap(query => this.http.get<Result[]>(`/api/search?q=${query}`))
    ),
    { initialValue: [] }
  );

  onSearch(event: Event) {
    const query = (event.target as HTMLInputElement).value;
    this.searchSubject.next(query);
  }
}
```

---

## 4. Dependency Injection

### 4.1 O Conceito Core

Dependency Injection (DI) é o coração do Angular. Ao invés de instanciar dependências diretamente, você declara o que precisa e o framework resolve.

```typescript
// SEM DI (acoplamento direto):
class UserComponent {
  private service = new UserService(new HttpClient(/* ... */));
  // Difícil de testar, impossível de substituir
}

// COM DI (Angular):
class UserComponent {
  private service = inject(UserService);
  // Angular resolve UserService e todas as suas dependências
  // Em testes, substitui por mock automaticamente
}
```

### 4.2 Providers e inject()

```typescript
import { Injectable, inject } from '@angular/core';
import { HttpClient } from '@angular/common/http';

// providedIn: 'root' → singleton global, tree-shakable
@Injectable({ providedIn: 'root' })
export class UserService {
  private http = inject(HttpClient);
  private baseUrl = '/api/users';

  getAll() {
    return this.http.get<User[]>(this.baseUrl);
  }

  getById(id: string) {
    return this.http.get<User>(`${this.baseUrl}/${id}`);
  }

  create(user: CreateUserDTO) {
    return this.http.post<User>(this.baseUrl, user);
  }

  update(id: string, changes: Partial<User>) {
    return this.http.patch<User>(`${this.baseUrl}/${id}`, changes);
  }

  delete(id: string) {
    return this.http.delete<void>(`${this.baseUrl}/${id}`);
  }
}
```

### 4.3 Injection Tokens e Factory Providers

```typescript
import { InjectionToken, inject, Provider } from '@angular/core';

// InjectionToken para valores que não são classes
export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');
export const APP_CONFIG = new InjectionToken<AppConfig>('APP_CONFIG');

export interface AppConfig {
  apiUrl: string;
  environment: 'development' | 'staging' | 'production';
  features: {
    darkMode: boolean;
    betaFeatures: boolean;
  };
}

// Providers no bootstrap da aplicação
export const appConfig: ApplicationConfig = {
  providers: [
    // Valor simples
    { provide: API_BASE_URL, useValue: 'https://api.example.com' },

    // Factory provider — lógica na criação
    {
      provide: APP_CONFIG,
      useFactory: () => {
        const isProd = window.location.hostname !== 'localhost';
        return {
          apiUrl: isProd ? 'https://api.prod.com' : 'http://localhost:3000',
          environment: isProd ? 'production' : 'development',
          features: {
            darkMode: true,
            betaFeatures: !isProd,
          },
        } satisfies AppConfig;
      },
    },

    // Class provider — substituir implementação
    { provide: LoggerService, useClass: environment.production ? ProdLogger : DevLogger },

    // Existing provider — alias
    { provide: AbstractLogger, useExisting: LoggerService },
  ],
};
```

### 4.4 Hierarchical Injectors

O Angular mantém uma **árvore de injectors** que espelha a árvore de componentes. Isso permite escopar serviços a subárvores específicas:

```
                      ┌──────────────────┐
                      │  Root Injector   │  ← providedIn: 'root'
                      │  (singletons)    │    UserService, HttpClient
                      └────────┬─────────┘
                               │
              ┌────────────────┼────────────────┐
              │                │                │
     ┌────────▼──────┐  ┌─────▼──────┐  ┌──────▼─────┐
     │  AdminModule  │  │ UserModule │  │ SharedModule│
     │   Injector    │  │  Injector  │  │  Injector   │
     └────────┬──────┘  └─────┬──────┘  └────────────┘
              │               │
     ┌────────▼──────┐  ┌─────▼──────┐
     │ AdminComponent│  │UserComponent│
     │   Injector    │  │  Injector   │  ← providers: [FormStateService]
     └───────────────┘  └────────────┘    (instância POR componente)
```

```typescript
// Serviço escopado ao componente — cada instância do componente
// recebe uma instância SEPARADA do serviço
@Component({
  selector: 'app-todo-list',
  standalone: true,
  providers: [TodoStateService],  // Instância por componente
  template: `
    @for (todo of state.todos(); track todo.id) {
      <app-todo-item [todo]="todo" />
    }
  `
})
export class TodoListComponent {
  state = inject(TodoStateService);
}

// Se houver 3 <app-todo-list> na página, haverá 3 instâncias de TodoStateService
```

---

## 5. Routing

### 5.1 Configuração de Rotas com Standalone

```typescript
// app.routes.ts
import { Routes } from '@angular/router';

export const routes: Routes = [
  {
    path: '',
    redirectTo: 'dashboard',
    pathMatch: 'full',
  },
  {
    path: 'dashboard',
    loadComponent: () =>
      import('./pages/dashboard/dashboard.component').then(m => m.DashboardComponent),
    title: 'Dashboard',
  },
  {
    path: 'users',
    // Lazy loading de rotas filhas
    loadChildren: () =>
      import('./pages/users/users.routes').then(m => m.USER_ROUTES),
    canActivate: [authGuard],
  },
  {
    path: 'login',
    loadComponent: () =>
      import('./pages/login/login.component').then(m => m.LoginComponent),
    title: 'Login',
  },
  {
    path: '**',
    loadComponent: () =>
      import('./pages/not-found/not-found.component').then(m => m.NotFoundComponent),
    title: 'Página não encontrada',
  },
];

// app.config.ts
import { ApplicationConfig } from '@angular/core';
import { provideRouter, withComponentInputBinding } from '@angular/router';
import { routes } from './app.routes';

export const appConfig: ApplicationConfig = {
  providers: [
    provideRouter(
      routes,
      withComponentInputBinding(), // Permite receber route params como inputs
    ),
  ],
};
```

### 5.2 Rotas Filhas e Nested Routes

```typescript
// pages/users/users.routes.ts
import { Routes } from '@angular/router';

export const USER_ROUTES: Routes = [
  {
    path: '',
    loadComponent: () =>
      import('./user-list/user-list.component').then(m => m.UserListComponent),
    title: 'Usuários',
  },
  {
    path: ':id',
    loadComponent: () =>
      import('./user-detail/user-detail.component').then(m => m.UserDetailComponent),
    title: 'Detalhes do Usuário',
    resolve: {
      user: userResolver,
    },
  },
  {
    path: ':id/edit',
    loadComponent: () =>
      import('./user-edit/user-edit.component').then(m => m.UserEditComponent),
    canDeactivate: [unsavedChangesGuard],
  },
];
```

### 5.3 Guards Funcionais (Angular 15+)

```typescript
// auth.guard.ts
import { inject } from '@angular/core';
import { CanActivateFn, Router } from '@angular/router';
import { AuthService } from '../services/auth.service';

// Guard funcional — mais simples que a interface CanActivate
export const authGuard: CanActivateFn = (route, state) => {
  const auth = inject(AuthService);
  const router = inject(Router);

  if (auth.isAuthenticated()) {
    return true;
  }

  // Redireciona para login preservando a URL original
  return router.createUrlTree(['/login'], {
    queryParams: { returnUrl: state.url },
  });
};

// Guard de role
export const roleGuard: CanActivateFn = (route) => {
  const auth = inject(AuthService);
  const requiredRoles = route.data['roles'] as string[];

  return requiredRoles.some(role => auth.hasRole(role));
};

// Guard de unsaved changes
export const unsavedChangesGuard: CanDeactivateFn<{ hasUnsavedChanges: () => boolean }> = (component) => {
  if (component.hasUnsavedChanges()) {
    return confirm('Você tem alterações não salvas. Deseja sair?');
  }
  return true;
};

// Resolver funcional
export const userResolver: ResolveFn<User> = (route) => {
  const userService = inject(UserService);
  const id = route.paramMap.get('id')!;
  return userService.getById(id);
};

// Uso nas rotas:
{
  path: 'admin',
  loadComponent: () => import('./admin.component').then(m => m.AdminComponent),
  canActivate: [authGuard, roleGuard],
  data: { roles: ['admin', 'super-admin'] },
}
```

---

## 6. Forms

### 6.1 Reactive Forms

Reactive Forms são a abordagem recomendada para formulários complexos. O modelo é definido no componente, dando controle total sobre validação e estado.

```typescript
import { Component, inject } from '@angular/core';
import { ReactiveFormsModule, FormBuilder, Validators, AbstractControl, ValidationErrors } from '@angular/forms';

@Component({
  selector: 'app-user-form',
  standalone: true,
  imports: [ReactiveFormsModule],
  template: `
    <form [formGroup]="form" (ngSubmit)="onSubmit()">
      <div>
        <label for="name">Nome</label>
        <input id="name" formControlName="name" />
        @if (form.controls.name.errors?.['required'] && form.controls.name.touched) {
          <span class="error">Nome é obrigatório</span>
        }
        @if (form.controls.name.errors?.['minlength']) {
          <span class="error">Mínimo 3 caracteres</span>
        }
      </div>

      <div>
        <label for="email">Email</label>
        <input id="email" formControlName="email" type="email" />
        @if (form.controls.email.errors?.['email'] && form.controls.email.touched) {
          <span class="error">Email inválido</span>
        }
      </div>

      <div>
        <label for="password">Senha</label>
        <input id="password" formControlName="password" type="password" />
        @if (form.controls.password.errors?.['strongPassword']) {
          <span class="error">
            {{ form.controls.password.errors?.['strongPassword'].message }}
          </span>
        }
      </div>

      <div>
        <label for="confirmPassword">Confirmar Senha</label>
        <input id="confirmPassword" formControlName="confirmPassword" type="password" />
        @if (form.errors?.['passwordMismatch'] && form.controls.confirmPassword.touched) {
          <span class="error">Senhas não conferem</span>
        }
      </div>

      <!-- FormArray: campos dinâmicos -->
      <div formArrayName="phones">
        <h3>Telefones</h3>
        @for (phone of phonesArray.controls; track $index) {
          <div>
            <input [formControlName]="$index" placeholder="(11) 99999-9999" />
            <button type="button" (click)="removePhone($index)">Remover</button>
          </div>
        }
        <button type="button" (click)="addPhone()">Adicionar telefone</button>
      </div>

      <button type="submit" [disabled]="form.invalid || form.pristine">
        Salvar
      </button>
    </form>
  `
})
export class UserFormComponent {
  private fb = inject(FormBuilder);

  form = this.fb.group({
    name: ['', [Validators.required, Validators.minLength(3)]],
    email: ['', [Validators.required, Validators.email]],
    password: ['', [Validators.required, strongPasswordValidator]],
    confirmPassword: ['', [Validators.required]],
    phones: this.fb.array<string>(['']),
  }, {
    validators: [passwordMatchValidator],
  });

  get phonesArray() {
    return this.form.controls.phones;
  }

  addPhone() {
    this.phonesArray.push(this.fb.control(''));
  }

  removePhone(index: number) {
    this.phonesArray.removeAt(index);
  }

  onSubmit() {
    if (this.form.valid) {
      console.log('Form value:', this.form.getRawValue());
    } else {
      // Marca todos os campos como touched para mostrar erros
      this.form.markAllAsTouched();
    }
  }
}

// Validator customizado (função pura)
function strongPasswordValidator(control: AbstractControl): ValidationErrors | null {
  const value = control.value as string;
  if (!value) return null;

  const hasUpperCase = /[A-Z]/.test(value);
  const hasLowerCase = /[a-z]/.test(value);
  const hasNumber = /\d/.test(value);
  const hasMinLength = value.length >= 8;

  if (hasUpperCase && hasLowerCase && hasNumber && hasMinLength) {
    return null; // válido
  }

  return {
    strongPassword: {
      message: 'Senha deve ter pelo menos 8 caracteres, uma maiúscula, uma minúscula e um número',
    },
  };
}

// Validator de grupo (cross-field)
function passwordMatchValidator(group: AbstractControl): ValidationErrors | null {
  const password = group.get('password')?.value;
  const confirmPassword = group.get('confirmPassword')?.value;

  if (password && confirmPassword && password !== confirmPassword) {
    return { passwordMismatch: true };
  }
  return null;
}
```

### 6.2 Typed Forms (Angular 14+)

A partir do Angular 14, Reactive Forms são **fully typed** — o compilador sabe o tipo de cada control:

```typescript
// O TypeScript infere automaticamente os tipos do FormGroup:
const form = this.fb.group({
  name: ['', Validators.required],       // FormControl<string | null>
  age: [0, Validators.min(18)],          // FormControl<number | null>
  active: [false],                        // FormControl<boolean | null>
  tags: this.fb.array(['angular']),       // FormArray<FormControl<string | null>>
});

// form.value é tipado:
// { name: string | null; age: number | null; active: boolean | null; tags: (string | null)[] }

// form.getRawValue() retorna sem null nos optionals:
// { name: string; age: number; active: boolean; tags: string[] }

// NonNullable form controls:
const strictForm = this.fb.nonNullable.group({
  name: [''],   // FormControl<string> (sem null!)
  age: [0],     // FormControl<number> (sem null!)
});
```

---

## 7. HTTP e RxJS

### 7.1 HttpClient

```typescript
import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpParams, HttpHeaders } from '@angular/common/http';
import { Observable, catchError, retry, map, throwError } from 'rxjs';

@Injectable({ providedIn: 'root' })
export class ProductService {
  private http = inject(HttpClient);
  private baseUrl = '/api/products';

  getAll(filters?: { category?: string; minPrice?: number }): Observable<Product[]> {
    let params = new HttpParams();
    if (filters?.category) {
      params = params.set('category', filters.category);
    }
    if (filters?.minPrice) {
      params = params.set('minPrice', filters.minPrice.toString());
    }

    return this.http.get<Product[]>(this.baseUrl, { params }).pipe(
      retry({ count: 2, delay: 1000 }),  // Retry 2x com 1s de intervalo
      catchError(this.handleError),
    );
  }

  create(product: CreateProductDTO): Observable<Product> {
    return this.http.post<Product>(this.baseUrl, product).pipe(
      catchError(this.handleError),
    );
  }

  upload(id: string, file: File): Observable<{ progress: number } | Product> {
    const formData = new FormData();
    formData.append('image', file);

    return this.http.put<Product>(`${this.baseUrl}/${id}/image`, formData, {
      reportProgress: true,
      observe: 'events',
    }).pipe(
      map(event => {
        if (event.type === HttpEventType.UploadProgress) {
          return { progress: Math.round((event.loaded / (event.total ?? 1)) * 100) };
        }
        return event as any;
      }),
    );
  }

  private handleError(error: HttpErrorResponse): Observable<never> {
    let message = 'Erro desconhecido';
    if (error.status === 0) {
      message = 'Sem conexão com o servidor';
    } else if (error.status === 404) {
      message = 'Recurso não encontrado';
    } else if (error.status === 422) {
      message = 'Dados inválidos';
    } else if (error.status >= 500) {
      message = 'Erro interno do servidor';
    }
    console.error(`[ProductService] ${error.status}: ${message}`, error);
    return throwError(() => new Error(message));
  }
}
```

### 7.2 Interceptors Funcionais (Angular 15+)

```typescript
// auth.interceptor.ts
import { HttpInterceptorFn, HttpErrorResponse } from '@angular/common/http';
import { inject } from '@angular/core';
import { catchError, throwError } from 'rxjs';

export const authInterceptor: HttpInterceptorFn = (req, next) => {
  const auth = inject(AuthService);
  const token = auth.getToken();

  if (token) {
    const cloned = req.clone({
      setHeaders: { Authorization: `Bearer ${token}` },
    });
    return next(cloned);
  }

  return next(req);
};

// logging.interceptor.ts
export const loggingInterceptor: HttpInterceptorFn = (req, next) => {
  const start = performance.now();

  return next(req).pipe(
    tap({
      next: () => {
        const duration = Math.round(performance.now() - start);
        console.log(`[HTTP] ${req.method} ${req.url} → ${duration}ms`);
      },
      error: (error: HttpErrorResponse) => {
        const duration = Math.round(performance.now() - start);
        console.error(`[HTTP] ${req.method} ${req.url} → ${error.status} (${duration}ms)`);
      },
    }),
  );
};

// Registrar interceptors no bootstrap
export const appConfig: ApplicationConfig = {
  providers: [
    provideHttpClient(
      withInterceptors([authInterceptor, loggingInterceptor]),
    ),
  ],
};
```

### 7.3 RxJS Patterns Essenciais

```typescript
import {
  Subject, BehaviorSubject, Observable,
  switchMap, mergeMap, concatMap, exhaustMap,
  debounceTime, distinctUntilChanged, takeUntilDestroyed,
  catchError, retry, shareReplay, combineLatest, of,
} from 'rxjs';
import { DestroyRef, inject } from '@angular/core';

// 1. FLATTENING OPERATORS — o mais importante do RxJS
//    Controlam como Observables internos são gerenciados:

// switchMap: CANCELA o anterior quando um novo chega
// Use para: autocomplete, busca, navegação
this.searchQuery$.pipe(
  debounceTime(300),
  distinctUntilChanged(),
  switchMap(query => this.http.get(`/api/search?q=${query}`))
  // Se o usuário digitar "ang", "angu", "angul", "angular",
  // somente a request para "angular" será completada.
  // As anteriores são canceladas automaticamente.
);

// mergeMap: roda TODAS em paralelo
// Use para: ações independentes (salvar múltiplos itens)
this.items$.pipe(
  mergeMap(item => this.http.post('/api/items', item))
  // Todas as requests rodam simultaneamente
);

// concatMap: roda em SEQUÊNCIA (espera uma terminar para iniciar a próxima)
// Use para: operações que devem ser ordenadas
this.actions$.pipe(
  concatMap(action => this.http.post('/api/actions', action))
  // Garante que ação 1 completa antes de iniciar ação 2
);

// exhaustMap: IGNORA novos enquanto o atual está em andamento
// Use para: submit de form (evita duplo click)
this.submitClick$.pipe(
  exhaustMap(() => this.http.post('/api/submit', this.form.value))
  // Se o usuário clicar 5x rápido, somente a primeira request é feita.
  // As outras são ignoradas.
);

// 2. UNSUBSCRIBE PATTERN — takeUntilDestroyed (Angular 16+)
@Component({ /* ... */ })
export class DashboardComponent {
  private destroyRef = inject(DestroyRef);

  ngOnInit() {
    this.dataService.getStream().pipe(
      takeUntilDestroyed(this.destroyRef), // Unsubscribe automático ao destruir
    ).subscribe(data => {
      this.processData(data);
    });
  }
}

// 3. CACHE COM shareReplay
@Injectable({ providedIn: 'root' })
export class ConfigService {
  private http = inject(HttpClient);

  // shareReplay(1) cacheia o último valor e compartilha entre subscribers
  config$ = this.http.get<AppConfig>('/api/config').pipe(
    shareReplay(1),
    catchError(() => of(DEFAULT_CONFIG)),
  );
}
```

---

## 8. Testing e Boas Práticas

### 8.1 TestBed e Component Testing

```typescript
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { provideHttpClientTesting, HttpTestingController } from '@angular/common/http/testing';
import { provideHttpClient } from '@angular/common/http';

describe('UserListComponent', () => {
  let component: UserListComponent;
  let fixture: ComponentFixture<UserListComponent>;
  let httpMock: HttpTestingController;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [UserListComponent], // Standalone components vão em imports
      providers: [
        provideHttpClient(),
        provideHttpClientTesting(),
      ],
    }).compileComponents();

    fixture = TestBed.createComponent(UserListComponent);
    component = fixture.componentInstance;
    httpMock = TestBed.inject(HttpTestingController);
  });

  afterEach(() => {
    httpMock.verify(); // Verifica que não há requests pendentes
  });

  it('should load users on init', () => {
    const mockUsers: User[] = [
      { id: '1', name: 'Alice', email: 'alice@test.com', role: 'admin' },
      { id: '2', name: 'Bob', email: 'bob@test.com', role: 'user' },
    ];

    fixture.detectChanges(); // Dispara ngOnInit

    const req = httpMock.expectOne('/api/users');
    expect(req.request.method).toBe('GET');
    req.flush(mockUsers); // Responde com dados mock

    fixture.detectChanges(); // Atualiza o template

    const userElements = fixture.nativeElement.querySelectorAll('.user-card');
    expect(userElements.length).toBe(2);
    expect(userElements[0].textContent).toContain('Alice');
  });

  it('should show error message on failure', () => {
    fixture.detectChanges();

    const req = httpMock.expectOne('/api/users');
    req.flush('Server Error', { status: 500, statusText: 'Internal Server Error' });

    fixture.detectChanges();

    const errorEl = fixture.nativeElement.querySelector('.error-message');
    expect(errorEl).toBeTruthy();
    expect(errorEl.textContent).toContain('Erro');
  });
});
```

### 8.2 Service Testing

```typescript
describe('UserService', () => {
  let service: UserService;
  let httpMock: HttpTestingController;

  beforeEach(() => {
    TestBed.configureTestingModule({
      providers: [
        UserService,
        provideHttpClient(),
        provideHttpClientTesting(),
      ],
    });

    service = TestBed.inject(UserService);
    httpMock = TestBed.inject(HttpTestingController);
  });

  it('should create user and return the created entity', () => {
    const newUser: CreateUserDTO = { name: 'Alice', email: 'alice@test.com' };
    const createdUser: User = { id: '1', ...newUser, role: 'user' };

    service.create(newUser).subscribe(user => {
      expect(user).toEqual(createdUser);
      expect(user.id).toBeDefined();
    });

    const req = httpMock.expectOne('/api/users');
    expect(req.request.method).toBe('POST');
    expect(req.request.body).toEqual(newUser);
    req.flush(createdUser);
  });

  it('should retry failed requests twice', () => {
    service.getAll().subscribe({
      next: (users) => expect(users.length).toBe(1),
    });

    // Primeira tentativa falha
    httpMock.expectOne('/api/users').flush('Error', { status: 500, statusText: 'Error' });

    // Retry 1 falha
    httpMock.expectOne('/api/users').flush('Error', { status: 500, statusText: 'Error' });

    // Retry 2 sucede
    httpMock.expectOne('/api/users').flush([{ id: '1', name: 'Alice' }]);
  });
});
```

### 8.3 Estrutura de Projeto e Boas Práticas

```
src/
├── app/
│   ├── app.component.ts            # Root component
│   ├── app.config.ts                # ApplicationConfig (providers)
│   ├── app.routes.ts                # Rotas raiz
│   │
│   ├── core/                        # Serviços singleton, guards, interceptors
│   │   ├── interceptors/
│   │   │   ├── auth.interceptor.ts
│   │   │   └── error.interceptor.ts
│   │   ├── guards/
│   │   │   ├── auth.guard.ts
│   │   │   └── role.guard.ts
│   │   └── services/
│   │       ├── auth.service.ts
│   │       └── notification.service.ts
│   │
│   ├── shared/                      # Componentes, pipes, directives reutilizáveis
│   │   ├── components/
│   │   │   ├── button/
│   │   │   ├── modal/
│   │   │   └── data-table/
│   │   ├── pipes/
│   │   │   └── relative-time.pipe.ts
│   │   └── directives/
│   │       └── tooltip.directive.ts
│   │
│   ├── features/                    # Feature modules (lazy loaded)
│   │   ├── dashboard/
│   │   │   ├── dashboard.component.ts
│   │   │   ├── dashboard.component.html
│   │   │   ├── dashboard.component.spec.ts
│   │   │   └── components/          # Componentes internos da feature
│   │   │       └── stats-card/
│   │   │
│   │   └── users/
│   │       ├── users.routes.ts      # Rotas da feature
│   │       ├── services/
│   │       │   └── user.service.ts
│   │       ├── models/
│   │       │   └── user.model.ts
│   │       └── components/
│   │           ├── user-list/
│   │           └── user-form/
│   │
│   └── layouts/                     # Layouts (shell com sidebar, header, etc.)
│       ├── main-layout/
│       └── auth-layout/
│
├── environments/
│   ├── environment.ts
│   └── environment.prod.ts
│
└── styles/
    └── global.scss
```

### 8.4 Performance

```typescript
// 1. Change Detection Strategy: OnPush
// Componentes com OnPush só re-verificam quando:
//   - Um @Input muda por referência
//   - Um event binding do template dispara
//   - Um Observable com async pipe emite
//   - Um signal lido no template muda
//   - markForCheck() é chamado manualmente
@Component({
  selector: 'app-user-card',
  standalone: true,
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `<div>{{ user().name }}</div>`
})
export class UserCardComponent {
  user = input.required<User>();
}

// 2. track em @for (equivalente ao trackBy do *ngFor)
// Sem track, Angular recria todos os DOM nodes ao reordenar/filtrar
@for (item of items(); track item.id) {
  <app-item [data]="item" />
}

// 3. @defer para lazy loading de componentes pesados
@defer (on viewport) {
  <app-analytics-dashboard />
}

// 4. preloadingStrategy para rotas
provideRouter(
  routes,
  withPreloading(PreloadAllModules), // Pré-carrega rotas em background
)

// 5. Signals eliminam Zone.js overhead
// Com signals, o Angular sabe exatamente quais componentes atualizar
// Futuro: zoneless Angular (experimental no Angular 18+)
```

---

## Resumo: Modelo Mental do Angular

```
┌──────────────────────────────────────────────────────────────────┐
│                        ANGULAR                                    │
│                                                                   │
│  ┌─────────────┐                                                 │
│  │  Components  │  @Component + template + styles                │
│  │  (Signals)   │  input(), output(), model(), computed()        │
│  └──────┬───────┘                                                │
│         │ depende de                                             │
│  ┌──────▼───────────────────────────────┐                        │
│  │  Dependency Injection                 │                        │
│  │  inject(), providers, InjectionToken  │                        │
│  │  Hierarchical Injectors               │                        │
│  └──────┬───────────────────────────────┘                        │
│         │ fornece                                                │
│  ┌──────▼─────────────────┐  ┌──────────────────────┐            │
│  │  Services              │  │  Router               │            │
│  │  HttpClient + RxJS     │  │  Guards, Resolvers     │            │
│  │  Interceptors          │  │  Lazy Loading           │            │
│  └────────────────────────┘  └──────────────────────┘            │
│                                                                   │
│  ┌──────────────────────────────────────┐                        │
│  │  Forms                                │                        │
│  │  Reactive Forms (FormGroup, FormArray) │                        │
│  │  Validators, Typed Forms              │                        │
│  └──────────────────────────────────────┘                        │
│                                                                   │
│  Reatividade: Signals (estado) + RxJS (streams)                  │
│  Change Detection: Zone.js → migração para Signals (zoneless)    │
│  Build: Angular CLI (esbuild, Vite dev server no Angular 17+)    │
│  Testing: TestBed + Jasmine/Jest + HttpTestingController         │
└──────────────────────────────────────────────────────────────────┘

Regra de ouro: Siga as convenções do Angular.
Não lute contra o framework — aproveite a estrutura que ele oferece.
DI, Signals e Reactive Forms são os pilares.
Entenda quando usar RxJS (streams) vs Signals (estado).
```

Angular é verboso por design. Cada decorator, cada provider, cada guard é uma decisão explícita e rastreável. Em projetos enterprise com 10+ desenvolvedores e ciclo de vida de anos, essa clareza compensa — e muito — a curva de aprendizado inicial.
