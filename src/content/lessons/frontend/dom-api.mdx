---
title: "DOM API e Manipulação"
description: "Document Object Model em profundidade: árvore de nós, seleção, traversal, mutação, DocumentFragment, template element e performance de DOM operations"
track: "frontend"
order: 8
section: "JavaScript"
priority: "high"
tags: ["dom", "javascript", "api", "seletores", "manipulação", "performance", "template"]
prerequisites: ["closures", "como-browser-funciona"]
keyTakeaways:
  - "O DOM é uma árvore de nós (não de tags) — text nodes, comment nodes e element nodes coexistem na mesma árvore"
  - "querySelector/querySelectorAll usam seletores CSS e retornam snapshots estáticos; getElementsBy* retornam coleções live que se atualizam automaticamente"
  - "Cada mutação no DOM pode disparar reflow (recalcula geometria) e repaint (redesenha pixels) — batch mutations com DocumentFragment ou requestAnimationFrame"
  - "O template element (<template>) mantém conteúdo inerte (não renderizado, não executado) até ser clonado — base de Web Components e rendering manual eficiente"
  - "textContent é seguro contra XSS e mais rápido que innerHTML; use innerHTML apenas com dados confiáveis e nunca com input do usuário"
---

# DOM API e Manipulação

O DOM (Document Object Model) é a interface programática entre JavaScript e o documento HTML. Quando o browser parseia HTML, ele constrói uma árvore de objetos — o DOM — que JavaScript pode ler e modificar. Frameworks como React abstraem o DOM, mas entender a API nativa é fundamental: é o que React usa internamente, é o que você debugga no DevTools, e é o que você precisa quando a abstração não resolve.

---

## 1. A Árvore DOM

### 1.1 Tipos de Nós

O DOM não é uma árvore de "tags" — é uma árvore de **nós** com tipos distintos:

```html
<div id="app">
  Hello <!-- comentário -->
  <span>World</span>
</div>
```

```
Document
 └── html (Element)
      └── body (Element)
           └── div#app (Element)
                ├── "Hello " (Text)
                ├── <!-- comentário --> (Comment)
                └── span (Element)
                     └── "World" (Text)
```

| Tipo | nodeType | Exemplo |
|------|----------|---------|
| Element | 1 | `<div>`, `<span>`, `<p>` |
| Text | 3 | Texto entre tags, whitespace |
| Comment | 8 | `<!-- ... -->` |
| Document | 9 | O nó raiz |
| DocumentFragment | 11 | Container virtual (não renderizado) |

### 1.2 Navegação na Árvore

```javascript
const div = document.getElementById('app');

// Navegação por TODOS os nós (incluindo text e comment)
div.childNodes;       // NodeList [Text, Comment, Element]
div.firstChild;       // Text "Hello "
div.lastChild;        // <span>

// Navegação apenas por ELEMENTS (mais útil na prática)
div.children;         // HTMLCollection [<span>]
div.firstElementChild; // <span>
div.lastElementChild;  // <span>

// Subindo e descendo
div.parentElement;    // <body>
div.closest('body');  // <body> (sobe até encontrar match)
```

---

## 2. Seleção de Elementos

### 2.1 querySelector vs getElementsBy*

```javascript
// querySelector — seletores CSS, retorna PRIMEIRO match
const btn = document.querySelector('.btn.primary');
const input = document.querySelector('[data-form="login"] input[type="email"]');

// querySelectorAll — retorna NodeList ESTÁTICA (snapshot)
const items = document.querySelectorAll('.list-item');
// items não muda se você adicionar .list-item depois

// getElementsBy* — retorna HTMLCollection LIVE
const divs = document.getElementsByTagName('div');
// divs se atualiza automaticamente quando o DOM muda!

// getElementById — o mais rápido (O(1) via hash table interna)
const app = document.getElementById('app');
```

### 2.2 Performance de Seleção

```javascript
// ✅ Rápido: ID direto (O(1) hash lookup)
document.getElementById('app');

// ✅ Rápido: seletor simples
document.querySelector('.my-class');

// ⚠️ Mais lento: seletores complexos (o engine precisa avaliar)
document.querySelectorAll('.container > .list .item:not(.hidden):nth-child(odd)');

// ✅ Cache seletores que serão reutilizados
const container = document.getElementById('list');
const items = container.querySelectorAll('.item'); // Escopo reduzido
```

---

## 3. Mutação do DOM

### 3.1 Criação e Inserção

```javascript
// Criar elemento
const card = document.createElement('div');
card.className = 'card';
card.textContent = 'Novo card'; // Seguro contra XSS

// Inserção moderna (posição precisa)
container.prepend(card);                    // Primeiro filho
container.append(card);                     // Último filho
reference.before(card);                     // Antes do elemento
reference.after(card);                      // Depois do elemento
reference.replaceWith(card);                // Substituir

// insertAdjacentHTML — parsing eficiente de HTML string
container.insertAdjacentHTML('beforeend', '<div class="card">HTML</div>');
// Posições: 'beforebegin' | 'afterbegin' | 'beforeend' | 'afterend'
```

### 3.2 Remoção

```javascript
// Moderno
element.remove();

// Clássico (ainda necessário para IE ou referência do parent)
parent.removeChild(element);
```

### 3.3 Atributos e Dataset

```javascript
// Atributos
el.setAttribute('role', 'button');
el.getAttribute('role');        // 'button'
el.hasAttribute('disabled');    // boolean
el.removeAttribute('disabled');
el.toggleAttribute('hidden');   // adiciona ou remove

// Dataset (data-* attributes)
// <div data-user-id="123" data-role="admin">
el.dataset.userId;  // '123' (kebab-case → camelCase)
el.dataset.role;    // 'admin'
el.dataset.active = 'true'; // Seta data-active="true"
```

### 3.4 Classes e Estilos

```javascript
// classList — API moderna para classes
el.classList.add('active', 'visible');
el.classList.remove('hidden');
el.classList.toggle('open');          // Adiciona ou remove
el.classList.toggle('dark', isDark);  // Força baseado em condição
el.classList.contains('active');      // boolean
el.classList.replace('old', 'new');

// Estilos inline (evitar quando possível — prefira classes)
el.style.backgroundColor = 'red';
el.style.cssText = 'color: white; font-size: 16px;';

// Ler estilos computados (após CSS aplicado)
const computed = getComputedStyle(el);
computed.fontSize; // '16px' (string, não número)
```

---

## 4. Performance de DOM Operations

### 4.1 O Custo de Mutações

Cada mutação no DOM pode disparar:
1. **Style recalculation** — recalcula CSS
2. **Reflow (Layout)** — recalcula posição e tamanho de elementos
3. **Repaint** — redesenha pixels na tela

```javascript
// ❌ Força reflow a cada iteração (layout thrashing)
for (const item of items) {
  const height = item.offsetHeight; // LEITURA → força reflow
  item.style.height = height * 2 + 'px'; // ESCRITA → invalida layout
  // Próxima leitura forçará outro reflow!
}

// ✅ Batch: todas as leituras primeiro, depois escritas
const heights = items.map(item => item.offsetHeight); // Leituras
items.forEach((item, i) => {
  item.style.height = heights[i] * 2 + 'px'; // Escritas
});
```

### 4.2 DocumentFragment

DocumentFragment é um container virtual que não existe no DOM. Mutações nele não causam reflow:

```javascript
// ❌ 1000 reflows (um por append)
for (let i = 0; i < 1000; i++) {
  const li = document.createElement('li');
  li.textContent = `Item ${i}`;
  list.appendChild(li); // Reflow a cada iteração
}

// ✅ 1 reflow (batch via fragment)
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
  const li = document.createElement('li');
  li.textContent = `Item ${i}`;
  fragment.appendChild(li); // Sem reflow (fragment não está no DOM)
}
list.appendChild(fragment); // UM único reflow
```

### 4.3 requestAnimationFrame

Para animações e atualizações visuais, use `requestAnimationFrame` para sincronizar com o ciclo de renderização do browser (~60fps):

```javascript
function animateProgress(el, from, to) {
  let current = from;

  function step() {
    current += (to - current) * 0.1;
    el.style.width = current + '%';

    if (Math.abs(to - current) > 0.5) {
      requestAnimationFrame(step); // Sincroniza com o refresh do monitor
    }
  }

  requestAnimationFrame(step);
}
```

---

## 5. Template Element

O `<template>` mantém conteúdo **inerte** — não renderizado, não executado, não afeta o layout:

```html
<template id="card-template">
  <div class="card">
    <h3 class="card-title"></h3>
    <p class="card-body"></p>
  </div>
</template>
```

```javascript
const template = document.getElementById('card-template');

function createCard(title, body) {
  // Clona o conteúdo do template (deep clone)
  const clone = template.content.cloneNode(true);

  clone.querySelector('.card-title').textContent = title;
  clone.querySelector('.card-body').textContent = body;

  return clone;
}

// Criar múltiplos cards eficientemente
const fragment = document.createDocumentFragment();
data.forEach(item => {
  fragment.appendChild(createCard(item.title, item.body));
});
container.appendChild(fragment);
```

---

## 6. Segurança: innerHTML vs textContent

```javascript
const userInput = '<img src=x onerror="alert(document.cookie)">';

// ❌ VULNERÁVEL: XSS via innerHTML com input do usuário
el.innerHTML = userInput; // Executa o script!

// ✅ SEGURO: textContent escapa HTML automaticamente
el.textContent = userInput; // Renderiza como texto literal

// ✅ SEGURO: createElement + textContent
const p = document.createElement('p');
p.textContent = userInput;
container.appendChild(p);
```

**Regra:** use `textContent` para conteúdo dinâmico. Use `innerHTML` apenas com HTML confiável (templates estáticos, nunca input do usuário).

---

## 7. Referências e Aprofundamento

- **MDN: Document Object Model** — referência completa da API DOM
- **MDN: Introduction to the DOM** — tutorial introdutório
- **"JavaScript: The Definitive Guide"** (Flanagan) — capítulos 15-16 sobre DOM
- **Google Developers: Rendering Performance** — guia sobre reflow, repaint e compositing
- **CS50 Web (Harvard)** — semana sobre JavaScript e DOM manipulation
