---
title: "Prototypes e Herança"
description: "Entenda o sistema de prototypes do JavaScript, como a herança realmente funciona e por que composição é preferível"
track: "frontend"
order: 7
section: "JavaScript"
priority: "high"
tags: ["javascript", "prototypes", "herança", "oop", "v8"]
prerequisites: ["closures"]
keyTakeaways:
  - "JavaScript não tem classes de verdade — class é syntactic sugar sobre prototypes"
  - "Todo objeto tem um [[Prototype]] interno que forma a prototype chain até null"
  - "V8 usa hidden classes e inline caches — o formato dos objetos afeta diretamente a performance"
---

## Prototype chain: o mecanismo fundamental

Todo objeto em JavaScript possui um slot interno `[[Prototype]]` que referencia outro objeto (ou `null`). Essa cadeia de referências é a **prototype chain** — o mecanismo que o engine usa para resolver propriedades.

```javascript
// Criando um objeto simples
const animal = {
  isAlive: true,
  breathe() { return 'respirando...'; },
};

const dog = Object.create(animal); // dog.[[Prototype]] === animal
dog.breed = 'Labrador';

// Property lookup: como o engine resolve uma propriedade
dog.breed;    // 1. Procura em dog (own property) → encontrou: 'Labrador'
dog.isAlive;  // 1. Procura em dog → não tem
              // 2. Procura em dog.[[Prototype]] (animal) → encontrou: true
dog.toString; // 1. Procura em dog → não tem
              // 2. Procura em animal → não tem
              // 3. Procura em Object.prototype → encontrou: function toString()
dog.xyz;      // Sobe toda a chain até null → retorna undefined

// Inspecionando a chain
Object.getPrototypeOf(dog) === animal;              // true
Object.getPrototypeOf(animal) === Object.prototype; // true
Object.getPrototypeOf(Object.prototype) === null;   // true — fim da chain

// __proto__ é um getter/setter legado em Object.prototype
// Use Object.getPrototypeOf() e Object.setPrototypeOf() em código moderno
// (setPrototypeOf é extremamente lento — evite em produção)
```

```
dog → animal → Object.prototype → null
 │       │            │
 │       │            ├─ toString()
 │       │            ├─ hasOwnProperty()
 │       │            └─ valueOf()
 │       │
 │       ├─ isAlive: true
 │       └─ breathe()
 │
 └─ breed: 'Labrador'
```

---

## Own properties vs inherited properties

```javascript
const parent = { inherited: true };
const child = Object.create(parent);
child.own = true;

// hasOwnProperty — verifica se a propriedade é do próprio objeto
child.hasOwnProperty('own');       // true
child.hasOwnProperty('inherited'); // false

// Object.hasOwn() — versão moderna (ES2022), mais segura
Object.hasOwn(child, 'own');       // true
Object.hasOwn(child, 'inherited'); // false

// Por que hasOwn é mais seguro que hasOwnProperty?
const obj = Object.create(null); // Objeto sem prototype!
// obj.hasOwnProperty('x'); // TypeError: obj.hasOwnProperty is not a function
Object.hasOwn(obj, 'x');          // false — funciona sempre

// for...in itera own + inherited (enumeráveis)
for (const key in child) {
  console.log(key); // 'own', 'inherited'
}

// Object.keys() retorna apenas own properties enumeráveis
Object.keys(child); // ['own']

// Property shadowing — própria "esconde" a herdada
child.inherited = 'sobrescrito'; // Cria own property em child
child.inherited;                 // 'sobrescrito' (own)
delete child.inherited;
child.inherited;                 // true (herdada de parent novamente)
```

---

## Constructor functions: o que `new` faz internamente

O operador `new` executa 4 passos internos ao chamar uma constructor function:

```javascript
function Dog(name, breed) {
  // Passo 3: `this` é vinculado ao novo objeto
  this.name = name;
  this.breed = breed;
  // Passo 4: se não retornar um objeto explicitamente, retorna `this`
}

Dog.prototype.bark = function () {
  return `${this.name} diz: Woof!`;
};

const rex = new Dog('Rex', 'Pastor Alemão');

// O que `new Dog('Rex', 'Pastor Alemão')` faz internamente:
function simulateNew(Constructor, ...args) {
  // Passo 1: Cria um novo objeto vazio
  const obj = {};

  // Passo 2: Vincula o [[Prototype]] ao prototype do constructor
  Object.setPrototypeOf(obj, Constructor.prototype);

  // Passo 3: Executa o constructor com `this` vinculado ao novo objeto
  const result = Constructor.apply(obj, args);

  // Passo 4: Se o constructor retornou um objeto, usa ele.
  // Caso contrário, retorna o objeto criado no passo 1.
  return (result !== null && typeof result === 'object') ? result : obj;
}

const rex2 = simulateNew(Dog, 'Rex', 'Pastor Alemão');
rex2.bark(); // "Rex diz: Woof!"

// Verificando a chain:
rex instanceof Dog;                                  // true
Object.getPrototypeOf(rex) === Dog.prototype;        // true
Dog.prototype.constructor === Dog;                   // true (referência circular)
```

---

## ES6 classes: syntactic sugar sobre prototypes

Classes em JavaScript NÃO são classes no sentido de Java/C++. São **funções construtoras com sintaxe declarativa** que usam o mesmo sistema de prototypes.

```javascript
class Animal {
  // Private fields (ES2022) — não acessíveis fora da classe
  #heartRate = 60;

  // Static field — pertence à classe, não às instâncias
  static kingdom = 'Animalia';

  constructor(name) {
    this.name = name; // Public field via constructor
  }

  // Método na prototype (Animal.prototype.breathe)
  breathe() {
    return `${this.name} está respirando. BPM: ${this.#heartRate}`;
  }

  // Getter — acesso como propriedade: animal.info
  get info() {
    return `${this.name} (${Animal.kingdom})`;
  }

  // Setter com validação
  set heartRate(value) {
    if (value < 0 || value > 300) throw new RangeError('BPM inválido');
    this.#heartRate = value;
  }

  // Static method — Animal.create(), não instância.create()
  static create(name) {
    return new this(name); // `this` em static method é a própria classe
  }
}

class Dog extends Animal {
  #tricks = [];

  constructor(name, breed) {
    super(name); // OBRIGATÓRIO antes de acessar `this` em subclasses
    this.breed = breed;
  }

  bark() {
    return `${this.name} diz: Woof!`;
  }

  learnTrick(trick) {
    this.#tricks.push(trick);
  }

  // Override com chamada ao método pai
  breathe() {
    const base = super.breathe();
    return `${base} (raça: ${this.breed})`;
  }
}

// O que acontece internamente:
// Dog.prototype.__proto__ === Animal.prototype (herança de instância)
// Dog.__proto__ === Animal (herança estática — por isso Dog.kingdom funciona)

const rex = new Dog('Rex', 'Labrador');
rex.bark();    // "Rex diz: Woof!"
rex.breathe(); // "Rex está respirando. BPM: 60 (raça: Labrador)"
rex.info;      // "Rex (Animalia)"

// Private fields são REALMENTE privados (não é convenção como _variavel)
// rex.#heartRate; // SyntaxError: Private field '#heartRate' must be declared
```

```javascript
// Provando que class é sugar sobre prototypes:
typeof Dog;                      // 'function'
typeof Dog.prototype;            // 'object'
Dog.prototype.bark;              // [Function: bark]
rex.hasOwnProperty('name');      // true  (own property)
rex.hasOwnProperty('bark');      // false (no prototype)
'bark' in rex;                   // true  (encontrado na chain)
```

---

## Object.create(): criação com prototype explícito

```javascript
// Object.create(proto, propertyDescriptors?) — cria objeto com prototype específico

// Pattern: herança sem constructor
const eventEmitter = {
  _listeners: null,

  on(event, fn) {
    if (!this._listeners) this._listeners = {};
    (this._listeners[event] ??= []).push(fn);
    return this;
  },

  emit(event, ...args) {
    const fns = this._listeners?.[event] ?? [];
    fns.forEach(fn => fn.apply(this, args));
    return this;
  },

  off(event, fn) {
    if (!this._listeners?.[event]) return this;
    this._listeners[event] = this._listeners[event].filter(f => f !== fn);
    return this;
  },
};

// Cria objetos que herdam de eventEmitter
const logger = Object.create(eventEmitter);
logger.log = function (message) {
  console.log(`[LOG] ${message}`);
  this.emit('log', message);
};

logger.on('log', (msg) => console.log(`Listener recebeu: ${msg}`));
logger.log('Servidor iniciado');

// Object.create(null) — objeto sem prototype algum (dicionário puro)
const cache = Object.create(null);
cache.toString = 'valor qualquer'; // Sem conflito com Object.prototype.toString
// Útil para maps onde as chaves podem colidir com nomes de métodos do Object
```

---

## Mixins e composição com Object.assign

```javascript
// Mixins permitem compor comportamentos sem herança hierárquica

const Serializable = {
  serialize() {
    return JSON.stringify(this);
  },
  toJSON() {
    // Controla o que é serializado
    const result = {};
    for (const key of Object.keys(this)) {
      if (!key.startsWith('_')) result[key] = this[key];
    }
    return result;
  },
};

const Validatable = {
  validate() {
    for (const [field, rules] of Object.entries(this._validations || {})) {
      for (const rule of rules) {
        const error = rule(this[field], field);
        if (error) throw new Error(error);
      }
    }
    return true;
  },
  addValidation(field, ruleFn) {
    this._validations ??= {};
    (this._validations[field] ??= []).push(ruleFn);
  },
};

const Observable = {
  observe(prop, callback) {
    this._observers ??= {};
    (this._observers[prop] ??= []).push(callback);
  },
  set(prop, value) {
    const old = this[prop];
    this[prop] = value;
    (this._observers?.[prop] || []).forEach(cb => cb(value, old));
  },
};

// Compondo múltiplos mixins
class UserModel {
  constructor(name, email) {
    this.name = name;
    this.email = email;
  }
}

// Adiciona todos os mixins ao prototype
Object.assign(UserModel.prototype, Serializable, Validatable, Observable);

const user = new UserModel('Lucas', 'lucas@example.com');
user.addValidation('email', (v, f) =>
  !v.includes('@') ? `${f} inválido` : null
);
user.validate();             // true
user.serialize();            // '{"name":"Lucas","email":"lucas@example.com"}'
user.observe('name', (n, o) => console.log(`Nome: ${o} → ${n}`));
user.set('name', 'Gabriel'); // "Nome: Lucas → Gabriel"
```

---

## instanceof: como funciona internamente

```javascript
// instanceof verifica se Constructor.prototype está na prototype chain do objeto

rex instanceof Dog;    // true  — Dog.prototype está na chain de rex
rex instanceof Animal; // true  — Animal.prototype também está
rex instanceof Object; // true  — Object.prototype também está
rex instanceof Array;  // false — Array.prototype NÃO está

// Implementação simplificada do instanceof
function simulateInstanceof(obj, Constructor) {
  let proto = Object.getPrototypeOf(obj);
  while (proto !== null) {
    if (proto === Constructor.prototype) return true;
    proto = Object.getPrototypeOf(proto);
  }
  return false;
}

// Symbol.hasInstance — customiza o comportamento de instanceof
class EvenNumber {
  static [Symbol.hasInstance](value) {
    return typeof value === 'number' && value % 2 === 0;
  }
}

4 instanceof EvenNumber;  // true
3 instanceof EvenNumber;  // false
'4' instanceof EvenNumber; // false (não é number)

// CUIDADO: instanceof falha entre realms (iframes, workers)
// Um Array criado em um iframe NÃO é instanceof do Array do frame pai
// Use Array.isArray() para verificação segura de arrays
```

---

## Performance: hidden classes e inline caches no V8

Entender como o V8 otimiza objetos é essencial para escrever código performático.

```javascript
// V8 cria "hidden classes" (também chamadas Maps/Shapes) para objetos
// com a mesma estrutura. Isso permite otimizações de inline caching.

// BOM — todos os objetos têm a mesma shape (mesma hidden class)
function createPointGood(x, y) {
  const point = {};
  point.x = x; // hidden class: C0 → C1 (adiciona x)
  point.y = y; // hidden class: C1 → C2 (adiciona y)
  return point;
}

// Todos compartilham a hidden class C2 → acesso monomorphic (rápido)
const p1 = createPointGood(1, 2);
const p2 = createPointGood(3, 4);
const p3 = createPointGood(5, 6);

// RUIM — propriedades adicionadas em ordens diferentes
function createPointBad(x, y, hasZ) {
  const point = {};
  if (hasZ) point.z = 0; // Ordem diferente → hidden class diferente!
  point.x = x;
  point.y = y;
  return point;
}

// Gera hidden classes diferentes → acesso polymorphic/megamorphic (lento)
const q1 = createPointBad(1, 2, false); // Shape: {x, y}
const q2 = createPointBad(3, 4, true);  // Shape: {z, x, y} — DIFERENTE!

// TIPOS DE INLINE CACHE:
// Monomorphic  — 1 shape  → lookup otimizado (offset direto na memória)
// Polymorphic  — 2-4 shapes → lookup com branch (ainda razoável)
// Megamorphic  — 5+ shapes → lookup genérico via hash table (lento)

// REGRAS PARA MANTER CÓDIGO MONOMORPHIC:
// 1. Sempre inicialize propriedades na mesma ordem
// 2. Não adicione propriedades condicionalmente
// 3. Não delete propriedades (use = undefined)
// 4. Mantenha tipos consistentes (não misture string e number na mesma prop)

// Evite delete — deoptimiza o objeto
const obj = { a: 1, b: 2 };
delete obj.b;  // V8 muda para "dictionary mode" (modo hash table lento)
obj.b = undefined; // Mantém a hidden class — preferível

// NUNCA modifique o prototype de um objeto existente
Object.setPrototypeOf(obj, other); // Invalida TODAS as inline caches
// A especificação permite, mas V8 precisa descartar otimizações
```

```javascript
// Benchmark: monomorphic vs megamorphic
function sumX(points) {
  let total = 0;
  for (const p of points) {
    total += p.x; // Inline cache: depende da hidden class de p
  }
  return total;
}

// Monomorphic — todos têm a mesma shape → rápido
const monoPoints = Array.from({ length: 100000 }, (_, i) => ({ x: i, y: i }));
console.time('mono');
sumX(monoPoints);
console.timeEnd('mono'); // ~0.5ms

// Megamorphic — shapes diferentes → lento
const megaPoints = Array.from({ length: 100000 }, (_, i) => {
  const p = { x: i };
  if (i % 5 === 0) p.a = 1;
  if (i % 5 === 1) p.b = 1;
  if (i % 5 === 2) p.c = 1;
  if (i % 5 === 3) p.d = 1;
  if (i % 5 === 4) p.e = 1;
  p.y = i;
  return p;
});
console.time('mega');
sumX(megaPoints);
console.timeEnd('mega'); // ~5ms — 10x mais lento!
```

---

## Composição sobre herança

Herança profunda cria acoplamento frágil. Composição oferece flexibilidade sem hierarquias rígidas.

```javascript
// PROBLEMA com herança profunda:
// Entity → Character → Player → Warrior → MagicWarrior
// Quer um inimigo que voa e lança magia? A hierarquia não previu isso.

// SOLUÇÃO: composição com factory functions
function withHealth(state) {
  return {
    takeDamage(amount) {
      state.hp = Math.max(0, state.hp - amount);
      if (state.hp === 0) this.die();
    },
    heal(amount) { state.hp = Math.min(state.maxHp, state.hp + amount); },
    isAlive() { return state.hp > 0; },
    die() { console.log(`${state.name} morreu`); },
  };
}

function withMovement(state) {
  return {
    move(x, y) { state.x += x; state.y += y; },
    getPosition() { return { x: state.x, y: state.y }; },
  };
}

function withMagic(state) {
  return {
    castSpell(spell) {
      if (state.mana < spell.cost) return false;
      state.mana -= spell.cost;
      return spell.effect();
    },
  };
}

function withFlying(state) {
  return {
    fly(x, y, altitude) {
      state.x += x; state.y += y; state.altitude = altitude;
    },
  };
}

// Composição livre — qualquer combinação é possível
function createPlayer(name) {
  const state = { name, hp: 100, maxHp: 100, mana: 50, x: 0, y: 0 };
  return Object.assign(
    { name },
    withHealth(state),
    withMovement(state),
    withMagic(state),
  );
}

function createFlyingEnemy(name) {
  const state = { name, hp: 50, maxHp: 50, x: 0, y: 0, altitude: 0 };
  return Object.assign(
    { name },
    withHealth(state),
    withFlying(state),
    withMagic(state), // Inimigo voador que lança magia — sem hierarquia!
  );
}

const player = createPlayer('Lucas');
const dragon = createFlyingEnemy('Dragão');
dragon.fly(10, 20, 100);
dragon.castSpell({ cost: 10, effect: () => player.takeDamage(30) });
```

---

## TypeScript: interface vs type vs abstract class

```typescript
// INTERFACE — contrato estrutural, pode ser implementada e estendida
// Ideal para: definir a forma de objetos, contracts de API
interface Serializable {
  serialize(): string;
}

interface Identifiable {
  readonly id: string;
}

// Interfaces podem ser merged (declaration merging)
interface User {
  name: string;
}
interface User {
  email: string; // Merge automático — User agora tem name + email
}

// TYPE — alias para qualquer tipo, incluindo unions e intersections
// Ideal para: tipos compostos, unions discriminadas, mapped types
type Result<T> = { ok: true; data: T } | { ok: false; error: Error };
type EventName = 'click' | 'hover' | 'focus';
type ReadonlyUser = Readonly<User>;

// Intersection — combina múltiplos tipos
type Entity = Identifiable & Serializable & {
  createdAt: Date;
};

// ABSTRACT CLASS — implementação parcial + contrato
// Ideal para: compartilhar lógica entre classes concretas
abstract class Repository<T extends Identifiable> {
  protected items: Map<string, T> = new Map();

  // Método concreto (compartilhado por todas as subclasses)
  findById(id: string): T | undefined {
    return this.items.get(id);
  }

  getAll(): T[] {
    return Array.from(this.items.values());
  }

  // Método abstrato (cada subclasse DEVE implementar)
  abstract validate(item: T): boolean;
  abstract save(item: T): Promise<void>;
}

class UserRepository extends Repository<User & Identifiable> {
  validate(user: User & Identifiable): boolean {
    return user.email.includes('@') && user.name.length > 0;
  }

  async save(user: User & Identifiable): Promise<void> {
    if (!this.validate(user)) throw new Error('Dados inválidos');
    this.items.set(user.id, user);
  }
}

// TypeScript usa STRUCTURAL TYPING — não nominal
// A compatibilidade é baseada na FORMA, não no nome do tipo
interface Dog { name: string; breed: string; }
interface Cat { name: string; breed: string; }

const dog: Dog = { name: 'Rex', breed: 'Labrador' };
const cat: Cat = dog; // OK! Mesma estrutura = tipos compatíveis

// Para forçar tipos nominais (branded types):
type UserId = string & { readonly __brand: unique symbol };
type OrderId = string & { readonly __brand: unique symbol };

function createUserId(id: string): UserId { return id as UserId; }
function createOrderId(id: string): OrderId { return id as OrderId; }

function getUser(id: UserId) { /* ... */ }
const userId = createUserId('u-123');
const orderId = createOrderId('o-456');
getUser(userId);  // OK
// getUser(orderId); // Erro! OrderId não é compatível com UserId
```

A prototype chain é a coluna vertebral do JavaScript. Mesmo usando classes ES6, TypeScript e frameworks modernos, todo acesso a propriedade, toda chamada de método e toda verificação de instanceof depende desse mecanismo. Entender prototypes é entender como a linguagem funciona no nível mais fundamental.
