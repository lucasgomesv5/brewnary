---
title: "Event Delegation e Observers"
description: "Domine propagação de eventos, delegation, custom events e os Observer APIs do navegador"
track: "frontend"
order: 9
section: "JavaScript"
priority: "high"
tags: ["javascript", "dom", "eventos", "performance", "observers"]
prerequisites: ["closures"]
keyTakeaways:
  - "Eventos fluem em três fases: capturing, target e bubbling — delegation explora o bubbling"
  - "Um único listener no pai substitui milhares de listeners nos filhos, economizando memória e suportando elementos dinâmicos"
  - "IntersectionObserver, MutationObserver e ResizeObserver resolvem problemas que antes exigiam polling custoso"
---

## Event propagation: o fluxo completo do DOM

Quando um evento ocorre no DOM, ele passa por **três fases** definidas na especificação W3C UI Events:

1. **Capturing phase**: o evento desce de `window` até o pai do target.
2. **Target phase**: o evento atinge o elemento que originou o evento.
3. **Bubbling phase**: o evento sobe do target de volta até `window`.

```javascript
// Visualizando as três fases
document.querySelector('.outer').addEventListener('click', (e) => {
  console.log('outer — capturing');
}, true); // true = capturing phase

document.querySelector('.inner').addEventListener('click', (e) => {
  console.log('inner — target/bubbling');
}); // padrão = bubbling phase

document.querySelector('.outer').addEventListener('click', (e) => {
  console.log('outer — bubbling');
});

// Ao clicar em .inner, o console mostra:
// "outer — capturing"    ← fase 1: descendo
// "inner — target/bubbling" ← fase 2: no target
// "outer — bubbling"     ← fase 3: subindo

// IMPORTANTE: nem todos os eventos borbulham.
// focus, blur, mouseenter, mouseleave NÃO borbulham.
// Alternativas que borbulham: focusin, focusout, mouseover, mouseout.
```

```
window
  └─ document
       └─ html
            └─ body
                 └─ .outer        ← capturing (descendo) / bubbling (subindo)
                      └─ .inner   ← target phase
```

---

## Event delegation: o pattern fundamental

Event delegation explora o bubbling para registrar **um único handler** no ancestral, em vez de um handler em cada filho. Isso resolve três problemas:

1. **Memória**: 1 listener vs N listeners.
2. **Elementos dinâmicos**: filhos adicionados depois do bind já são capturados.
3. **Setup/teardown**: um único `addEventListener` / `removeEventListener`.

```javascript
// SEM delegation — 1000 itens = 1000 listeners
document.querySelectorAll('.item').forEach(item => {
  item.addEventListener('click', handleClick);
});
// Problema: itens adicionados via JS depois NÃO terão o listener.

// COM delegation — 1 listener no container
const list = document.querySelector('.list');
list.addEventListener('click', (event) => {
  // event.target = elemento exato que recebeu o clique (pode ser um filho)
  // event.currentTarget = elemento onde o listener está registrado (.list)

  // .closest() sobe a árvore até encontrar um match do seletor
  const item = event.target.closest('.item');
  if (!item) return; // Clicou fora de qualquer .item

  // Garante que o item está DENTRO do nosso container
  if (!list.contains(item)) return;

  const id = item.dataset.id;
  console.log(`Item ${id} clicado`);
});

// Agora, mesmo itens adicionados dinamicamente são tratados:
const novoItem = document.createElement('li');
novoItem.className = 'item';
novoItem.dataset.id = '1001';
novoItem.textContent = 'Item dinâmico';
list.appendChild(novoItem); // Já funciona, sem addEventListener extra!
```

```javascript
// event.target vs event.currentTarget — a diferença é crucial

document.querySelector('.card').addEventListener('click', (e) => {
  console.log(e.target);         // Elemento exato clicado (ex: <span> dentro do card)
  console.log(e.currentTarget);  // Sempre .card (onde o listener está)
  console.log(e.target === e.currentTarget); // true apenas se clicou diretamente no .card
});

// CUIDADO com arrow functions e this:
// Em arrow functions, `this` NÃO é o currentTarget.
// Use e.currentTarget em vez de `this` dentro de arrow functions.
```

---

## stopPropagation vs stopImmediatePropagation vs preventDefault

Três métodos frequentemente confundidos, com comportamentos muito diferentes:

```javascript
const button = document.querySelector('.btn');

// preventDefault — cancela a ação padrão do navegador
// NÃO interrompe a propagação do evento
document.querySelector('a.link').addEventListener('click', (e) => {
  e.preventDefault(); // Impede a navegação
  // O evento ainda borbulha normalmente!
  console.log('Link clicado, mas navegação cancelada');
});

// stopPropagation — para o evento de continuar subindo/descendo
// MAS permite outros listeners no MESMO elemento
button.addEventListener('click', (e) => {
  e.stopPropagation();
  console.log('Handler 1 — executado');
});
button.addEventListener('click', (e) => {
  console.log('Handler 2 — TAMBÉM executado (mesmo elemento)');
});

// stopImmediatePropagation — para TUDO
// Impede propagação E outros listeners no mesmo elemento
button.addEventListener('click', (e) => {
  e.stopImmediatePropagation();
  console.log('Handler 1 — executado');
});
button.addEventListener('click', (e) => {
  console.log('Handler 2 — NÃO executado');
});

// Resumo:
// preventDefault()            → cancela ação padrão, evento continua fluindo
// stopPropagation()           → para propagação, outros handlers do mesmo elemento rodam
// stopImmediatePropagation()  → para tudo (propagação + handlers restantes)
```

---

## Custom Events: comunicação entre componentes

Custom Events permitem comunicação desacoplada entre componentes sem dependência direta — essencial em micro-frontends e Web Components.

```javascript
// Criando e disparando um Custom Event
class ShoppingCart extends HTMLElement {
  addItem(product) {
    this.items.push(product);

    // CustomEvent aceita um objeto `detail` para dados arbitrários
    this.dispatchEvent(new CustomEvent('cart:updated', {
      bubbles: true,     // Permite delegation — o evento sobe pelo DOM
      composed: true,    // Atravessa Shadow DOM boundaries
      detail: {
        items: [...this.items],
        total: this.calculateTotal(),
        lastAdded: product,
      },
    }));
  }
}

// Qualquer ancestral pode escutar (delegation funciona!)
document.addEventListener('cart:updated', (e) => {
  console.log(`Carrinho atualizado: ${e.detail.items.length} itens`);
  console.log(`Total: R$ ${e.detail.total.toFixed(2)}`);
  updateCartBadge(e.detail.items.length);
});

// Pattern: Event Bus para comunicação global
class EventBus extends EventTarget {
  emit(name, detail) {
    this.dispatchEvent(new CustomEvent(name, { detail }));
  }

  on(name, callback) {
    this.addEventListener(name, callback);
    // Retorna função de cleanup
    return () => this.removeEventListener(name, callback);
  }
}

const bus = new EventBus();
const unsubscribe = bus.on('user:login', (e) => {
  console.log(`Bem-vindo, ${e.detail.name}!`);
});

bus.emit('user:login', { name: 'Lucas', role: 'admin' });
unsubscribe(); // Limpeza
```

---

## Event listeners: passive, once e AbortController

```javascript
// passive: true — informa ao navegador que o handler NÃO chamará preventDefault()
// Permite otimizar scroll (o browser não precisa esperar o handler terminar)
window.addEventListener('scroll', handleScroll, { passive: true });
window.addEventListener('touchstart', handleTouch, { passive: true });

// Se você tentar chamar preventDefault() em um passive listener:
// Chrome mostra: "Unable to preventDefault inside passive event listener"

// once: true — o listener é removido automaticamente após a primeira execução
button.addEventListener('click', () => {
  console.log('Executado apenas uma vez');
}, { once: true });

// AbortController — limpeza elegante de múltiplos listeners
function setupFeature(element) {
  const controller = new AbortController();
  const { signal } = controller;

  element.addEventListener('click', handleClick, { signal });
  element.addEventListener('mouseover', handleHover, { signal });
  element.addEventListener('keydown', handleKey, { signal });
  window.addEventListener('resize', handleResize, { signal });
  document.addEventListener('visibilitychange', handleVisibility, { signal });

  // Uma única chamada remove TODOS os listeners acima
  return () => controller.abort();
}

const cleanup = setupFeature(document.querySelector('.widget'));
// Mais tarde, ao desmontar:
cleanup(); // Remove todos os 5 listeners de uma vez

// Em React, AbortController é ideal para cleanup em useEffect:
function useWindowEvent(event, handler, options) {
  React.useEffect(() => {
    const controller = new AbortController();
    window.addEventListener(event, handler, {
      ...options,
      signal: controller.signal,
    });
    return () => controller.abort();
  }, [event, handler]);
}
```

---

## Debounce e throttle: controle de frequência de execução

```javascript
// DEBOUNCE — executa apenas após o usuário PARAR por N ms
// Caso de uso: busca em campo de texto (espera o usuário parar de digitar)
function debounce(fn, delay) {
  let timeoutId;
  return function (...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn.apply(this, args), delay);
  };
}

const searchInput = document.querySelector('#search');
const handleSearch = debounce(async (e) => {
  const results = await fetch(`/api/search?q=${e.target.value}`);
  renderResults(await results.json());
}, 300);

searchInput.addEventListener('input', handleSearch);

// THROTTLE — executa no máximo uma vez a cada N ms
// Caso de uso: scroll, resize (execução periódica durante ação contínua)
function throttle(fn, limit) {
  let inThrottle = false;
  let lastArgs = null;
  let lastThis = null;

  return function (...args) {
    if (!inThrottle) {
      fn.apply(this, args);
      inThrottle = true;
      setTimeout(() => {
        inThrottle = false;
        // Executa a última chamada pendente (trailing call)
        if (lastArgs) {
          fn.apply(lastThis, lastArgs);
          lastArgs = null;
          lastThis = null;
        }
      }, limit);
    } else {
      lastArgs = args;
      lastThis = this;
    }
  };
}

window.addEventListener('scroll', throttle(() => {
  updateScrollIndicator();
}, 100), { passive: true });

// Quando usar cada um:
// debounce → input de busca, validação, resize final, auto-save
// throttle → scroll, mousemove, resize contínuo, rate limiting de API
```

---

## IntersectionObserver: observação eficiente de visibilidade

O IntersectionObserver resolve problemas que antes exigiam `getBoundingClientRect()` dentro de scroll listeners — uma abordagem que causa **layout thrashing** e destrói a performance.

```javascript
// Lazy loading de imagens (sem scroll listener!)
const lazyImages = document.querySelectorAll('img[data-src]');

const imageObserver = new IntersectionObserver(
  (entries, observer) => {
    entries.forEach(entry => {
      if (!entry.isIntersecting) return;

      const img = entry.target;
      img.src = img.dataset.src;
      img.removeAttribute('data-src');
      observer.unobserve(img); // Para de observar após carregar
    });
  },
  {
    rootMargin: '200px', // Começa a carregar 200px antes de entrar na viewport
    threshold: 0,
  }
);

lazyImages.forEach(img => imageObserver.observe(img));

// Infinite scroll
const sentinel = document.querySelector('#scroll-sentinel');
const infiniteObserver = new IntersectionObserver(
  async ([entry]) => {
    if (!entry.isIntersecting) return;

    const nextPage = await fetchNextPage();
    if (nextPage.items.length === 0) {
      infiniteObserver.disconnect(); // Não há mais páginas
      return;
    }
    appendItems(nextPage.items);
  },
  { rootMargin: '400px' }
);

infiniteObserver.observe(sentinel);

// Analytics: tracking de visibilidade (quanto tempo o usuário viu cada seção)
const sectionTimers = new Map();

const analyticsObserver = new IntersectionObserver(
  (entries) => {
    entries.forEach(entry => {
      const id = entry.target.id;
      if (entry.isIntersecting) {
        sectionTimers.set(id, Date.now());
      } else if (sectionTimers.has(id)) {
        const duration = Date.now() - sectionTimers.get(id);
        analytics.track('section_viewed', { id, duration });
        sectionTimers.delete(id);
      }
    });
  },
  { threshold: 0.5 } // Pelo menos 50% visível
);

document.querySelectorAll('section[id]').forEach(s => analyticsObserver.observe(s));
```

---

## MutationObserver: detectando mudanças no DOM

MutationObserver permite reagir a mudanças no DOM de forma eficiente, sem polling. É essencial para monitorar scripts de terceiros e integrações.

```javascript
// Caso de uso: monitorar injeção de scripts de terceiros
const bodyObserver = new MutationObserver((mutations) => {
  for (const mutation of mutations) {
    for (const node of mutation.addedNodes) {
      if (node.nodeType !== Node.ELEMENT_NODE) continue;

      // Detectar scripts injetados
      if (node.tagName === 'SCRIPT') {
        console.warn(`Script injetado: ${node.src || 'inline'}`);
      }

      // Detectar iframes suspeitos
      if (node.tagName === 'IFRAME' && !node.hasAttribute('data-approved')) {
        console.error('Iframe não aprovado detectado!');
        node.remove();
      }
    }
  }
});

bodyObserver.observe(document.body, {
  childList: true,    // Observa adição/remoção de filhos diretos
  subtree: true,      // Observa toda a subárvore (recursivo)
});

// Caso de uso: sincronizar estado quando biblioteca externa modifica o DOM
const formObserver = new MutationObserver((mutations) => {
  for (const mutation of mutations) {
    if (mutation.type === 'attributes' && mutation.attributeName === 'value') {
      const input = mutation.target;
      // Dispara evento para que frameworks (React, Vue) detectem a mudança
      input.dispatchEvent(new Event('input', { bubbles: true }));
    }
  }
});

formObserver.observe(document.querySelector('#payment-form'), {
  attributes: true,         // Observa mudanças em atributos
  attributeFilter: ['value', 'checked', 'disabled'],
  subtree: true,
});

// IMPORTANTE: sempre desconectar quando não for mais necessário
// bodyObserver.disconnect();
```

---

## ResizeObserver: componentes responsivos sem media queries

```javascript
// ResizeObserver observa mudanças de tamanho de elementos individuais,
// não da viewport. Isso permite "container queries" em JavaScript.

const cardObserver = new ResizeObserver((entries) => {
  for (const entry of entries) {
    const { width } = entry.contentRect;
    const card = entry.target;

    // Layout adaptativo baseado no tamanho do CONTAINER, não da viewport
    card.classList.toggle('card--compact', width < 300);
    card.classList.toggle('card--default', width >= 300 && width < 600);
    card.classList.toggle('card--expanded', width >= 600);
  }
});

document.querySelectorAll('.card').forEach(c => cardObserver.observe(c));

// Caso de uso: auto-resize de textarea
const textarea = document.querySelector('textarea.auto-resize');
const textareaObserver = new ResizeObserver(([entry]) => {
  // Ajusta a altura baseado no conteúdo
  const el = entry.target;
  el.style.height = 'auto';
  el.style.height = `${el.scrollHeight}px`;
});

textareaObserver.observe(textarea);

// Caso de uso: gráfico responsivo (resize o canvas quando o container muda)
function createResponsiveChart(container, canvas) {
  const observer = new ResizeObserver(([entry]) => {
    const { width, height } = entry.contentRect;
    const dpr = window.devicePixelRatio || 1;

    canvas.width = width * dpr;
    canvas.height = height * dpr;
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;

    const ctx = canvas.getContext('2d');
    ctx.scale(dpr, dpr);
    drawChart(ctx, width, height); // Re-renderiza o gráfico
  });

  observer.observe(container);
  return () => observer.disconnect();
}
```

---

## Pointer Events vs Mouse Events vs Touch Events

```javascript
// PROBLEMA HISTÓRICO:
// - Mouse Events (click, mousedown, mousemove) não funcionam em touch
// - Touch Events (touchstart, touchmove) não funcionam com mouse
// - Resultado: código duplicado para cada tipo de input

// SOLUÇÃO: Pointer Events — API unificada para mouse, touch, stylus e pen

const canvas = document.querySelector('#drawing-canvas');
let isDrawing = false;

canvas.addEventListener('pointerdown', (e) => {
  isDrawing = true;
  // e.pointerType === 'mouse' | 'touch' | 'pen'
  // e.pressure — pressão do stylus (0 a 1)
  // e.tiltX, e.tiltY — ângulo do stylus
  // e.pointerId — identificador único (multi-touch!)

  canvas.setPointerCapture(e.pointerId);
  // setPointerCapture garante que os eventos continuem sendo
  // direcionados a este elemento mesmo se o pointer sair dele
  startPath(e.offsetX, e.offsetY, e.pressure);
});

canvas.addEventListener('pointermove', (e) => {
  if (!isDrawing) return;

  // getCoalescedEvents() retorna todos os pontos intermediários
  // que o browser coletou entre frames — essencial para desenho suave
  const events = e.getCoalescedEvents?.() || [e];
  for (const coalescedEvent of events) {
    drawLine(coalescedEvent.offsetX, coalescedEvent.offsetY, coalescedEvent.pressure);
  }
});

canvas.addEventListener('pointerup', (e) => {
  isDrawing = false;
  canvas.releasePointerCapture(e.pointerId);
});

// CSS complementar para pointer events:
// touch-action: none;       — desativa gestos do browser no elemento
// touch-action: pan-y;      — permite scroll vertical, captura horizontal
// touch-action: pinch-zoom; — permite apenas pinch zoom

// Detecção de tipo de input para adaptar a UI
window.addEventListener('pointerdown', (e) => {
  document.documentElement.dataset.inputType = e.pointerType;
  // Permite CSS como:
  // [data-input-type="touch"] .tooltip { font-size: 1.2rem; }
  // [data-input-type="mouse"] .tooltip { font-size: 0.875rem; }
}, { capture: true });
```

A compreensão profunda do modelo de eventos do DOM e dos Observer APIs é o que separa código performático de código que trava a UI thread. Event delegation reduz alocação de memória, passive listeners desbloqueiam scroll suave, e os Observers eliminam a necessidade de polling — que é historicamente a maior fonte de jank em aplicações web.
