---
title: "Docker Compose Avançado"
description: "Docker Compose v2 em profundidade: builds, healthchecks, profiles, secrets, networking, volumes e workflows de desenvolvimento"
track: "infra"
order: 3
section: "Containers"
priority: "high"
tags: ["docker-compose", "desenvolvimento", "profiles", "secrets", "healthchecks"]
prerequisites: ["docker-profundo"]
keyTakeaways:
  - "Docker Compose v2 é uma reescrita em Go integrada ao CLI do Docker, com suporte a profiles, watch mode e gestão nativa de secrets"
  - "Healthchecks com depends_on condition: service_healthy garantem ordem de inicialização baseada em prontidão real, não apenas no start do processo"
  - "Profiles permitem separar serviços de debug/observabilidade do core, ativando-os apenas quando necessário"
---

## Docker Compose v2: A Reescrita em Go

O Docker Compose v2 substituiu a versão original em Python. As diferenças chave:

```
Compose v1 (Python):              Compose v2 (Go):
─────────────────────             ─────────────────────
docker-compose (binário separado) docker compose (subcomando do CLI)
Execução mais lenta               Performance nativa
docker-compose.yml obrigatório    compose.yaml, compose.yml, docker-compose.yml
version: campo obrigatório        version: campo ignorado (retrocompat)
Não tem profiles                  Profiles para ativação condicional
Não tem watch                     Watch mode para hot reload
Não tem include                   Include para composição de arquivos
```

A especificação do Compose é um padrão aberto mantido em `compose-spec/compose-spec`. Não é mais exclusiva do Docker — Podman Compose e outras ferramentas implementam a mesma especificação.

## Referência Completa do Compose File

### Services: Configuração Detalhada

```yaml
# compose.yaml — Configuração completa de produção-like
services:
  api:
    build:
      context: .                    # Diretório raiz do build
      dockerfile: Dockerfile        # Pode ser customizado
      target: production            # Stage específico do multi-stage
      args:
        NODE_VERSION: "20"          # Build args (disponíveis no Dockerfile)
        BUILD_DATE: "${BUILD_DATE}" # Variáveis de ambiente do host
      cache_from:
        - type=registry,ref=registry.io/app:cache
      cache_to:
        - type=registry,ref=registry.io/app:cache,mode=max
      platforms:
        - linux/amd64
        - linux/arm64
      labels:
        com.empresa.version: "1.0.0"
      ssh:
        - default                   # Forward SSH agent para build

    image: registry.io/api:${TAG:-latest}  # Tag customizável

    container_name: api             # Nome fixo (desabilita scaling)
    hostname: api-server            # Hostname interno
    restart: unless-stopped         # Reinicia exceto se parado manualmente

    ports:
      - "3000:3000"                 # host:container
      - "127.0.0.1:9229:9229"      # Bind apenas em localhost (debug)

    environment:
      NODE_ENV: production
      LOG_LEVEL: info

    env_file:
      - .env                        # Variáveis do arquivo
      - .env.local                  # Override local (gitignored)

    volumes:
      - app-data:/app/data          # Named volume
      - ./config:/app/config:ro     # Bind mount read-only
      - /app/node_modules           # Anonymous volume

    tmpfs:
      - /tmp:size=100M              # tmpfs para dados temporários

    networks:
      app-net:
        aliases:
          - api.internal            # DNS alias adicional

    deploy:
      resources:
        limits:
          cpus: "1.0"
          memory: 512M
        reservations:
          cpus: "0.25"
          memory: 128M
      replicas: 2

    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"
        tag: "{{.Name}}/{{.ID}}"

    healthcheck:
      test: ["CMD-SHELL", "wget -qO- http://localhost:3000/health || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s             # Período de graça no startup

    depends_on:
      db:
        condition: service_healthy   # Espera health check passar
        restart: true                # Reinicia se db reiniciar
      cache:
        condition: service_started   # Apenas espera iniciar
      migrations:
        condition: service_completed_successfully  # Espera terminar com sucesso

    security_opt:
      - no-new-privileges:true
    cap_drop:
      - ALL
    cap_add:
      - NET_BIND_SERVICE
    read_only: true
```

### Healthchecks: A Chave para Orquestração Confiável

```yaml
services:
  db:
    image: postgres:16-alpine
    environment:
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_DB: myapp
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d myapp"]
      interval: 5s
      timeout: 3s
      retries: 10
      start_period: 30s
    volumes:
      - pgdata:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    command: >
      redis-server
      --requirepass ${REDIS_PASSWORD}
      --maxmemory 256mb
      --maxmemory-policy allkeys-lru
      --appendonly yes
    healthcheck:
      test: ["CMD", "redis-cli", "-a", "${REDIS_PASSWORD}", "ping"]
      interval: 5s
      timeout: 3s
      retries: 5

  elasticsearch:
    image: elasticsearch:8.12.0
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=false
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
    healthcheck:
      test: ["CMD-SHELL", "curl -sf http://localhost:9200/_cluster/health || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 60s             # ES demora para iniciar

  rabbitmq:
    image: rabbitmq:3.13-management-alpine
    healthcheck:
      test: ["CMD", "rabbitmq-diagnostics", "check_port_connectivity"]
      interval: 10s
      timeout: 5s
      retries: 10
```

### Depends_on com Condições

```yaml
services:
  # Serviço que executa e termina (migrations, seed)
  migrations:
    build:
      context: .
      target: migrations
    command: npx prisma migrate deploy
    environment:
      DATABASE_URL: postgres://postgres:${DB_PASSWORD}@db:5432/myapp
    depends_on:
      db:
        condition: service_healthy

  api:
    build:
      context: .
      target: production
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
      migrations:
        condition: service_completed_successfully  # Migrations DEVEM rodar antes
    # API só inicia depois que:
    # 1. Postgres está aceitando conexões (healthy)
    # 2. Redis está respondendo a PING (healthy)
    # 3. Migrations terminaram com sucesso (exit code 0)
```

## Profiles: Serviços Condicionais

Profiles permitem definir conjuntos de serviços que são ativados sob demanda. Perfeito para separar ferramentas de debug, observabilidade ou testes.

```yaml
services:
  api:
    # Sem profile → sempre ativo
    build: .
    ports: ["3000:3000"]

  db:
    # Sem profile → sempre ativo
    image: postgres:16-alpine

  # ─── Ferramentas de Debug ───────────────────────
  pgadmin:
    image: dpage/pgadmin4
    profiles: ["debug"]              # Só sobe com --profile debug
    ports: ["8080:80"]
    environment:
      PGADMIN_DEFAULT_EMAIL: admin@local.dev
      PGADMIN_DEFAULT_PASSWORD: admin

  redis-insight:
    image: redis/redisinsight:latest
    profiles: ["debug"]
    ports: ["5540:5540"]

  mailhog:
    image: mailhog/mailhog
    profiles: ["debug"]
    ports:
      - "1025:1025"                  # SMTP
      - "8025:8025"                  # UI

  # ─── Observabilidade ─────────────────────────────
  prometheus:
    image: prom/prometheus
    profiles: ["observability"]
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml
    ports: ["9090:9090"]

  grafana:
    image: grafana/grafana
    profiles: ["observability"]
    ports: ["3001:3000"]
    volumes:
      - grafana-data:/var/lib/grafana

  # ─── Testes ──────────────────────────────────────
  test-runner:
    build:
      context: .
      target: test
    profiles: ["test"]
    depends_on:
      db:
        condition: service_healthy
    command: npm run test:integration
    environment:
      DATABASE_URL: postgres://postgres:test@db:5432/myapp_test
```

```bash
# Uso de profiles
docker compose up -d                           # Apenas api + db
docker compose --profile debug up -d           # + pgadmin, redis-insight, mailhog
docker compose --profile observability up -d   # + prometheus, grafana
docker compose --profile debug --profile observability up -d  # Tudo

# Executar testes
docker compose --profile test run --rm test-runner
```

## Secrets e Configs

```yaml
services:
  api:
    secrets:
      - db_password
      - api_key
    configs:
      - source: nginx_conf
        target: /etc/nginx/nginx.conf
        mode: 0440

# Secrets são montados em /run/secrets/<nome> como arquivos
secrets:
  db_password:
    file: ./secrets/db_password.txt   # De arquivo local
  api_key:
    environment: "API_KEY"            # De variável de ambiente

configs:
  nginx_conf:
    file: ./config/nginx.conf
```

```javascript
// Lendo secret no código (Node.js)
import { readFileSync } from 'fs';

const dbPassword = process.env.DB_PASSWORD
  || readFileSync('/run/secrets/db_password', 'utf8').trim();
```

## Networking Avançado

### Redes Customizadas e Isolamento

```yaml
services:
  api:
    networks:
      - frontend       # Acessível pelo load balancer
      - backend         # Acessa banco e cache

  nginx:
    networks:
      - frontend       # Exposta externamente

  db:
    networks:
      - backend         # Isolada — só API acessa

  cache:
    networks:
      - backend

  worker:
    networks:
      - backend

networks:
  frontend:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/24

  backend:
    driver: bridge
    internal: true       # SEM acesso à internet (isolamento total)
    ipam:
      config:
        - subnet: 172.21.0.0/24
```

### DNS Resolution e Aliases

```yaml
services:
  api-v1:
    image: app:v1
    networks:
      app-net:
        aliases:
          - api              # Ambas as versões respondem por "api"

  api-v2:
    image: app:v2
    networks:
      app-net:
        aliases:
          - api              # Round-robin DNS para canary testing

networks:
  app-net:
    driver: bridge
```

```bash
# DNS interno do Docker Compose
# Dentro de qualquer container na mesma rede:
nslookup db        # → 172.21.0.2
nslookup api       # → 172.20.0.3 (ou round-robin se múltiplos)

# O Docker embute um DNS resolver em 127.0.0.11
# Resolução: nome do serviço → IP do container
# Se replicas > 1, retorna múltiplos IPs (DNS round-robin)
```

## Dados Persistentes: Volumes e Bind Mounts

```yaml
services:
  db:
    image: postgres:16-alpine
    volumes:
      - pgdata:/var/lib/postgresql/data        # Named volume
      - ./scripts/init.sql:/docker-entrypoint-initdb.d/init.sql:ro  # Init script
      - ./backups:/backups                     # Bind mount para backups

  api:
    build: .
    volumes:
      - ./src:/app/src                         # Bind mount (hot reload)
      - /app/node_modules                      # Anonymous volume
      - build-cache:/app/.cache                # Cache persistente

volumes:
  pgdata:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /data/postgres                   # Diretório específico no host

  build-cache:
    # Volume padrão — Docker gerencia localização

  # Volume externo (criado fora do Compose)
  shared-data:
    external: true
    name: my-shared-volume
```

```bash
# Quando usar o quê:
# Named volume   → dados de banco, caches persistentes (Docker gerencia)
# Bind mount      → código em desenvolvimento (hot reload)
# Anonymous volume → proteger diretórios do container (node_modules)
# tmpfs           → dados sensíveis temporários (em memória, nunca em disco)
# External volume → compartilhar entre múltiplos compose projects

# Backup de volume
docker run --rm \
  -v pgdata:/source:ro \
  -v $(pwd)/backups:/backup \
  alpine tar czf /backup/pgdata-$(date +%Y%m%d).tar.gz -C /source .
```

## Extends e Include

### Extends — Herança de Configuração

```yaml
# compose.base.yaml — Configuração base compartilhada
services:
  node-base:
    build:
      context: .
      target: base
    environment:
      NODE_ENV: ${NODE_ENV:-development}
    logging:
      driver: json-file
      options:
        max-size: "10m"

# compose.yaml
services:
  api:
    extends:
      file: compose.base.yaml
      service: node-base
    build:
      target: production           # Override do target
    ports:
      - "3000:3000"

  worker:
    extends:
      file: compose.base.yaml
      service: node-base
    command: node dist/worker.js
```

### Include — Composição Modular

```yaml
# compose.yaml
include:
  - path: ./services/database/compose.yaml
  - path: ./services/cache/compose.yaml
  - path: ./services/monitoring/compose.yaml
    env_file: ./services/monitoring/.env

# Cada arquivo incluído define seus próprios services, volumes, networks
# Sem conflito de nomes — cada include é seu próprio projeto
```

## Development Workflows: Watch Mode

```yaml
# compose.yaml — Watch mode para desenvolvimento
services:
  api:
    build:
      context: .
      target: development
    develop:
      watch:
        # Sync: copia arquivos para dentro do container
        - action: sync
          path: ./src
          target: /app/src
          ignore:
            - "**/*.test.ts"

        # Sync + restart: reinicia o processo do container
        - action: sync+restart
          path: ./config
          target: /app/config

        # Rebuild: reconstrói a imagem inteira
        - action: rebuild
          path: package.json
          # Mudança em package.json → rebuild completo

  frontend:
    build:
      context: ./frontend
    develop:
      watch:
        - action: sync
          path: ./frontend/src
          target: /app/src
```

```bash
# Iniciar com watch mode
docker compose watch

# Agora ao salvar um arquivo em ./src:
# 1. Compose detecta a mudança
# 2. Sincroniza para /app/src dentro do container
# 3. Nodemon/Vite detecta e faz hot reload
# Sem necessidade de bind mounts (funciona melhor em macOS/Windows)
```

## Gestão de Ambientes

```yaml
# compose.yaml — Base
services:
  api:
    build: .
    env_file: .env

# compose.override.yaml — Automaticamente carregado em dev
services:
  api:
    build:
      target: development
    volumes:
      - ./src:/app/src
    ports:
      - "9229:9229"         # Debug port
    environment:
      LOG_LEVEL: debug

# compose.production.yaml — Usado explicitamente em produção
services:
  api:
    build:
      target: production
    deploy:
      replicas: 3
      resources:
        limits:
          memory: 512M
    environment:
      LOG_LEVEL: warn
```

```bash
# Desenvolvimento (compose.yaml + compose.override.yaml automático)
docker compose up

# Produção (compose.yaml + compose.production.yaml explícito)
docker compose -f compose.yaml -f compose.production.yaml up -d

# Validar configuração final (merge de todos os arquivos)
docker compose -f compose.yaml -f compose.production.yaml config

# Variáveis de ambiente têm precedência:
# 1. Shell environment
# 2. .env file
# 3. Dockerfile ENV
```

## Scaling e Considerações de Produção

```bash
# Escalar serviço (requer que container_name NÃO esteja definido)
docker compose up -d --scale api=3 --scale worker=5

# Ver status de todos os containers
docker compose ps --format "table {{.Name}}\t{{.Status}}\t{{.Ports}}"

# Logs de múltiplos serviços
docker compose logs -f api worker --since 5m --tail 100

# Atualizar apenas um serviço sem derrubar outros
docker compose up -d --no-deps --build api

# Health status
docker compose ps --format json | jq '.[] | {name: .Name, health: .Health}'
```

### Compose em Produção — Quando Sim e Quando Não

```
✅ Use Compose em produção quando:
- Aplicação roda em servidor único
- Equipe pequena, sem necessidade de orquestração distribuída
- Startup, MVP, projetos de baixa complexidade
- Ambientes de staging/preview

❌ Migre para Kubernetes quando:
- Precisa de múltiplos hosts (alta disponibilidade)
- Auto-scaling baseado em métricas
- Rolling updates com rollback automático
- Service mesh, network policies avançadas
- Equipe e carga justificam a complexidade

⚠️ Limitações do Compose em produção:
- Sem orquestração multi-host nativa
- Sem auto-healing sofisticado (apenas restart policy)
- Sem rolling updates reais (recria containers)
- Sem service mesh / mTLS nativo
- Sem auto-scaling baseado em métricas
```

Docker Compose é a ferramenta ideal para ambientes de desenvolvimento e cenários de produção single-host. Dominar suas funcionalidades avançadas — profiles, healthchecks condicionais, watch mode e gestão de secrets — é fundamental para construir workflows de desenvolvimento eficientes e reproduzíveis.
