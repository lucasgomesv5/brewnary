---
title: "CI/CD Avançado"
description: "Pipelines como código, progressive delivery, GitOps com ArgoCD, feature flags, segurança em pipelines e otimização de builds"
track: "infra"
order: 7
section: "Entrega e Operações"
priority: "high"
tags: ["ci-cd", "gitops", "argocd", "feature-flags", "canary", "pipeline"]
prerequisites: []
keyTakeaways:
  - "Pipeline como código versionado no repositório garante reprodutibilidade e auditabilidade de todo o processo de entrega"
  - "Progressive delivery com canary analysis e feature flags separa deploy (infraestrutura) de release (funcionalidade), reduzindo risco"
  - "GitOps com ArgoCD/Flux torna o Git a fonte de verdade para o estado do cluster, com reconciliação contínua e rollback via git revert"
---

## Pipeline como Código

A pipeline de CI/CD deve ser tratada como código: versionada, revisada, testada. Cada repositório contém sua própria definição de pipeline.

### Pipeline Completa de Produção

```yaml
# .github/workflows/production.yml
name: Production Pipeline

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true  # Cancela runs anteriores do mesmo branch

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

permissions:
  contents: read
  packages: write
  id-token: write           # OIDC para autenticação sem secrets

jobs:
  # ─── Quality Gates ──────────────────────────────
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
      - run: npm ci
      - run: npm run lint
      - run: npm run type-check

  test:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_PASSWORD: test
          POSTGRES_DB: test
        ports: ['5432:5432']
        options: >-
          --health-cmd pg_isready
          --health-interval 5s
          --health-timeout 3s
          --health-retries 10
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
      - run: npm ci
      - run: npm run test -- --coverage --forceExit
        env:
          DATABASE_URL: postgres://postgres:test@localhost:5432/test
      - uses: codecov/codecov-action@v4

  # ─── Security Scan ─────────────────────────────
  security:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: npm audit --audit-level=high
      - uses: aquasecurity/trivy-action@master
        with:
          scan-type: fs
          severity: HIGH,CRITICAL
          exit-code: 1
      # SAST — análise estática de segurança
      - uses: returntocorp/semgrep-action@v1
        with:
          config: >-
            p/security-audit
            p/secrets
            p/owasp-top-ten

  # ─── Build e Push ──────────────────────────────
  build:
    needs: [lint, test, security]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tag: ${{ steps.meta.outputs.tags }}
    steps:
      - uses: actions/checkout@v4

      # OIDC — autenticação sem secrets estáticos
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::123456:role/github-actions
          aws-region: us-east-1

      - uses: docker/setup-buildx-action@v3

      - uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,prefix=
            type=ref,event=branch

      - id: build
        uses: docker/build-push-action@v6
        with:
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          platforms: linux/amd64,linux/arm64
          cache-from: type=gha
          cache-to: type=gha,mode=max
          provenance: true                # SLSA provenance
          sbom: true                      # Software Bill of Materials

  # ─── Deploy Staging ────────────────────────────
  deploy-staging:
    needs: build
    runs-on: ubuntu-latest
    environment:
      name: staging
      url: https://staging.empresa.com
    steps:
      - uses: actions/checkout@v4
      - name: Update image tag in GitOps repo
        run: |
          # GitOps: atualiza tag no repositório de manifests
          gh api repos/empresa/k8s-manifests/dispatches \
            -f event_type=deploy \
            -f client_payload='{"env":"staging","image":"${{ needs.build.outputs.image-tag }}"}'

  # ─── Testes E2E ────────────────────────────────
  e2e:
    needs: deploy-staging
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: npx playwright install --with-deps chromium
      - run: npx playwright test
        env:
          BASE_URL: https://staging.empresa.com
      - uses: actions/upload-artifact@v4
        if: always()
        with:
          name: playwright-report
          path: playwright-report/

  # ─── Deploy Production ─────────────────────────
  deploy-production:
    needs: e2e
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://empresa.com
    steps:
      - name: Deploy via GitOps
        run: |
          gh api repos/empresa/k8s-manifests/dispatches \
            -f event_type=deploy \
            -f client_payload='{"env":"production","image":"${{ needs.build.outputs.image-tag }}"}'
```

## Trunk-Based Development vs GitFlow

```
Trunk-Based Development:                GitFlow:
─────────────────────────              ──────────────────
main ─●─●─●─●─●─●─●─●─●─             main ──●──────●──────●──
       \/ \/ \/                                \    /  \    /
  short-lived branches                  develop ─●──●────●──●──
  (horas, max 1-2 dias)                          │       │
                                        feature/x──●──●──┘
                                        feature/y────●──●──┘

Trunk-Based:                           GitFlow:
✅ Integração contínua real            ❌ Branches longa vida → merge hell
✅ Deploy contínuo (CD)                ❌ Release branches complexos
✅ Feature flags para WIP              ✅ Bom para software com versões
✅ Menos conflitos                     ✅ Releases planejadas
✅ Recomendado por DORA/Google         ❌ Mais lento para entregar

Recomendação: Trunk-Based para SaaS/web apps.
GitFlow apenas para software com releases versionadas (mobile, libs).
```

## Feature Flags: Separar Deploy de Release

```javascript
// Feature flags permitem:
// 1. Deploy código para 100% dos servidores
// 2. Ativar feature para X% dos usuários
// 3. Rollback instantâneo (desliga a flag)

// Com Unleash (open source) ou LaunchDarkly (SaaS)
import { UnleashClient } from 'unleash-proxy-client';

const unleash = new UnleashClient({
  url: 'https://unleash.empresa.com/api/frontend',
  clientKey: process.env.UNLEASH_CLIENT_KEY,
  appName: 'api',
});

await unleash.start();

// Toggle simples
if (unleash.isEnabled('new-checkout-flow')) {
  return renderNewCheckout();
}
return renderOldCheckout();

// Gradual rollout (percentual)
// Configurado no Unleash: 5% → 25% → 50% → 100%
if (unleash.isEnabled('new-payment-gateway', { userId: user.id })) {
  return processWithNewGateway(payment);
}
return processWithOldGateway(payment);

// Variantes (A/B testing)
const variant = unleash.getVariant('pricing-page', { userId: user.id });
// variant.name: "control" | "variant-a" | "variant-b"
// variant.payload: { price: "$9.99" }
```

```yaml
# Configuração de feature flag no Unleash
# Estratégias disponíveis:
# - gradualRollout: percentual (5%, 25%, 50%, 100%)
# - userIds: lista específica de users (beta testers)
# - remoteAddress: por IP/CIDR
# - applicationHostname: por instância
# - flexibleRollout: combinação de critérios
```

## Progressive Delivery: Canary e Traffic Shifting

### Canary com Flagger (Kubernetes)

```yaml
# Flagger automatiza canary analysis no Kubernetes
apiVersion: flagger.app/v1beta1
kind: Canary
metadata:
  name: api
  namespace: production
spec:
  targetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: api

  service:
    port: 80
    targetPort: 3000
    gateways:
      - public-gateway.istio-system.svc.cluster.local
    hosts:
      - api.empresa.com

  analysis:
    # Intervalo entre verificações
    interval: 1m
    # Número de verificações bem-sucedidas para promoção
    threshold: 10
    # Máximo de verificações falhadas antes de rollback
    maxWeight: 50
    # Incremento de tráfego por step
    stepWeight: 10
    # 0% → 10% → 20% → 30% → 40% → 50% → promote para 100%

    metrics:
      - name: request-success-rate
        thresholdRange:
          min: 99.0                  # Mínimo 99% de sucesso
        interval: 1m

      - name: request-duration
        thresholdRange:
          max: 500                   # Máximo 500ms p99
        interval: 1m

    webhooks:
      # Load test durante canary
      - name: load-test
        type: rollout
        url: http://flagger-loadtester.test/
        metadata:
          cmd: "hey -z 1m -q 10 -c 2 http://api-canary.production:80/"

      # Notificação no Slack
      - name: notify-slack
        type: event
        url: http://flagger-slack.production/
```

```
Fluxo do Canary Deploy:
1. Nova imagem detectada no Deployment
2. Flagger cria Deployment canary (api-canary)
3. Direciona 10% do tráfego para canary
4. Analisa métricas (success rate, latência)
5. Se OK: incrementa para 20%, 30%... até 50%
6. Se métricas degradam: rollback automático para 0%
7. Se todas as verificações passam: promote para 100%
```

## GitOps: ArgoCD e Flux

### ArgoCD — Deployment Declarativo

```yaml
# ArgoCD Application — sincroniza Git com cluster
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: api-production
  namespace: argocd
spec:
  project: production

  source:
    repoURL: https://github.com/empresa/k8s-manifests.git
    targetRevision: main
    path: environments/production/api
    helm:
      valueFiles:
        - values.yaml
        - values-production.yaml

  destination:
    server: https://kubernetes.default.svc
    namespace: production

  syncPolicy:
    automated:
      prune: true              # Remove recursos que não estão no Git
      selfHeal: true           # Reverte mudanças manuais (kubectl edit)
      allowEmpty: false
    syncOptions:
      - CreateNamespace=true
      - PruneLast=true
      - ApplyOutOfSyncOnly=true
    retry:
      limit: 5
      backoff:
        duration: 5s
        factor: 2
        maxDuration: 3m

  # Notificações
  info:
    - name: slack
      value: "#deploys"
```

```
GitOps Flow:
1. Dev faz merge na main do app repo
2. CI build + push imagem para registry
3. CI atualiza tag no GitOps repo (k8s-manifests)
4. ArgoCD detecta mudança no GitOps repo
5. ArgoCD sincroniza: aplica manifests no cluster
6. ArgoCD verifica health dos recursos
7. Rollback: git revert no GitOps repo → ArgoCD reverte

Benefícios:
- Git é a fonte de verdade (auditabilidade total)
- Drift detection: mudanças manuais são revertidas
- Rollback = git revert (simples e rastreável)
- Ambiente = branch/path no Git repo
```

### Estrutura do Repositório GitOps

```
k8s-manifests/
├── base/                          # Manifests base (Kustomize)
│   ├── api/
│   │   ├── deployment.yaml
│   │   ├── service.yaml
│   │   ├── ingress.yaml
│   │   ├── hpa.yaml
│   │   └── kustomization.yaml
│   └── worker/
│       └── ...
├── environments/
│   ├── staging/
│   │   ├── api/
│   │   │   ├── kustomization.yaml  # Patches sobre base
│   │   │   └── patch-replicas.yaml
│   │   └── kustomization.yaml
│   └── production/
│       ├── api/
│       │   ├── kustomization.yaml
│       │   ├── patch-replicas.yaml
│       │   └── patch-resources.yaml
│       └── kustomization.yaml
└── argocd/
    ├── projects.yaml
    └── applications.yaml
```

## Testing em Pipelines

### Contract Tests

```yaml
# Contract tests verificam que APIs não quebraram contratos
  contract-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Run Pact tests
        run: |
          npm run test:contract
          # Publica contratos no Pact Broker
          npx pact-broker publish pacts/ \
            --consumer-app-version=${{ github.sha }} \
            --broker-base-url=${{ secrets.PACT_BROKER_URL }}
      - name: Can I Deploy?
        run: |
          npx pact-broker can-i-deploy \
            --pacticipant=api \
            --version=${{ github.sha }} \
            --to-environment=production
```

### Chaos Engineering em Pipeline

```yaml
  chaos-test:
    needs: deploy-staging
    runs-on: ubuntu-latest
    steps:
      - name: Run Litmus chaos experiment
        run: |
          kubectl apply -f - <<EOF
          apiVersion: litmuschaos.io/v1alpha1
          kind: ChaosEngine
          metadata:
            name: api-chaos
            namespace: staging
          spec:
            appinfo:
              appns: staging
              applabel: app=api
            chaosServiceAccount: litmus-admin
            experiments:
              - name: pod-delete
                spec:
                  components:
                    env:
                      - name: TOTAL_CHAOS_DURATION
                        value: '30'
                      - name: CHAOS_INTERVAL
                        value: '10'
                      - name: FORCE
                        value: 'false'
          EOF

      - name: Verify steady state
        run: |
          # Verificar que a aplicação se recuperou
          sleep 60
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://staging.empresa.com/health)
          if [ "$STATUS" != "200" ]; then
            echo "App não se recuperou do chaos test!"
            exit 1
          fi
```

## Infrastructure Pipelines (Terraform em CI)

```yaml
# .github/workflows/terraform.yml
name: Terraform

on:
  pull_request:
    paths: ['infra/**']
  push:
    branches: [main]
    paths: ['infra/**']

jobs:
  plan:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      id-token: write
    steps:
      - uses: actions/checkout@v4

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::123456:role/terraform
          aws-region: us-east-1

      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.7.0

      - run: terraform init
        working-directory: infra/production

      - run: terraform validate
        working-directory: infra/production

      - id: plan
        run: terraform plan -no-color -out=tfplan
        working-directory: infra/production

      # Comentário no PR com o plan
      - uses: actions/github-script@v7
        if: github.event_name == 'pull_request'
        with:
          script: |
            const output = `#### Terraform Plan
            \`\`\`
            ${{ steps.plan.outputs.stdout }}
            \`\`\``;
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            });

  apply:
    needs: plan
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    runs-on: ubuntu-latest
    environment: production-infra
    steps:
      - uses: actions/checkout@v4
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::123456:role/terraform
          aws-region: us-east-1
      - uses: hashicorp/setup-terraform@v3
      - run: terraform init && terraform apply -auto-approve
        working-directory: infra/production
```

## Secrets em CI/CD

```yaml
# OIDC — autenticação sem secrets estáticos (recomendado)
# GitHub Actions assume IAM Role via token OIDC
- uses: aws-actions/configure-aws-credentials@v4
  with:
    role-to-assume: arn:aws:iam::123456:role/github-actions
    aws-region: us-east-1
    # Nenhum secret estático necessário!

# HashiCorp Vault — secrets dinâmicos
- name: Import secrets from Vault
  uses: hashicorp/vault-action@v3
  with:
    url: https://vault.empresa.com
    method: jwt
    role: github-actions
    secrets: |
      secret/data/production/db password | DB_PASSWORD ;
      secret/data/production/api jwt_secret | JWT_SECRET ;
```

## Otimização de Builds

```yaml
# Caching agressivo
  build:
    steps:
      # Cache de dependências
      - uses: actions/cache@v4
        with:
          path: |
            ~/.npm
            node_modules
          key: deps-${{ hashFiles('package-lock.json') }}
          restore-keys: deps-

      # Cache de Docker layers
      - uses: docker/build-push-action@v6
        with:
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Paralelização — jobs independentes rodam em paralelo
      # lint, test, security → todos em paralelo
      # build → após todos passarem
      # deploy → após build

# Build matrix para testes multi-versão
  test:
    strategy:
      matrix:
        node-version: [18, 20, 22]
        os: [ubuntu-latest, macos-latest]
      fail-fast: false    # Não cancela outros se um falhar

# Remote build cache (Turborepo/Nx)
  build:
    env:
      TURBO_TOKEN: ${{ secrets.TURBO_TOKEN }}
      TURBO_TEAM: empresa
    steps:
      - run: npx turbo build --cache-dir=.turbo
```

CI/CD avançado não é apenas sobre automatizar o deploy — é sobre criar uma esteira de entrega que inspire confiança. Cada commit na main deve poder ir para produção automaticamente, com quality gates, security scans, progressive delivery e rollback automático garantindo que problemas sejam detectados e revertidos antes de afetar usuários.
